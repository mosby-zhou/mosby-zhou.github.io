{"pages":[{"title":"","text":"About me","link":"/about/index.html"}],"posts":[{"title":"人工神经网络和反向传播算法","text":"最近因为人机大战, 人工智能火得不行, 作为技术人员, 自然对这种终极技术产生了一定的兴趣, 翻了一些论文看了一些文档以后, 在这里记录一点学习心得吧. 人工智能原理人工智能, 这个标题好像很厉害的样子, 实际上原理很简单, 就是一个强大的神经网络. 而神经网络又好像很厉害的样子, 下面就来看看神经网络是什么东西. 神经网络基本概念在深度学习中的神经网络, 和人体的神经网络一点关系都没有, 只是一个相似的名词而已. 这里的神经网络是由很多个神经节点构成, 可能有多层, 每层有n个, 就像n维数组一样, 每个神经节点都是一个多参数函数, 返回值是和下一层网络节点数量相同的sigmoid函数值. 同一层的每个节点的输出值经过求权和相加以后, 作为下一层的参数以供计算. 这便是神经网络最基本的实现方式. 原理在宇宙中, 大概除了量子存在海森堡测不准原理以外, 其他的都是可测量和计算的. 如万有引力, 牛顿定律, E=mc^2等. 这种是简单的原理, 上升到复杂一点的, 如火箭升空, 需要多大的推动力, 能带多少燃料和多少负载, 能飞到什么地方和什么时候到, 都是可以计算出来的, 只是需要的条件和参数比较多. 以此类推到更复杂的情况, 可以得到, 任何事情或者说是变化都是可以计算出来的, 只是需要你传入准确的参数. 而在以前, 这些计算方法都是由人类创造和推出, 而在神经网络中, 是由算法和数据生成. 如以前的天气预报, 是通过各种风力风向温度湿度等, 传入一个复杂计算函数中得到结果, 往往会出现不准确的情况, 因为计算函数不完善, 而这种计算函数又是很难构建完善的. 而现在出现了人工智能加大数据分析预测天气情况, 比以前准确了许多, 而且会一直进化和提升. 假设以前的计算方法为, 指定一个函数f(x1,x2,x3...) = ax1 + bx2 + cx3 + ..., 传入足够的值来得到结果, 那么里面的参数列表a,b,c等值是通过历史数据计算得来. 计算参数起来就会特别复杂和麻烦, 而且并不能动态生成这个函数, 而神经网络则是类似这样, 不过是生成一个动态的参数表格. 先来看看单个的神经元, 为了方便计算和得出结果, 需要使神经元的输入值都为(0,1), 输出值也为(0,1), 这样在计算结果时, 接近1的为真, 接近0的为假. 为了将任意值都转换为(0,1)的形式, 需要定义一个sigmoid函数, sigmoid(z) = 1 / (1 + e^-z). 当输入值为很大的正数时, 那么e^-z值为很小, 函数返回值接近1, 当输入值为很大的负数时, e^-z变大, 函数返回值接近0, 而在中间值变化时, 该函数返回值也是平滑的, 所以可以比较好的模拟(0,1)的返回值. 不过如果你需要, 也可以实现一个其他的sigmoid函数, 只要返回值为平滑的(0,1)即可. 在看传入sigmoid函数的参数, 应该是传入值和该神经元初步计算得到的值. 表示为f(x1,x2...) = a1x1 + a2x2 + ... + b. 所以确定一个神经元, 只需要确定它的a1-an的值, 和偏移量b即可. 然后来看一个最简单的单层神经网络, 有一个输入层, 一个处理层, 一个输出层. 输入层输入值为{x1,x2,x3,x4}, 处理层有3个神经元, 那么它们的处理函数应该是f[a1](x1,x2,x3,x4) = sigmoid(a1a1 * x1 + a1a2 * x2 + a1a3 * x3 + a1a4 * x4 + a1b), f[a2](x1,x2,x3,x4) = sigmoid(a2a1 * x1 + a2a2 * x2 + a2a3 * x3 + a2a4 * x4 + a2b), f[a3](x1,x2,x3,x4) = sigmoid(a3a1 * x1 + a3a2 * x2 + a3a3 * x3 + a3a4 * x4 + a3b), 输出层只有一个神经元, 处理函数f[b1](xa1,xa2,xa3) = sigmoid(b1a1 * xa1 + b1a2 * xa2 + b1a3 * xa3 + b1b). 假设上面的神经网络是对真实情况的反应, 设y(x)为真实输出, f(x)为神经网络的输出. 在给定x的情况下, 需要找到合适的参数, 使f(x)值尽量等于y(x)的值. 那么问题就变成: 需要一个算法, 找到所有的参数an和bnb, 是输出值尽量靠近真实值. 为了知道如何才算靠近真实值, 需要定义一个代价函数: C(w,b) = E(x)(||y(x) - a||^2) / 2n, 这里面的a即为f(x)计算得到的值, E(x)(...)即为对所有的x值求和, 反映到实际即对于所有训练数据x, n为训练数据数量, 得到一个整体训练数据的误差, w为所有an的向量, b代表偏移. 而训练神经网络的目标, 便是让C(w,b)变得尽可能小. 现在, 将输入值x向量化看待, 每层的输入值为xn = {xn1,xn2,xn3,xn4}, 每层的计算函数为wn = {{a1a1,a1a2,a1a3,a1a4},{a2a1,a2a2,a2a3,a2a4},{a3a1,a3a2,a3a3,a3a4}}, 偏移量为bn = {b1b,b2b,b3b}, 那么在计算输出值的时候, 使用向量计算, 即可得到输出值f(x) = sigmoid(wn * xn + bn), 那么计算该层的输出值即为f(xi) = sigmoid(wn * x[i-1] + bn), 令z[i] = wn * x[i-1] + bn, 那么f(xi) = sigmoid(z[i]), 令z[i][j]为第[i]层的第[j]个值, 那么z[a][1]为第a层第1个值, 即为f[a1](x1,x2,x3,x4)所计算的值, 即z[a][1] = a1a1 * x1 + a1a2 * x2 + a1a3 * x3 + a1a4 * x4 + a1b, 那么z[i][j] = E(k)(a[i]a[j][k] * x[k]) + b[i][j]. 下面来看看反向传播算法的含义吧. 假设在训练好的神经网络中, 每个神经元都有正确的参数, 而第i层第j个神经元被人为改变成了错误的参数. 那么在输入x的值时, 在计算结果经过这个神经元的时候, 值与原来的正确值有一点改变, 设改变值为Δz[i][j], 这就导致了神经元输出变成了f[i][j](x) = sigmoid(z[i][j] + Δz[i][j]). 这个改变将会在后续的网络中传播, 导致全部代价改变. 因为原始的代价函数为C = (y - a)^2 / 2, a = E(i,j)(z[i][j]), 那么代价改变值可以表示为ΔC = C′ * Δz[i][j], 那么C′ = d(C) / d(z[i][j]). 可以看出, 如果改变Δz[i][j], 便可以使C变化, 如果正确的改变Δz[i][j], 可以使得C值变小. 设第i层第j个神经元的错误量为δij = d(c) / d(z[i][j]), 那么它对i+1层的第 n 个神经元影响为a[i + 1][n] * δij. 在训练神经网络中, 参数计算是靠梯度批量下降法来寻找合适参数的, 那么便需要求误差函数对每个权重a和偏移b的偏导数. 如果是正常求值, 那么需要从输入节点开始, 将每个节点对下个节点的影响导数求出, 一直求到对最终结果的影响. 然后再根据最终结果对每个节点的偏导值, 来调整它们的权重和偏导数. 而反向传播算法则是改进这个计算方法的算法. 反向传播从最后一层节点开始计算它之前的每个节点对它的影响, 然后再依次前推, 那么一次性就能计算出所有的节点对最后一个节点的偏导值, 极大的简化了求值速度. 这便是反向传播的核心思想, 即快速计算出最终结果对每个节点参数的偏导值, 然后再根据梯度下降算法来更新每个节点的参数, 从而降低C的值, 进化神经网络. 而具体如何实现, 又是一个比较大的内容了, 可以参考这篇文章, 使用python实现一个简单的神经网络来识别图片.","link":"/2016/03-13-ann-and-backpropagation/"},{"title":"动态规划算法","text":"在以前做ACM的时候, 总是绕不开DP算法解题, 刚好又在项目里遇到了, 就总结一下吧. DP算法又叫动态规划算法, 从字面可以看出它是动态的. 那么是什么样的动态呢, 可以这样理解: 根据之前的计算结果动态决定下一步的计算结果. 从一个简单的题目开始: 使用1,3,5三个数, 组成13, 需要的数字最少的方案. 一眼就能看出来是5 + 5 + 3. 那么从算法角度来看看这个是怎么实现的吧. 要判断13由多少构成, 那么就可以把问题看成为: 12, 10, 8这三个数分别最小由多少构成. 这样可以一直推到最小值1. 那么算法的步骤即从1开始计算最小构成值为多少. 123456789101112131415160 = 0 -&gt; 0不需要参数即可构成1 = 0 + 1 =&gt; [1] -&gt; 1个(1)即可构成2 = 1 + 1 =&gt; [2] -&gt; 第一个(1)是上一步的计算值, 第二个(1)是其中一个数3 = 2 + 1 =&gt; [3]/ 0 + 3 =&gt; [1] -&gt; 2 + 1中, (2)是上一步的计算值, 这里出现了分化, 3 可以由3个值构成, 也可以由1个值构成, 那么取小, 由1个值构成的供之后计算4 = 3[1] + 1 =&gt; [2]/ 1[1] + 3 =&gt; [2]5 = 4[2] + 1 =&gt; [3]/ 2[2] + 3 =&gt; [3]/ 0[0] + 5 =&gt; [1] -&gt; 取小值16 = 5[1] + 1 =&gt; [2]/ 3[1] + 3 =&gt; [2]/ 1[1] + 5 =&gt; [2]7 = 6[2] + 1 / 4[2] + 3 / 2[2] + 5 =&gt; [3]8 = 7[3] + 1 / 5[1] + 3 / 3[1] + 5 =&gt; [2]9 = 8[2] + 1 / 6[2] + 3 / 4[2] + 5 =&gt; [3]10 = 9[3] + 1 =&gt; [4]/ 7[3] + 3 =&gt; [4]/ 5[1] + 5 =&gt; [2] -&gt; 取小值211 = 10[2] + 1 / 8[2] + 3 / 6[2] + 5 =&gt; [3]12 = 11[3] + 1 / 9[3] + 3 / 7[3] + 5 =&gt; [4]13 = 12[4] + 1 =&gt; [5]/ 10[2] + 3 =&gt; [3]/ 8[2] + 5 =&gt; [3] -&gt; 取小值3而且可以从构成中看见, 13 = 10 + 3 / 8 + 5, 10 = 5 + 5, 8 = 5 + 3 这便是动态规划算法的原理, 现在用代码来实现一遍: 1234567891011121314int lis(int n){ //计算n由最少多少个数字构成 int *d = new int[n + 1]; //计算出0-n的全部 int a[] = {1, 3, 5}; d[0] = 0; //和为0的时候不需要元素构成 for (int i = 1; i &lt;= n; i++){ //从i计算到n d[i] = d[i - 1] + 1; //1为最小元素, 默认为前一个值减最小值加1 for (int j = 0; j &lt; 3; j++){ //循环所有元素 if (a[j] &lt;= i &amp;&amp; d[i - a[j]] + 1 &lt; d[i]){ // 如果n-某元素所需要的构成比当前构成小, 那么取小的构成 d[i] = d[i - a[j]] + 1; } } } return d[n]; // 返回构成的最小值} 接下来看一个复杂一点的问题: 有编号分别为 a,b,c,d,e 的五件物品, 它们的重量分别是 2,2,6,5,4, 它们的价值分别是 6,3,5,4,6, 现在给你个承重为 10 的背包, 如何让背包里装入的物品具有最大的价值总和. 同样的计算方式: 1234567891011121314151617181920212223242526272829303132int lis(int n){ //计算 n 重量时的最大价值int w[] = { 0, 4, 5, 6, 2, 2 };int v[] = { 0, 6, 4, 5, 3, 6 };int w*length = getArrayLen(w);int \\*\\_d = new int*[w_length];for (int i = 0; i &lt; w_length; i++){d[i] = new int[n + 1]; // 计算出 0-n 的全部}for (int i = 0; i &lt; n + 1 || i &lt; w_length; i++){if (i &lt; n + 1){d[0][i] = 0; // 初始化 0-0 的元素值为 0}if (i &lt; w_length){d[i][0] = 0; // d[x][n]表示放置之前的 x 号物体时, n 承重的时候的价值}}for (int i = 1; i &lt; n + 1; i++){ // 主循环for (int j = 1; j &lt; w_length; j++){ // 遍历每个物体, 填充 d[x], 即当前含有前 j 个物体时的计算承重价值if (i &gt;= w[j]){ // 如果当前承重大于物品重量int a = d[j - 1][i]; // a 为 放置上一个物体时, 承重的价值int b = d[j - 1]i - w[j]] + v[j]; // b 为 放置之前的物体情况下, 如果承重减去当前物体承重, 再加上当前物体的价值 的价值d[j][i] = a &gt; b ? a : b; // 取价值比较大的值}else{ // 如果当前承重小于物品重量, 那么直接和上一个承重的价值相等d[j][i] = d[j - 1][i];}}}return d[w_length - 1][n]; // 放置全部物体的情况下, n 承重的价值}printf(&quot;%4d\\n&quot;, lis(10)); // -&gt; 15","link":"/2016/06-27-dp-dynamic-programming-algorithm/"},{"title":"angularjs provider的区别和使用","text":"moduleangular 可以对一个 module 使用.config 方法来配置这个模块, config 可以注入一个$provide对象, 所有的配置都是通过$provide 的方法调用的.$provide 下有六个方法: provider factory service value constant decorator 它们都有自己的语法糖, 即不是通过.config(['$provide', function($provide){}])调用. providerprovider是最重要的一个方法, 了解provider以后, 会发现factory, service, value三个方法只是provider的语法糖. provieder的源码:123456789function provider(name, provider_) { if (isFunction(provider_) || isArray(provider_)) { provider_ = providerInjector.instantiate(provider_); } if (!provider_.$get) { throw Error('Provider ' + name + ' must define $get factory method.'); } return (providerCache[name + providerSuffix] = provider_);} name是这个 provider 的名称, 在整个 app 里面应该唯一, 否则会覆盖. 如果第二个参数是数组, 则按依赖注入前面的参数, 解析最后一个函数, 如果是函数, 则直接解析. 这两种解析方式函数返回的对象都应该是一个有$get方法的对象. 可以说provider是一个可配置的factory, 可以存在其他配置对象并通过闭包使用. 在 return 地方可以看到, angular 对所有的 provider 都做了缓存, 所以 provider 都是单例模式的, 包括下面的factory, service, value. factory源码:123function factory(name, factoryFn) { return provider(name, { $get: factoryFn });} 简单点说就是生成一个 factory 对象, 对象的属性是 factoryFn 里面 return 的任意值. service源码:12345678function service(name, constructor) { return factory(name, [ '$injector', function ($injector) { return $injector.instantiate(constructor); }, ]);} 和 factory 基本没区别, 只是通过 new 方式调用的, 你可以在 constructor 函数里面直接对 this 设置值(注意通过 this 设置值的时候不能有 return). 也可以和 factory 一样 return 一个对象.区别是通过 this 设置值的时候, 会显示原型(在我们项目里面, 只有 service, 大部分也是 return 对象, 原因是…名字比 factory 易懂…). value源码:12345678function value(name, value) { return factory(name, valueFn(value));}function valueFn(value) { return function () { return value; };} 很简单, 返回一个常量. constant源码:1234function constant(name, value) { providerCache[name] = value; instanceCache[name] = value;} 和 value 的区别是, 不通过 factory 调用, 即配置完成以后就存在了, 可以在 config 里面注入. 而且是在配置完成的时候立即加载运行的.通过代码也可以看到constant也是单例模式, 通过缓存读取的. 123456789101112131415161718192021222324252627app.constant('myConstant', '1');app.config([ 'myConstant', '$provide', function (myConstant, $provider) { console.log(myConstant); },]);//有效app.value('myValue', '1');app.config([ 'myValue', '$provide', function (myValue, $provider) { console.log(myValue); },]);//报错app.value('myValue', '1');app.config([ 'myValueProvider', '$provide', function (myValueProvider, $provider) { console.log(myValueProvider); },]);//有效, 获取的是provider对象, 而不是$get的值, 所以在部分情况下定义provider的属性可以在config里面获取得到. decorator装饰器模式的实现. 可以对 provider 对象进行装饰. 源码:12345678function decorator(serviceName, decorFn) { var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get; origProvider.$get = function () { var origInstance = instanceInjector.invoke(orig$get, origProvider); return instanceInjector.invoke(decorFn, null, { $delegate: origInstance }); };} 简单点说就是把上面通过provider创建的 provide 的$get 方法替换成新的decorFn, 可以达到运行时修改 service 的功能. 实际使用的情况并不多见. 不能对constant定义的值使用, 因为constant不是通过provider创建的, 但能对value 使用. 多次使用decorator对于某个provider来说, 使用过decorator以后, 这个provider的$get方法已经变成decorator里面替换的$get了, 所以再次使用decorator的时候, 等于对改变过的$get使用decorator, 即会造成叠加而不是替换的效果. 这点和provider重复声明会替换不同. $injectorangular.injector()可以获得注入器, 如果有引入 jquery, 则$.fn.injector()也可以使用. $injector.has('serviceName')可以判断是否存在这个服务. $injector.get('serviceName')可以通过服务名获得服务对象. $injector.annotate(ctrls)可以获得 ctrls 的依赖对象.","link":"/2016/08-18-angularjs-provider/"},{"title":"一个angular指令加载顺序异常的排除","text":"起因在表格展示的时候, 有些状态需要切换的, 之前都是直接使用的 checkbox. 有天老大说要优化界面, 把大部分的 checkbox 换成仿 iOS 的 SwitchButton, 开始想得很简单嘛, 新建了一个指令, 考虑了下使用场景和情况, 减少使用成本, 使用方法和原始 input 差不多, 很快就完工了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var switchBtn = function () { return { restrict: 'A', templateUrl: 'views/common/switchBtn.html', css: { href: 'styles/common/switchBtn.css', persist: true }, replace: true, scope: { //传入的ng-model至少是双层结构(至少有个.) ngModel: '=', firstStatus: '@', onChange: '=', text: '=', noText: '=', item: '=', }, controller: function ($scope) {}, link: function ($scope, $element, $attrs) { $element.on('selectstart', function () { return false; }); var firstStatus = false; if ($scope.firstStatus &amp;&amp; $scope.firstStatus.toLowerCase() == 'false') { firstStatus = false; } else if ($scope.firstStatus &amp;&amp; $scope.firstStatus.toLowerCase() == 'true') { firstStatus = true; } if (typeof $scope.ngModel != 'undefined' &amp;&amp; $scope.ngModel != null) { $scope.ngModel = firstStatus || $scope.ngModel; } else { $scope.ngModel = firstStatus; } if ($scope.noText) { $scope.text = ['', '']; } else if (!$scope.noText &amp;&amp; !$scope.text) { $scope.text = ['on', 'off']; } $scope.changeSwitch = function () { $scope.ngModel = !$scope.ngModel; if ($scope.onChange) { if ($scope.onChange($scope.ngModel, $scope.item) == false) { $scope.ngModel = !$scope.ngModel; } } }; $scope.getText = function () { return $scope.text[$scope.ngModel ? 0 : 1]; }; }, };}; 1234&lt;div class=&quot;switch-select&quot; ng-click=&quot;changeSwitch()&quot;&gt; &lt;div class=&quot;switch-bg&quot; ng-class=&quot;{true:'on',false:'off'}[ngModel]&quot;&gt;&lt;span ng-bind=&quot;getText()&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;switch-btn&quot; ng-class=&quot;{true:'on',false:'off'}[ngModel]&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/*按钮大小不符合可根据需要在相关页面css自定义大小*//* demo:.[class] .switch-select { width: 45px; height: 16px; } .[class] .switch-bg { border-radius: 18px; font-size: 12px; } .[class] .switch-bg span { top: 1px; } .[class] .switch-bg.on span { left: 6px; } .[class] .switch-bg.off span { right: 6px; } .[class] .switch-btn { top: 1px; height: 14px; width: 14px; } .[class] .switch-btn.on { left: 30px; } .[class] .switch-btn.off { left: 1px; }*/.switch-select { position: relative; display: inline-block; vertical-align: top; width: 45px; height: 16px; cursor: pointer;}.switch-bg { height: 100%; width: 100%; color: #fff; border-radius: 18px; font-size: 12px; text-transform: uppercase; transition: All 0.3s ease; -webkit-transition: All 0.3s ease; -moz-transition: All 0.3s ease; -o-transition: All 0.3s ease;}.switch-bg span { position: absolute; top: 1px; line-height: 1;}.switch-bg.on { background-color: #00af2c; border: 1px solid #068506;}.switch-bg.on span { left: 6px;}.switch-bg.off { background-color: #ed5b49; border: 1px solid #d2402e;}.switch-bg.off span { right: 6px;}.switch-btn { transition: All 0.3s ease; -webkit-transition: All 0.3s ease; -moz-transition: All 0.3s ease; -o-transition: All 0.3s ease; background: #eee; background: linear-gradient(#eee, #fafafa); border-radius: 100%; height: 14px; position: absolute; top: 1px; width: 14px;}.switch-btn.on { left: 30px;}.switch-btn.off { left: 1px;}.switch-btn .switch-btn-content { background: #dedede; background: linear-gradient(#dedede, #cacaca); border-radius: 50%; height: 9px; width: 9px; margin-top: 5px; margin-left: 5px; padding: 0;} 加入文件, 替换 input, 简单好用, 给老大看效果也还不错, 写好文档和使用方法,&lt;div switch-btn ng-model=&quot;item.isTagEnum&quot; no-text=&quot;true&quot;&gt;&lt;/div&gt;交差完工. 问题过了两天, 突然发现在表单里面刚刚加载完表单以后点击按钮没有反应, 需要等个 2-3s 才有事件. 开始以为是 ng-repate 的性能问题, 一个 repeat 里面指令太多, 试试 trackby - 无效, 试试减少其他元素(因为之前对填入的数据都加了一个 autoInputTips 的)- 无效, 最后发现只是循环这一个指令都比较慢, 而且数据量越少越快, 感觉很奇怪, 断点到指令的 link, 也发现 link 加载顺序不对, 大概有 2-3s 延迟才执行这个指令的 link, 换成其他指令, 即使很复杂的, 也没有出现加载缓慢的情况. 排查仔细排查这个指令和其他指令的不同…一点点删改, 发现删除了css: { href: 'styles/common/switchBtn.css', persist: true },之后, 指令加载就正常了. 确定是 angularcss 的问题. 给指令加 compile. 去看 network, 发现 css 请求是在 controller 和 prelink 执行完了以后执行的, 于是感觉是因为 css 延迟加载导致指令加载顺序异常. 原理去看 angularcss 源码, 在 650 行左右 123456789101112131415161718var directive = $delegate[0];var compile = directive.compile;if (!directive.css) { directive.css = $directive.css;}directive.compile = function () { var link = compile ? compile.apply(this, arguments) : false; return function (scope) { var linkArgs = arguments; $timeout(function () { if (link) { link.apply(this, linkArgs); } }); $rootScope.$broadcast('$directiveAdd', directive, scope); };};return $delegate; 果然如同猜想, 在指令有 css 的时候, angularcss 改写指令的 compile 方法, 返回的新的 postlink 在$timeout 函数里面执行原始的 link, 所以才导致了 link 函数加载顺序异常. 解决确定原因以后解决起来就简单了, 去掉组件的独立引用 css, 合并到 common.scss 里面, 在 index 里面引入. 顺便提醒各项目组尽量少使用独立的 angularcss, 而且只在各自的顶级指令里面使用 angularcss, 会改变加载顺序而且由于使用 timeout, 会影响性能. 后记 改完以后基本使用没问题, 性能也还 ok, 因为也使用的 ng-model 传入值, 用起来感觉和原始 input 差不多, 但是有个问题, 传入的值如果不是对象而是值的时候, 会因为改变的是值而不是对象绑定不到原始值上. 比如&lt;div switch-btn ng-model=&quot;isDisplay&quot; no-text=&quot;true&quot;&gt;&lt;/div&gt;在 switchBtn 指令里面改变$scope.isDel 的值则不会改变原始 scope 里的值, 因为这样传递 scope 是值传递. 那怎么解决呢? 很简单, 用$scope.$parent 来取到原始节点的 scope, 然后改变值就可以了. 123if (!/\\./.test(attr['ngModel'])) { $scope.$parent[attr['ngModel']] = value;} 看到这里可能有人有疑惑… 如果在 ngIf 下面使用, 还是会绑定不到值啊?是的… 可是原本的 input NgModel 就存在这个问题, 为了统一, 也不准备修复原理是 ngIf 创建了自己的$scope:true 的原型继承作用域, 虽然可以通过原型拿到值, 但是绑定的时候还是绑定不到原型链上的. 后记的后记 后来我用的时候嫌麻烦, 改成了最简单的 css 实现. 效果: .mui-switch { width: 52px; height: 31px; position: relative; border: 1px solid #dfdfdf; background-color: #fdfdfd; box-shadow: #dfdfdf 0 0 0 0 inset; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-clip: content-box; display: inline-block; -webkit-appearance: none; -moz-appearance: none; user-select: none; outline: none; } input[type=\"checkbox\"].mui-switch:focus { outline: #fff none 0; } .mui-switch:before { content: ''; width: 29px; height: 29px; position: absolute; top: 0px; left: 0; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-color: #fff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4); } .mui-switch:checked { box-shadow: #64bd63 0 0 0 16px inset; /*border-color: #64bd63; background-color: #64bd63;*/ border-color: #52a4ff; background-color: #52a4ff; } .mui-switch:checked:before { left: 21px; } .mui-switch.mui-switch-animbg { transition: background-color ease 0.4s; } .mui-switch.mui-switch-animbg:before { transition: left 0.3s; } .mui-switch.mui-switch-animbg:checked { box-shadow: #dfdfdf 0 0 0 0 inset; /*background-color: #64bd63;*/ background-color: #52a4ff; transition: border-color 0.4s, background-color ease 0.4s; } .mui-switch.mui-switch-animbg:checked:before { transition: left 0.3s; } .mui-switch.mui-switch-anim { transition: border cubic-bezier(0, 0, 0, 1) 0.4s, box-shadow cubic-bezier(0, 0, 0, 1) 0.4s; } .mui-switch.mui-switch-anim:before { transition: left 0.3s; } .mui-switch.mui-switch-anim:checked { /*box-shadow: #64bd63 0 0 0 16px inset; background-color: #64bd63;*/ box-shadow: #52a4ff 0 0 0 16px inset; background-color: #52a4ff; transition: border ease 0.4s, box-shadow ease 0.4s, background-color ease 1.2s; } .mui-switch.mui-switch-anim:checked:before { transition: left 0.3s; } .mui-switch.mui-switch-middle { height: 26px; width: 44px; } .mui-switch.mui-switch-middle:before { width: 24px; height: 24px; } .mui-switch.mui-switch-middle:checked:before { left: 18px; } } } 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124.mui-switch { width: 52px; height: 31px; position: relative; border: 1px solid #dfdfdf; background-color: #fdfdfd; box-shadow: #dfdfdf 0 0 0 0 inset; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-clip: content-box; display: inline-block; -webkit-appearance: none; -moz-appearance: none; user-select: none; outline: none;}input[type='checkbox'].mui-switch:focus { outline: #fff none 0;}.mui-switch:before { content: ''; width: 29px; height: 29px; position: absolute; top: 0px; left: 0; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-color: #fff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);}.mui-switch:checked { box-shadow: #64bd63 0 0 0 16px inset; /*border-color: #64bd63; background-color: #64bd63;*/ border-color: #52a4ff; background-color: #52a4ff;}.mui-switch:checked:before { left: 21px;}.mui-switch.mui-switch-animbg { transition: background-color ease 0.4s;}.mui-switch.mui-switch-animbg:before { transition: left 0.3s;}.mui-switch.mui-switch-animbg:checked { box-shadow: #dfdfdf 0 0 0 0 inset; /*background-color: #64bd63;*/ background-color: #52a4ff; transition: border-color 0.4s, background-color ease 0.4s;}.mui-switch.mui-switch-animbg:checked:before { transition: left 0.3s;}.mui-switch.mui-switch-anim { transition: border cubic-bezier(0, 0, 0, 1) 0.4s, box-shadow cubic-bezier(0, 0, 0, 1) 0.4s;}.mui-switch.mui-switch-anim:before { transition: left 0.3s;}.mui-switch.mui-switch-anim:checked { /*box-shadow: #64bd63 0 0 0 16px inset; background-color: #64bd63;*/ box-shadow: #52a4ff 0 0 0 16px inset; background-color: #52a4ff; transition: border ease 0.4s, box-shadow ease 0.4s, background-color ease 1.2s;}.mui-switch.mui-switch-anim:checked:before { transition: left 0.3s;}.mui-switch { &amp;.mui-switch-middle { height: 26px; width: 44px; &amp;:before { width: 24px; height: 24px; } &amp;:checked { &amp;:before { left: 18px; } } } &amp;.mui-switch-small { height: 22px; width: 36px; &amp;:before { width: 20px; height: 20px; } &amp;:checked { &amp;:before { left: 14px; } } }} 1&lt;input class=&quot;mui-switch mui-switch-animbg mui-switch-middle&quot; type=&quot;checkbox&quot; ng-model=&quot;item.isDisplay&quot; /&gt;","link":"/2016/09-04-angularjs-css-directive-link-error/"},{"title":"angular的异步加载组件以及路由使用","text":"ui-router应该可以算angular最重要的组件之一了, 简单易用, 不过它的template基于controller的做法不太符合我们项目里directive-first的原则, 而且它的异步加载模块ocLazyLoad语法不太好用, 需要配置在 app 初始化的config中, 不能实现动态配置和动态读取. 所以之前自己实现了一个建议版本的异步加载模块指令, 供项目组使用. angular-async-module加入了动态加载读取模块, 也可以和ui-router分离使用, 可以对加载开始和结束的行为进行事件响应. 对于router, 不建议使用controller来控制模版行为, 而建议使用指令来控制模版. 一般是一个router对应一个module, 根据需求可选这个module是否异步.angular-async-module对于模块的加载是基于ng-include指令的, 页面需要为一个模版页, 正常情况会包含展示的自定义指令, 用&lt;!-- script: asyncDemo/asyncDemoMod --&gt;这种语法导入所需module的scrpit, 可以支持一个模版导入多个文件模块. 指令加载是在模块导入完成以后加载到页面上, 提供生命周期钩子函数, 可以自由控制加载时页面内容. 详细可见项目demo.","link":"/2016/10-23-angularjs-async-module/"},{"title":"angular的eval与watch","text":"angular 给开发人员提供了很多内部使用的强大的工具函数, $parse服务和$observe就是其中两个比较有用的函数. $parse$parse作为一个服务, 在使用的时候需要先注入到指令中, 它的作用是把一个字符串编译成一个解释器函数(也可传入一个函数, 不过和直接声明函数没区别), 再对指定的scope操作即可. 生成的函数有两个参数, 一个是context, 另一个是locals(可选), context即表达式里面的属性所在的对象, locals如果提供, 可以覆盖context里面重名的属性. 1234567891011121314151617$scope.context = { add: function (a, b) { return a + b; }, mul: function (a, b) { return a * b; }, a: 1, b: 2,};$scope.locals = { a: 3, c: 9,};var mulParsed = $parse('mul(a, add(b, c))');$scope.value = mulParsed($scope.context, $scope.locals);//得到值是33. 3 * (2 + 9) $parse最常见的用法即解析一个字符串变量到scope上. angular 的模版页中变量的解析也是由$parse提供的.如果$parse解析出来的是一个对象属性(a.b || [a]), 那么返回的函数会提供一个assign方法, assign是对这个对象设置值的方法. 12345678910$scope.a = { b: { c: 5, },};var cGetter = $parse('a[&quot;b&quot;].c');var cSetter = cGetter.assign;console.log(cGetter($scope)); //5cSetter($scope, 10);console.log(cGetter($scope)); //10 不过实际使用的时候, $eval比$parse更常用一些, 可以不需要注入直接由$scope调用. $eval$eval的源码也是十分简单的. 123$eval: function(expr, locals) { return $parse(expr)(this, locals);}, 使用起来和$parse差不多, 省略了一步生成解释函数的过程. 下面看看什么情况下来使用$eval. 12345678910&lt;div my-app&gt; &lt;div ng-if='!loading'&gt; &lt;div other-directive&gt; &lt;div content-directive content-text='text'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;//myApp {scope.text = 'eval内容'}//otherDirective {scope: true,}//contentDirective {scope: {contentText: '='}} 在以上代码中, 最内层的指令contentDirective可以获取到myApp中 text 的值, 但是如果在contentDirective里面对contentText修改, myApp是拿不到改变以后的值的. 这是因为otherDirective的scope: true是对scope进行原型继承, 在当前取不到值可以顺原型链继续读取, 可是修改值的时候是不能设置原型链上的值的. 解决办法可以是传入一个对象, 那么修改只是修改这个对象的属性, 所以可以读取到值, 这也是推荐的做法. 但是如果你确实不想传入对象, 那么就可以使用$eval来解决这个问题. 123456789101112131415161718192021&lt;div my-app&gt; &lt;div ng-if=&quot;!loading&quot;&gt; &lt;div other-directive&gt; &lt;div content-directive content-text=&quot;text&quot; scope-level=&quot;3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;//contentDirectivescope: {scopeLevel: '=', contentText: '='},link: function($scope, $element, attrs, ctrls) { $scope.scopeLevel = $scope.scopeLevel || 1; var $parent = $scope; var levelInt = parseInt($scope.scopeLevel); while(levelInt &gt; 0 &amp;&amp; levelInt != Infinity){ $parent = $parent.$parent; levelInt--; } $scope.contentText = 'newContentText'; //设置值, 如果不使用$eval, 当attrs['contentText']为多层属性时不能设置值. $parent.$eval(attrs['contentText'] + ' = contentText', $scope);} $watch$scope.$watch(key, func, isDeep)可以监听一个$scope上给定key的值的变化, 如果有变化则调用 func, 返回值是一个注册函数, 再次执行注册函数可以取消该监听. 第三个参数为是否深度比较, 不建议设置为 true, 太占用性能. $observe12345678910111213$observe: function(key, fn) { var attrs = this, $$observers = (attrs.$$observers || (attrs.$$observers = {})), listeners = ($$observers[key] || ($$observers[key] = [])); listeners.push(fn); $rootScope.$evalAsync(function() { if (!listeners.$$inter) { // no one registered attribute interpolation function, so lets call it manually fn(attrs[key]); } }); return fn;} 如果说$watch基本可以满足传值到指令里面再次改变以后的事件触发, 那么attrs.$observe(key, func)则是监听属性的变化以及触发事件. 这两个的区别是: 当你的传值方法为key=&quot;{{someone}}&quot;时, 使用$scope.$watch(attrs.key)是无效的, 因为{{}}这种值无法解析, 这时候就需要用attrs.$observe, 在源码里面可以看到调用的是$evalAsync这个方法, 这个方法和$eval的区别是该方法为延迟执行, 但是会在本轮$digest循环期间执行, 在$digest里面可以看到是在所有$scope上的watch执行完成以后调用, 所以能够监听到括号表达式的值. 附$digest源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113$digest: function() { var watch, value, last, fn, get, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask; beginPhase('$digest'); // Check for changes to browser url that happened in sync before the call to $digest $browser.$$checkUrlChange(); if (this === $rootScope &amp;&amp; applyAsyncId !== null) { // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then // cancel the scheduled $apply and flush the queue of expressions to be evaluated. $browser.defer.cancel(applyAsyncId); flushApplyAsync(); } lastDirtyWatch = null; do { // &quot;while dirty&quot; loop dirty = false; current = target; while (asyncQueue.length) { try { asyncTask = asyncQueue.shift(); asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals); } catch (e) { $exceptionHandler(e); } lastDirtyWatch = null; } traverseScopesLoop: do { // &quot;traverse the scopes&quot; loop if ((watchers = current.$$watchers)) { // process our watches length = watchers.length; while (length--) { try { watch = watchers[length]; // Most common watches are on primitives, in which case we can short // circuit it with === operator, only when === fails do we use .equals if (watch) { get = watch.get; if ((value = get(current)) !== (last = watch.last) &amp;&amp; !(watch.eq ? equals(value, last) : (typeof value === 'number' &amp;&amp; typeof last === 'number' &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) { dirty = true; lastDirtyWatch = watch; watch.last = watch.eq ? copy(value, null) : value; fn = watch.fn; fn(value, ((last === initWatchVal) ? value : last), current); if (ttl &lt; 5) { logIdx = 4 - ttl; if (!watchLog[logIdx]) watchLog[logIdx] = []; watchLog[logIdx].push({ msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp, newVal: value, oldVal: last }); } } else if (watch === lastDirtyWatch) { // If the most recently dirty watcher is now clean, short circuit since the remaining watchers // have already been tested. dirty = false; break traverseScopesLoop; } } } catch (e) { $exceptionHandler(e); } } } // Insanity Warning: scope depth-first traversal // yes, this code is a bit crazy, but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $broadcast if (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) || (current !== target &amp;&amp; current.$$nextSibling)))) { while (current !== target &amp;&amp; !(next = current.$$nextSibling)) { current = current.$parent; } } } while ((current = next)); // `break traverseScopesLoop;` takes us to here if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) { clearPhase(); throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog); } } while (dirty || asyncQueue.length); clearPhase(); while (postDigestQueue.length) { try { postDigestQueue.shift()(); } catch (e) { $exceptionHandler(e); } }} $apply &amp; $digest$digset循环就是angular的核心循环了, angular就是在这个循环里面执行脏值检测, 更新scope和页面, 进行双向绑定和触发watch事件的. 那么如果我们需要在某些地方触发双向绑定和事件, 只需要进入这个循环就可以了. angular提供了几种进入$digset循环的方法. $apply$scope.$apply()会触发整个应用中的所有$scope上的$digset循环, 即刷新整个应用的双向绑定值等等. 因为执行的是全部, 所以频繁调用还是会导致性能问题, 所以有了下一个方法$digset $digset$scope.$digset()会触发当前scope和子scope中的$digset循环, 那么造成的问题是父节点不会刷新, 优点是对于性能有明显的改善. $evalAsync$scope.$evalAsync()有两种情况, 如果当前正在$digset循环中, 那么会添加到$digset循环尾部执行, 如果不在$digset循环中, 那么它可以触发新一轮的$digset循环. $timeout在没有$evalAsync之前, 在angular上下文之外触发$digset循环的方法比较常用的就是它, 基本等于setTimeoout, 在执行的最后会调用$apply触发$digset循环. $applyAsync也可以触发$digset循环, 和$apply有点区别, 定义一个延迟执行任务, 如果不存在applyAsyncId, 会调用$rootScope.$apply. 在$digset源码里面可以看见, 在$rootScope中才会触发定义的applyAsync方法, 如果你手动调用的是非$rootScope的$digset循环, 那么不会触发applyAsync里面定义的方法. 官方说明是方便$http在请求结束的时候合并$apply的调用, 实际项目里面使用到的情况还是$evalAsync比较常用一些.","link":"/2016/11-14-angularjs-eval-watch/"},{"title":"angularjs 的一些小技巧和实现","text":"angular关于 angularangular 的实用和方便性就不说了, 说说要注意的一些地方. 尽量不要用{{}}`做绑定数据, 使用`ng-bind`. 原因是当浏览器卡的时候页面会显示出`{{item.name}}这样的代码(也可用ng-cloak). 对于在 onchange 触发的 input, 可以使用ng-model-options=&quot;{ debounce: 500 }&quot;使事件触发不会那么频繁, 提高性能(在用于给比较大 table 做 filter 的时候性能提升明显). 少用$watch. 有一种说法是超过 1000 个 watcher 以后, 整个系统的卡顿就会特别明显, 多使用自定义事件回调机制, 对于指令的作用和功能也更清晰. 同 3 类似, 对于那些只有展示一次作用, 不会再次改变的数据, 使用 oncebind 命令::, 如ng-bind=&quot;::item.name&quot;. 在各种 table 和 repeat 里面比较常用. 有个小技巧是: 如果你的 repeat 里面的数据不会变化, 把 repeat 的传入值也改成一次性的ng-repeat=&quot;item in ::dataList&quot;. 用好$compile. $compile是 angular 暴露出的内部转换 html 模版到编译函数的功能, 虽然各种ng-if ng-show ng-class已经为动态展示元素提供了很好的帮助, 但是对于一些复杂的页面元素(比如根据后台条件生成不同的验证指令控件), 直接写一个 htmlHelperServer 方法生成正确的 html, 然后使用$element.append($html)), $compile($element.contents())($scope)加入到当前指令中. service 的使用. 如果你的指令应该传入一个 tree 形数据, 而后台拿到的是 list, 那么这个指令所在的模块的 service 里应该有写好的如何把 list 转换成有效的 tree 数据方法. 这样其他人使用这个指令时可以注入这个 service, 使用已有的转换方法. scope angular 有个快速获取某个元素所在 scope 的方法:$(ele).scope(), 结合$.fn.closest可以很方便的拿到上级 scope. 但是并不推荐在代码里使用, 会打乱层级关系和造成代码混乱. 正确的方式是依赖上级指令require: '^parent', 通过link的ctrls参数拿到上级的相关方法. $scope.$apply()有时候在指令里面不得不使用jquery或者其他方法改变绑定到 angular 里的对象属性, 这时候通常会使用$scope.$apply()来把改变同步到界面上. 存在问题是如果这个时候是处于$digest循环中, 那么apply会报错. 推荐做法是封装一个safeApply在rootScope上, 需要使用的地方使用$scope.$root.$safeApply();. 12345$rootScope.$safeApply = function () { if ($rootScope.$$phase != '$apply' &amp;&amp; $rootScope.$$phase != '$digest') { $rootScope.$apply(); }}; directive 指令可以分成两种类型: 容器指令和展示指令, 前者保存数据和提供操作函数以及界面的组合, 后者只做部分特殊的展示和提供回调. 数据应该跟随指令保存, 而不是controller. 普通指令应该全部支持A属性, 容器指令支持E属性且replace设置为true, 在写 html 的时候不能出现自定义的闭合标签, 因为部分浏览器对闭合标签支持不友好. 普通指令通过attribute的方式使用, 方便组合以及自定义样式. 特别是那些纯功能性不提供 dom 的指令, 使用transclude: true,replace: true,scope: true来做到低耦合. 对于组合式指令, 多个指令用于一个元素时, 可以设置这些指令的优先级, 加载顺序是由priority参数定义的. 还可以设置 terminal, 停止低于某个指令的优先级的其他指令运行. 对于这些指令, 都不应该有自己的 scope 作用域, 即只能设置scope: false或者不设置. 如果一个元素上多个指令都有自己的scope, 会报错. 指令的销毁. 在指令从界面上移除的时候(包括ng-if=false), 会触发$destroy事件, 在指令中设置$scope.$on('$destroy',func), 可以接收到此事件进行一些操作, 比如清除生成的watch, 释放$timeout, 清除jquery动态添加的全局元素等, 回收内存. 指令的事件广播. 只推荐在全局中使用广播, 因为指令可选择接收或不接收, 属于被动接收全局控制, 而且要定义好广播命名和规范的接收文档. 在容器指令中发送广播会影响全局代码的混乱. 如果需要主动发送全局事件, 请使用require和ctrls来调用相关父级指令函数. 指令的controller. 正常情况下应该只有容器指令和最外层的指令有controller, 里面的下级指令可以依赖该指令拿到外层的相关属性和方法. controllerAs是个很令人迷惑的属性, 简单点说就是把 as 的 name 绑定到 scope 上, 即在controller里面返回的 this 作为一个对象返回, 在scope[name]里面可以取到这个 this 对象. 还可以使用bindToController 选择需要的属性自动绑定到 this 上. 一般情况下controller都只定义一些方法, 供其他指令使用. 也可以做一些初始化的操作, 毕竟controller运行在 link 前面, 不过注意不能使用 dom, 这时候 dom 还没有加载到界面上. 父级调用下级的方法. 有时候父级作为容器组件, 下级是纯展示组件, 而且还有很多个. 那么父级上有个事件需要改变下级的状态, 怎么处理呢? 通常我们会在下级的 link 里面最后加上以下方法暴露出去所提供的方法.当然指令里面需要接收scope``initComplete: '=?', 父级在调用的时候需要写一个接收方法的回调并保存下级的方法, 在需要的时候调用. 这样就实现了展示组件和容器组件的解耦. 当然下级调用父级的就是很简单的 require 然后通过 ctrls 调用了. 123456if ($scope.initComplete) { var exports = { fun: $scope.fun, }; $scope.initComplete(exports, $scope, $element);} controller 尽量少使用独立的controller, 一般都是作为和指令关联的controller才需要用到. controller 不要用于构建界面, 只有指令才作为界面的元素. controller只定义方法. 系统中只需要少数几个controller, 一个是runController, 在最开始的入口执行, angular.module(appName, [...commonModules]).directive('myApp', myAppDirective.myApp).run(runCtrl);定义一些自定义的方法和初始化值, 比如我们的highChart的配置就是写在这里. 上面说的$safeApply也是在这里定义的. 还有几个controller是在路由切换的时候需要提供不同的方法加载路由. controller作为指令的定义是一个字符串的时候, 只是把那个方法里的内容移到以那个字符串命名的controller里面, 在指令的 link 里面第四个参数能拿到那个controller, 其他没有什么区别. provider在系统里只推荐使用两种provider, constant和service. constantconstant定义常量, 比如各种服务地址, 通过生成一个config对象, 供全局使用. serviceservice完全可替代factory, 当返回值是对象时, 和factory没有区别(原理是通过 new 调用的方法, 无返回值时可以设定this). 由于是单例模式, 也可以当作全局变量使用, 如注册一个可改变的configService到全局, 则全局可读写并动态配置.把所有与后台接口交互的方法均定义到service里面, service提供的方法应该与后台同步, 命名相同, 这样就保证后台方法修改的时候, 前端只用修改一个service里的调用. 所有的请求应该通过一个自定义的 ajax 发出去, 即在service里只有参数和配置, 没有 url 和解析. 123456789101112131415161718192021(function (define) { 'use strict'; define([], function () { var demoService = function ($q, ajaxService) { var functionName = function (content, info, onComplete) { var data = { CommandName: 'ClassName$FunctionName', params: { content: content, info: info, }, }; return ajaxService.post(data, onComplete); }; return { functionName: functionName, }; }; return ['$q', 'App.ajaxService', demoService]; });})(define); promise 和 onComplete为了兼容性和减少开发人员入门学习成本, 学习jquery提供两种方式的回调, 在有onComplete参数的时候, 调用onComplete, 同时返回promise对象, 可以在后面自由添加[then|catch]方法. 同时在ajaxService.post里面请求失败触发回调时, 也检测标准 http 错误(500)并记录日志到后台. decoratordecorator可以注入constant来改变service的行为, 不过目前没有碰到需要使用的情况, 按需使用即可. module使用require构建模块化的 angularJs 项目.在每个模块里声明自己的directive和service以及modName, 再在系统的总入口里面注册该模块, 这样每个 mod 都是独立的, 不会互相干扰. 在异步加载 mod 的时候也方便操作.区分模块是创建还是获取是根据第二个参数是否传入有关, 如果传入数组, 则表示是创建模块, 否则是根据模块名获取模块. 123456789//commonMod.js(function (define, angular) { 'use strict'; define(['common/configMod', 'common/commonService', 'common/commonDirective'], function (configMod, commonService, commonDirective) { var modName = 'App.commonMod'; angular.module(modName, [configMod]).service('App.commonService', commonService).directive('myDirective', commonDirective.myDirective); return modName; });})(define, angular);","link":"/2016/12-20-angularjs-practice/"},{"title":"chrome扩展开发","text":"前言最近, 因为不可抗力的关系, google越来越难用了, 而且好不容易能连上, 反应也特别慢. 迫不得已只能用百度, 而百度的广告也是越来越恶心了, 搜个代码都能出现一堆广告. 既然是自己的浏览器, 那就自己想想办法来干掉百度吧. extensionchrome以及使用Chromium内核的浏览器, 都可以使用extension来增强浏览器功能. 如大名鼎鼎的Adblock Plus插件等. 插件原理是chrome提供一系列API来供用户自定义操作浏览器. manifestmanifest.json文件是所有扩展插件的起点, 里面给定了插件的权限, 功能, 运行时间, 依赖等. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//manifest.json{ &quot;manifest_version&quot;: 1, &quot;name&quot;: &quot;百度一下!&quot;, &quot;version&quot;: &quot;1.0.0.0&quot;, &quot;description&quot;: &quot;from zhoucong&quot;, &quot;icons&quot;: { &quot;16&quot;: &quot;icon3x72.png&quot;, &quot;48&quot;: &quot;icon3x72.png&quot;, &quot;128&quot;: &quot;icon3x72.png&quot; }, &quot;browser_action&quot;: { &quot;default_icon&quot;: &quot;icon3x72.png&quot;, &quot;default_title&quot;: &quot;全功能扩展～！&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; }, &quot;options_page&quot;: &quot;options.html&quot;, &quot;background&quot;: { &quot;scripts&quot;: [&quot;js/lib_js/jquery-2.1.4.js&quot;, &quot;js/background.js&quot;] }, &quot;commands&quot;: { &quot;_execute_browser_action&quot;: { &quot;suggested_key&quot;: { &quot;windows&quot;: &quot;Ctrl+Shift+S&quot;, &quot;mac&quot;: &quot;Command+Shift+S&quot;, &quot;chromeos&quot;: &quot;Ctrl+Shift+S&quot;, &quot;linux&quot;: &quot;Ctrl+Shift+S&quot; } } }, &quot;permissions&quot;: [ &quot;background&quot;, &quot;storage&quot;, &quot;bookmarks&quot;, &quot;nativeMessaging&quot;, &quot;tabs&quot;, &quot;contextMenus&quot;, &quot;activeTab&quot;, &quot;webRequest&quot;, &quot;webRequestBlocking&quot;, &quot;downloads&quot;, &quot;http://*/*&quot;, &quot;https://*/*&quot; ], &quot;content_security_policy&quot;: &quot;script-src 'self' 'unsafe-eval'; object-src 'self'&quot;, &quot;content_scripts&quot;: [ { &quot;all_frames&quot;: true, &quot;matches&quot;: [&quot;*://*.baidu.com/*&quot;], &quot;js&quot;: [&quot;js/baidu_background.js&quot;], &quot;run_at&quot;: &quot;document_end&quot; } ], &quot;web_accessible_resources&quot;: [&quot;js/lib_js/jquery-2.1.4.js&quot;, &quot;js/lib_js/jquery-custom.js&quot;]} browser_action定义了图标图片, 提示, 以及点击弹出的html文件.options_page定义的是在chrome://extensions/中点击选项的打开页, 一般用作插件用户自定义配置设置.background定义的是在插件在后台运行时需要的js.commands定义了快捷键.permissions表示插件所需权限, 会在安装插件时提示用户所需权限.content_scripts定义了匹配到相应页面时, 运行的js文件.web_accessible_resources定义的是在content_scripts中可以请求的js文件. baidu_background接下来创建baidu_background.js. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//这是个必要的函数, 用于将函数注入到页面function addscript(prefix, f, suffix) { var script = document.createElement('script'); script.type = 'text/javascript'; script.innerHTML = prefix + eval(f) + suffix; document.head.appendChild(script);}//主要函数function killAdsFunction() { if (!window.adcount) { //初始化 window.adcount = 0; window.killAds = []; } console.log('----------------kill baidu ads--------------------'); var $wrapper_wrapper = $('#wrapper_wrapper'); var $content_left = $('#content_left'); var ads = $content_left.children('div:has(a:contains(广告))'); window.adcount += ads.length; window._is_my_remove = true; ads.remove(); window._is_my_remove = false; console.log('页面加载完成时干掉了: ' + window.adcount + ' 个广告'); var pb = function (e) { if (window._is_my_remove == true) { return; } var ads = []; if ($(e.target).closest('#wrapper_wrapper').length &gt; 0) { console.log('屏蔽广告插件无刷新版本killAdsFunction启动!!!'); $content_left = $('#content_left'); window._is_my_remove = true; ads = $content_left.children('div:has(span:contains(广告):not(:has(*)))'); if (ads.length &gt; 0) { window.adcount += ads.length; ads.remove(); window.killAds = $.merge(window.killAds, ads); console.log('本次干掉: ' + ads.length + ' 个广告', ads); console.log('总共干掉了: ' + window.adcount + ' 个广告'); } window._is_my_remove = false; } }; $wrapper_wrapper.on('DOMNodeInserted DOMSubtreeModified', pb);}//注入页面addscript('(', killAdsFunction, ')();'); 运行在chrome://extensions/中点击加载已解压的扩展程序, 选中刚刚创建的文件夹, 即可看见扩展程序了. 加入插件前 加入插件后 后记chrome插件功能远远不止这么点功能, 更强大的还可以和windows程序通信, 在background.js中, 可以拦截网络请求, 和windows程序通信, 调用迅雷下载相关资源. 可以参考git.","link":"/2017/01-05-chrome-extensions-start/"},{"title":"三大数据库的split函数","text":"前言在执行sql查询传参的时候, 为了防止sql注入, 一般都会使用参数化查询. 而例外的是in, 因为它是多参数, 所以一般都是在后台代码中拼好用逗号分割的字符串以后, 再直接使用字符串传入sql解释器. 这样一来, sql注入便是有可能成功的了, 而且防止sql注入的代码需要在后台完成. 为了解决这个问题, 我们只需要在sql中提供自定义函数拆分字符串即可. sqlserversqlserver应该算是最简单的了, 函数可以返回临时表, 查询起来也够简单. 12345678910111213141516171819202122232425262728293031323334CREATE FUNCTION [dbo].[f_Split] ( @str NVARCHAR(MAX) , @split_char NVARCHAR(10) )RETURNS @table TABLE ( value NVARCHAR(MAX) )AS BEGIN IF @str IS NULL OR @split_char IS NULL OR LEN(@str) = 0 OR LEN(@split_char) = 0 RETURN DECLARE @index INT SET @index = CHARINDEX(@split_char, @str) WHILE @index &gt; 0 BEGIN INSERT @table VALUES ( LEFT(@str, @index - 1) ) SET @str = RIGHT(@str, LEN(@str) - @index) SET @index = CHARINDEX(@split_char, @str) END INSERT @table VALUES ( @str ) RETURN END-- 使用SELECT * FROM dbo.f_Split('1,2,3,4',',')SELECT * FROM dbo.temp t0WHERE t0.ID IN ( SELECT value FROM dbo.f_Split('1,2,3,4',',')) oracleoracle也简单, 在使用的时候用table函数调用即可. 1234567891011121314151617181920212223242526272829CREATE OR REPLACE TYPE f_split_type IS TABLE OF VARCHAR2 (4000)CREATE OR REPLACE FUNCTION f_split(str VARCHAR2, split_char VARCHAR2 := ',')RETURN f_split_type PIPELINED IS v_i INTEGER; v_str_value VARCHAR2(500); v_str VARCHAR2(4000) := str;BEGIN LOOP v_i := INSTR(v_str, split_char); EXIT WHEN v_i = 0; v_str_value := SUBSTR(v_str, 1, v_i - 1); v_str := SUBSTR(v_str, v_i + 1); PIPE ROW(v_str_value); END LOOP; PIPE ROW(v_str); RETURN;END f_split;-- 使用SELECT t.COLUMN_VALUE FROM TABLE(f_split('1,2,3,4,5','2')) tSELECT * FROM temp t0WHERE t0.ID IN ( SELECT COLUMN_VALUE FROM TABLE(f_Split('1,2,3,4',','))) mysqlmysql是比较麻烦的了, 不提供临时表可用, 而且函数不能返回结果表. 只能用一种简单的办法, 创建一个单独用作保存结果的表, 然后联合查询. 这里设置的清除数据时间是一小时, 即自动清除一小时之前的临时数据. 12345678910111213141516171819202122232425262728293031323334353637383940414243-- 临时表CREATE TABLE `split_temp_table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `mainId` varchar(50) DEFAULT NULL, `value` varchar(100) DEFAULT NULL, `createTime` datetime DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8-- 函数CREATE FUNCTION `f_split` (str VARCHAR (2000),split_char VARCHAR (10)) RETURNS VARCHAR (50) CHARSET utf8BEGIN DECLARE uid VARCHAR (50) ; DECLARE i INT; DECLARE now_time DATETIME; SET now_time = NOW(); DELETE FROM `split_temp_table` WHERE createTime &lt; SUBDATE(now_time,INTERVAL 1 HOUR); IF (str IS NULL OR LENGTH(str) = 0 OR split_char IS NULL OR LENGTH(split_char) = 0) THEN RETURN NULL; END IF; SET uid = UUID() ; SET i = LOCATE(split_char,str); WHILE i &gt; 0 DO INSERT INTO split_temp_table(mainId, `value`, createTime) VALUES(uid, LEFT(str,i - 1), now_time); SET str = RIGHT(str,LENGTH(str) - i); SET i = LOCATE(split_char,str); END WHILE; INSERT INTO split_temp_table(mainId, `value`, createTime) VALUES(uid, str, now_time); RETURN uid ;END $$-- 使用SELECT f_split('1,2,3',',') INTO @uid;SELECT * FROM temp t0WHERE t0.ID IN ( SELECT t1.`value` FROM split_temp_table t1 WHERE t1.`mainId` = @uid) 这三个函数完成以后, 在查询的时候就可以直接使用参数化传入带逗号分割的字符串了, 不需要考虑sql注入和sql拼接了.","link":"/2017/02-20-sql-split-string-by-char/"},{"title":"sublime插件开发","text":"在写前端代码的时候, vs虽然有比较完美的智能提示和格式化, 但是字体太大和占用内存太大, 而且比起纯代码编辑器还是卡了一点, 所以一般还是习惯使用sublime来写html等前端代码. 但是最近有一点用得很不舒服的就是代码格式化. sublime是没有自己的代码格式化的, 需要格式化都需要使用插件来完成, 而我目前使用的有HTML-CSS-JS Prettify, 格式化出来的效果还是比较好的, 唯一有一点不舒服的就是会有一点点卡顿的感觉, 在js文件比较大的时候更明显. 而有时候在复制一些代码时, 特别是使用ESLint格式化的代码, 在粘贴到sublime里面的时候, 由于ESLint默认的缩进是2行, 而项目组里面的代码都是4行缩进的, 贴进来以后就显得很不协调, 即使是用带格式的粘贴ctrl + shift + v也不能解决这个问题, 只能默认缩进到当前行, 但是里面的缩进还是2行. 而每次粘贴完成代码以后使用一次格式化又感觉有点卡和不爽, 所以想自己写个小插件来解决这个问题. 首先新建一个plugins, 点击Tool -&gt; New Plugin...会出现一个默认的Hello World文件, 能发现它的语法是python. 然后用ctrl + ~打开控制台, 保存该文件到Packages下demo目录, 文件名为demo.py. 保存的时候就能看到控制台出现提示, reloading plugin ..., 表示插件读取到了. 既然是python, 那么测试一下, 发现不支持print 'a'这种语法可知python版本为3.x. 运行方式, 在.py文件中, 主函数名为xAxBxCommand, 那么在控制台中输入view.run_command('x_ax_bx')即可运行该插件. 剩下的就是开发python了. 打开vs, 建个python工程, 写好转换函数, 贴进来就可以使用了. 首先是获取剪切板内容, 查API可得使用函数sublime.get_clipboard()即可获取当前剪切板内容. 剩下就是简单的修改字符串函数了. 1clipboardStr = sublime.get_clipboard() 首先是把\\t转换成空格, clipboardStr = clipboardStr.expandtabs(4).然后是把行分割成数组, 这里有个问题是window中, 行结尾符可能是\\r\\n也可能是\\n, 这里处理方法是如果有\\r\\n即使用\\r\\n做分隔符. 1234split_symbol = '\\n'if clipboardStr.find('\\r\\n') &gt; -1: split_symbol = '\\r\\n's_list = clipboardStr.split(split_symbol) 如果当前剪切板只有一行, 那么就直接调用paste_and_indent(ctrl + shift + v)粘贴即可. 12if len(s_list) == 1: self.view.run_command('paste_and_indent') 如果超过一行, 那么先将每行都往前缩进最小的空格数量, 即去掉多余的空格, 按本来的缩进排列, 这里存在一个问题是, 可能在复制的时候第一行是没有复制到空格而是直接复制得代码, 所以需要特殊处理一下.再计算每行的最小前置空格差, 如果最小相差为2, 那么说明这段代码的原始tab占空格为2个, 否则为4个. 如果tab占空格为2的话, 那么将每行的前置空格数量翻倍即可. 12345678910111213141516171819202122232425262728293031preIndent = 0if len(s_list) == 1: self.view.run_command('paste_and_indent')else: preIndent = self.getLeftSpace(s_list[0]) if preIndent == 0: preIndent = 1000 leftSpaceList = [0] for s in s_list[1:]: leftSpace = self.getLeftSpace(s) leftSpaceList.append(leftSpace) preIndent = leftSpace if leftSpace &lt; preIndent else preIndent s_list[0] = s_list[0].lstrip() minPreIndentSpace = 1000 leftSpaceList.sort() for i in range(1, len(leftSpaceList)): leftSpaceSplit = leftSpaceList[i] - leftSpaceList[i-1] if leftSpaceSplit &gt; 0 and leftSpaceSplit &lt; minPreIndentSpace: minPreIndentSpace = leftSpaceSplit if preIndent &gt; 0: for index in range(1, len(s_list)): s = s_list[index] if self.getLeftSpace(s) &gt;= preIndent and len(s.strip()) &gt; 0: s_list[index] = s[preIndent:] if minPreIndentSpace == 2: for index in range(0, len(s_list)): if self.getLeftSpace(s_list[index]) &gt;= minPreIndentSpace: s_list[index] = s_list[index].replace(' ', ' ') clipboardStr = split_symbol.join(s_list)def getLeftSpace(self, s): return len(s) - len(s.lstrip()) 然后将值设置到剪切板中, 调用paste_and_indent即可. 12sublime.set_clipboard(clipboardStr)self.view.run_command('paste_and_indent') 然后去设置一个快捷键, 建立一个Default (Windows).sublime-keymap文件, 内容为: 123[ { &quot;keys&quot;: [&quot;ctrl+shift+v&quot;], &quot;command&quot;: &quot;paste_with_tab&quot; }] 这里直接覆盖了原始的ctrl + shift + v命令. command即PasteWithTabCommand的驼峰转换小写形式. 再加一个菜单文件Main.sublime-menu, 内容: 1234567891011121314[ { &quot;id&quot;: &quot;edit&quot;, &quot;children&quot;: [ { &quot;caption&quot;: &quot;-&quot;, &quot;id&quot;: &quot;clipboard&quot; }, { &quot;caption&quot;: &quot;带缩进的粘贴&quot;, &quot;command&quot;: &quot;paste_with_tab&quot; }, ] }] 所有代码见git","link":"/2017/03-06-sublime-plugins/"},{"title":"使用css3的flex布局和rem大小单位","text":"flex在以前做框架布局的时候, 一般都是使外层元素设置height:100%;width:100%;, 使用外层元素设置padding, 内层也可以使用height:100%;width:100%;来布局(元素需要为border-box). 对于那些固定的元素, 可以使用calc(100% - npx)这种方式来动态计算布局. 而在css3中, 出现了一种新的布局模型flex, 相关语法可以看这里, 可以比calc更优雅和简洁的实现动态布局, 不过对于IE系列只有IE 10+才支持, IE 9便只能使用calc或其他方式了. flex可以做到的几种布局 : 对某个方向自动填充, 如果超过则压缩元素, 可以设置指定元素需要压缩和比例. 如果不超过可以自动拉伸元素, 可设置指定元素拉伸和比例. 如果元素全为固定大小, 可以设置如果不填满时的填充方式, 有flex-start | flex-end | center | space-between | space-around五种可选, 分别是从起点开始, 终点开始, 居中, 两端对齐且每项间隔相等, 每项两侧间距相等. 设置在垂直轴上的布局方式, 常见的垂直居中可以很简单的实现. 如果设置为wrap即换行模式, 可以设置超过一行的情况下的行的布局. 可以对子项单独设置排序(order), 放大比例(flex-grow), 缩小比例(flex-shrink), 在计算拉伸时所占实际大小(flex-basis), 单独的垂直轴布局方式(align-self) 一般情况下, 如两端固定, 中间可拉伸的布局代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html, body { width: 100%; height: 100%; padding: 0; margin: 0; } * { box-sizing: border-box; } .flex-row{ height: 300px; background-color: #ccc; display: flex; flex-flow: row nowrap; } .start{ flex: 0 1 300px; background-color: yellow; } .end{ flex: 0 1 150px; background-color: blue; } .wrapper{ flex: 1 0 auto; display: flex; align-items: center; justify-content: center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flex-row&quot;&gt; &lt;div class=&quot;start&quot;&gt;开始&lt;/div&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;wrapper-center-content&quot;&gt;居中的中间&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;end&quot;&gt;结束&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图 通过设置flex-direction属性, 可以设置元素是横向排列还是纵向排列, 从而可以构建出各种动态嵌套布局, 在修改相关元素大小的时候, 也不会影响到整体布局, 不用像之前写calc一样修改一点以后再去计算每个元素大小, 全交给浏览器自动计算, 省事方便很多. rem再看看rem单位, 之前出现的em单位是将字体大小与容器大小相匹配的单位, 即容器可以跟着字体大小动态变化, 不会出现字体比容器大的情况. 但是存在的问题是在写每个div的大小时, 需要知道当前em的比例, 即文字大小. 而rem单位出现便解决了这个问题, rem表示root-em, 即根节点的字体大小. 只需要设置html的font-size, 其他元素则都设置为1rem即可表示html的font-size大小, 在动态改变字体时, 也只需要修改html的font-size即可, 不会出现以前em的修改多处的问题. vh以前如果要设置一个元素高度是浏览器页面大小, 只能在外层通过height:100%;一层层传到内层元素, 或者使用js设置ele.style.height = window.innerHeight. 这样会很不方便, 而vh可以很简单的实现这个需求. 100vh == window.innerHeight. vwvh是高度单位, 那么vw则是宽度单位了, 表示100%的屏幕可见宽度. 在宽度自适应布局中, 比较简单的做法就可以用到vw了. 再结合flex布局, 可以说是非常强大的了. 123456.left-menu{ width: 25vw;}.main{ width: 75vw;} 再比如, 图片不能超过页面大小. 1234.max-img{ max-height: 90vh; max-width: 90vw;} vmvm表示的是vmin和vmax, 能想到要用到的地方就是做一个正方形的头部图片了. 1234.header-img{ height : 100vmin; width : 100vmin;} 这几个属性, 除了flex, 其他都支持IE9+, 而flex支持IE10+, 使用到的情况还是比较多的, 熟悉多用为好.","link":"/2017/03-15-css3-flex-rem/"},{"title":".Net正则平衡组使用","text":"在.Net中, 正则表达式匹配支持两种高级语法: 匹配到的指定组名(?&lt;Group&gt;...) 根据组名的几种操作方式(?&lt;-Group&gt;), (?(Group)yes|no) 指定组名用?&lt;Group&gt;或?'Group'两种语法, 都可以为匹配到的组命名. 1234567var reg = new Regex(&quot;name:(?'groupName'[a-zA-Z0-9_-]+)&quot;);//var reg = new Regex(&quot;name:(?&lt;groupName&gt;[a-zA-Z0-9_-]+)&quot;);var matches = reg.Matches(&quot;name:test1,name:test2&quot;);foreach (Match m in matches){ var name = m.Groups[&quot;groupName&quot;].Value;} 组堆栈在使用?&lt;Group&gt;语法时, .net会将匹配到的内容压入堆栈stack. 然后在之后的匹配中, 可以使用语法?&lt;-Group&gt;从堆栈顶部弹出名字为&lt;Group&gt;的命名组, 如果堆栈为空, 那么该组匹配失败. 123456var reg = new Regex(&quot;name:(?&lt;nameMatch&gt;(?'stack'{[^{}]+)(?'-stack'}))&quot;);var matches = reg.Matches(&quot;name:{abc}&quot;);foreach (Match m in matches){ var name = m.Groups[&quot;nameMatch&quot;].Value;//{abc}} (?(Group)yes|no)的意义是, 如果堆栈上还存在名字为Group的组内容是, 执行yes语句, 否则执行no语句. 这时候可以使用(?!)零宽负向先行断言, 由于没有后缀表达式, 试图匹配总是失败. 即如果还存在Group时, 直接失败. 这几种语法结合起来, 就可以构造递归匹配的方法了. 如匹配类json格式字符串{l:{l1:{l2:3}}}. 1234567var reg = new Regex(@&quot;\\{(?&lt;match&gt;.+)\\}&quot;);//匹配到内容 : &quot;l:{l1:{l2:3}}&quot;//存在问题, 如果字符串为 &quot;{l:{ {l1:{l2:3}}}&quot; 也能匹配到全部var reg = new Regex(@&quot;\\{(?&lt;match&gt;(?&gt;[^{}]+|(?&lt;stack&gt;\\{(?!\\{))|(?&lt;-stack&gt;\\}))*(?(stack)(?!)))\\}&quot;);// {l:{l1:{l2:3}}} =&gt; l:{l1:{l2:3}}// {l:{ {l1:{l2:3}}} =&gt; l1:{l2:3}// {l:{ {l1:{ {l2:3}}} =&gt; l2:3 解释: 找到第一个{开始, 命名为match匹配组, 使用(?&gt;)非回溯(又名贪婪)匹配法则和固化分组进行内容匹配(对性能好), 匹配到 : 所有不是{}符号的内容[^{}]+ 或者如果是{, 而且后面不为{的内容则压入stack, 如果是}, 则弹出stack. 一直匹配到最后(贪婪模式), 如果最后还有stack, 则匹配失败({}数量不正确的情况不会匹配到). 这种语法的帮助在于可以递归匹配内容, 而且判断内容是否正确. 比如做SQL动态(0 嵌套)解析, 即可使用正则平衡组匹配. 1234567891011121314151617181920212223242526\\{\\? #匹配括号开始 -- 有一个括号和问号 (?&lt;DynamicClause&gt; #分组别名DynamicClause (?&gt; #非回溯(也称为 贪婪 )子表达式。 即在贪婪条件下匹配过去满足条件的, #如果碰见后面不满足的,则不会退回字符再查找 #用(?&gt;…)实现固化分组(成功匹配后，回溯时不会考虑这个匹配的字符) #!正常情况则是贪婪匹配,如果碰见不满足的可以退回字符再次查找满足的 [^\\{\\}]+ #除了{}的字符串 | #或者 \\{\\?(?&lt;Clause&gt;) #{[0-1个问号]push字符串到Clause -- 括号,可能有个问号,然后把Clause放进去 #命名捕获组,遇到正括弧Clause计数加1 | #或者 \\}(?&lt;-Clause&gt;) #}pop字符串Clause -- 反括号,然后把Clause弹出 #狭义平衡组,遇到闭括弧Clause计数减1 )* #0-n个这种字符串 (?(Clause)(?!)) #如果还有Clause匹配失败 ) #分组结束\\} #匹配括号结束//使用语法select * from tablewhere row = #row# and IsDel = 0 {? and a = #AValue#} {? and ({? b like '%' + #input# + '%'} {? or c = #input#})}","link":"/2017/04-28-regex-group-match/"},{"title":"使用docker建立redis集群提供系统缓存","text":"最近做了系统的权限以及动态权限sql和配置库, 为了提升性能, 都做到了缓存里面, 缓存方法是, 当更新内容时同步写入锁清空缓存, 读取数据时使用可升级读取锁来读取缓存, 如果缓存为空时候升级写入锁读取数据库并写入缓存. 这样在单服务器上是比较好的读写策略了, 但是在多台服务器上却不能这样使用, 而需要使用其他的服务器来提供订阅更新等机制. 目前使用了redis. docker为了redis的高可用, 需要创建redis集群, 这里选择建立在多个docker环境中. 首先安装docker. 123sudo apt-get install curl //安装curlcurl -sSL https://get.docker.com/ | sh //获取最近版本dockerdocker run hello-world //安装完成以后测试是否成功 Dockerfile创建Dockerfile文件. 123456789101112131415// /usr/local/docker-files/DockerfileFROM redis:4.0.1MAINTAINER zhoucongENV REDIS_HOME /usr/localRUN mkdir $REDIS_HOME/confWORKDIR $REDIS_HOME/conf## 创建一个redis.conf文件，打开集群相关配置，默认端口不写的话为6379RUN echo &quot;cluster-enabled yes&quot; &gt; redis.confRUN echo &quot;cluster-config-file redis-nodes.conf&quot; &gt;&gt; redis.conf## 初始化容器时启动redis实例CMD [&quot;redis-server&quot;,&quot;/usr/local/conf/redis.conf&quot;] redis-container根据Dockerfile创建容器. 1docker build -t zhoucong/redis-test . 下载完成以后, 在/usr/local/redis/conf/下分别建立6501-65066 个文件夹, 因为redis集群至少需要 3 台主从机. 在每个文件夹下建立配置文件. 123cluster-enabled yescluster-config-file redis-nodes.confport 6501 //port(n) start docker启动这些 redis 节点 123456docker run -d --name redis-m-01 -v /usr/local/redis/conf/6501/:/usr/local/conf -p 6501:6501 -p 16501:16501 zhoucong/redis-testdocker run -d --name redis-m-02 -v /usr/local/redis/conf/6502/:/usr/local/conf -p 6502:6502 -p 16502:16502 zhoucong/redis-testdocker run -d --name redis-m-03 -v /usr/local/redis/conf/6503/:/usr/local/conf -p 6503:6503 -p 16503:16503 zhoucong/redis-testdocker run -d --name redis-c-04 -v /usr/local/redis/conf/6504/:/usr/local/conf -p 6504:6504 -p 16504:16504 zhoucong/redis-testdocker run -d --name redis-c-05 -v /usr/local/redis/conf/6505/:/usr/local/conf -p 6505:6505 -p 16505:16505 zhoucong/redis-testdocker run -d --name redis-c-06 -v /usr/local/redis/conf/6506/:/usr/local/conf -p 6506:6506 -p 16506:16506 zhoucong/redis-test 在主机中安装好redis后, 进入/redis/src/, 执行命令 redismake redis-cluster123456789sudo gem install redis //安装ruby的redis模块//创建集群ruby redis-trib.rb create --replicas 1 \\10.200.200.227:6501 10.200.200.227:6502 10.200.200.227:6503 \\10.200.200.227:6504 10.200.200.227:6505 10.200.200.227:6506//如果一直出现Waiting for the cluster to join.需要手动设置防火墙sudo ufw allow 6501-6506 16501-16506 connect redis-cluster本机连接docker里的redis 1234567//如果不使用-c, 会因为插槽不对报错/redis/src/redis-cli -c -h 10.200.200.227 -p 6501&gt; set test demo// -&gt; Redirected to slot [6918] located at 172.17.0.1:6502 ok 成功&gt; get test // -&gt; demo redis-lock到这里就成功了, 在后台使用相关库连接到redis, 然后就可以直接使用了. 缓存做法则改成在服务器中使用一级缓存, 全局使用redis来提供二级缓存, redis里不存在数据时去数据库获取数据并更新到redis中, 当更新数据时候先保存到数据库, 然后清空一级和二级缓存, 同时发布一个事件到redis中, 其他的服务器在订阅事件处理中清空一级缓存. 利用redis的SETNX和GETSET命令来锁住缓存对象, 防止并发时数据错误覆盖和死锁. 当然, 这只是一个简单的redis锁的实现, 而且不够强壮, 但是对于我们系统的使用已经足够, 而且系统也额外提供了清空和重新读取缓存的功能. 如果想要比较强壮的redis分布式锁, 可以参考这篇文章: 基于 Redis 的分布式锁到底安全吗（上）, 基于 Redis 的分布式锁到底安全吗（下）. 1234567891011//redis防止并发覆盖while(SETNX(cacheLock,now + 30s) == 0)//设置30s超时{ if(now &gt; GET(cacheLock) &amp;&amp; now &gt; GETSET(cacheLock,now + 30s)){ break;//成功拿到锁, 并给锁设置新值 }else{ Thread.sleep(500); }}//dosthDEL(cacheLock)","link":"/2017/05-22-docker-redis/"},{"title":"ES6 import 模块导入分析","text":"ES6使js可以进行模块化开发了, 而模块化开发很容易的一个问题就是循环依赖. 而ES6的模块加载为引用形加载, 虽然对于函数这种可以动态找到值不会出现循环依赖的问题, 但是对于那些直接在外部定义的值还是会直接执行, 而这种情况就会出现值的循环依赖关系. 对于值循环依赖的这种情况一般都是可以避免的, 只要提取出来成为公共值即可. 而在提取时需要一个个文件跟踪import查看依赖, 太麻烦了, 所以为项目组提供一个import分析器来解决这个事情. 123456789101112131415161718192021222324252627282930313233343536public void Resolve(Dictionary&lt;string, JsFile&gt; dic){ if (this.ImportStatus != JsFileImportStatus.ImportNone) { this.ImportStatus = JsFileImportStatus.ImportComplete; return; } this.ImportStatus = JsFileImportStatus.Importing; foreach (var im in this.ImportStrings) { try { var tmpFile = GetJsFile(this.FilePath + im, dic, im); if (tmpFile.ImportStatus == JsFileImportStatus.ImportNone) {//刚刚拿到的新文件 //tmpFile.ImportStatus = JsFileImportStatus.Importing; this.Imports.Add(new ImportStruct(tmpFile, JsFileImportStatus.ImportNone)); } else if (tmpFile.ImportStatus == JsFileImportStatus.Importing) {//在前面正在导入中了 //tmpFile.ImportStatus = JsFileImportStatus.ImportComplete; this.Imports.Add(new ImportStruct(tmpFile, JsFileImportStatus.Importing)); } else if (tmpFile.ImportStatus == JsFileImportStatus.ImportComplete) {//之前已经导入完成了 this.Imports.Add(new ImportStruct(tmpFile, JsFileImportStatus.ImportComplete)); } tmpFile.Resolve(dic); } catch (Exception e) { continue; } } this.ImportStatus = JsFileImportStatus.ImportComplete;} 全部代码和软件在github中有, 使用效果如下: 左边的依赖树中, 绿色表示依赖关系正常, 红色表示依赖出现循环, 需要解决的地方. 右边显示的是依赖关系解析的json值, 如果需要可以拿去仔细分析依赖. 分析依赖原理基本和import原理一致, 按顺序依次加载, 如果遇到已经加载完成的, 则作为已经成功的, 显示绿色, 如果遇到新文件, 则标记为正在加载中, 如果遇到正在加载中的, 说明出现了循环依赖, 显示为红色, 需要处理该文件的加载问题.","link":"/2017/05-31-es6-import-module-analyse/"},{"title":"SqlServer 开窗函数","text":"在mysql中, select a,count(b) from t这种语法是可以通过的, 选出来的a列是b中的第一个值. 但是在oracle和mssql中, 这种语法是不能用的, mssql会提示: 选择列表中的列'a'无效, 因为该列没有包含在聚合函数或GROUP BY 子句中. 简单点的解决办法是使用子查询: 1select a , (select count(b) from t) from t 但是这种sql写起来比较复杂, 而且查询性能不好, 这时候就可以使用开窗函数来解决这种问题了. 开窗函数语法有两种: 聚合开窗函数, 聚合函数(row) OVER (PARTITION BY) 排序开窗函数, 排序函数(row) OVER ([?PARTITION BY] ORDER BY) 1select a , count(b) over () from t 简单点可以理解为, 如果是聚合函数, 那么PARTITION BY即指定某些列, 聚合那些列数据相同的数据. 比如统计字段为月份, 那么就是每个月的值分别相加统计. 比起GROUP BY指定部分列统计时, 整个SELECT语句全在GROUP BY统计上灵活多了, 而且可以指定不同列来统计.对于几个排序函数ROW_NUMBER, RANK, DENSE_RANK, NTILE来说, 可以使用OVER (ORDER BY)字句, 即指定某些字段进行ORDER BY然后得出排名, 可以在一个查询中得到多种类型的排序, 而在ORDER BY前还可以使用PARTITION BY字句, 语法和效果与GROUP BY ORDER BY一样.","link":"/2017/06-08-sqlserver-over-partition-by/"},{"title":"react 1 - jsx 和 组件","text":"react在看本篇之前, 应该有ES6语法基础. 如果没有, 推荐去学习阮一峰的 ES 6 入门. jsxreact与其他前端 MVVM 框架的最大区别之一应该就在于jsx与html-templete的区别了. 以前的框架都是基于已经存在的html做优化和操作, react却是舍弃了html, 用jsx来替代html的功能, 如果不了解的, 可以把jsx想象成高级版本的javascript代码, 所以比原始的html功能强大得多. 下面介绍jsx. 基本语法12345678const World = ({ children }) =&gt; ( &lt;div&gt; {children} {1 + 1} &lt;span&gt; World!&lt;/span&gt; &lt;/div&gt;);ReactDOM.render(&lt;World&gt;Hello&lt;/World&gt;, document.querySelector('#container')); 上面就是react创建一个组件的代码. jsx即在js代码里面写的类似html构建页面的代码, 语法类似xml, 所以叫jsx. 可以看到, ReactDOM.render函数的第一个参数就是jsx格式的内容, 而World函数的返回值也是一个jsx的内容.在react里面规定, 如果是大写字母开头的元素, 即作为自定义组件创建, 小写字母开头的元素, 即作为html原始控件创建. 所以World方法首字母必须大写.那么react到底怎么执行jsx的呢, 这看起来和原始的js以及html区别也太大了点, 下面我们就来看看jsx怎么执行的.首先, 浏览器是不可能认识jsx的, 那么就有一个叫babel的插件会把jsx编译成js代码, 和我们平常写的代码差不多, 来看看jsx的js版本吧. 123456'use strict';var World = function World(_ref) { var children = _ref.children; return React.createElement('div', null, children, 1 + 1, React.createElement('span', null, ' World!'));};ReactDOM.render(React.createElement(World, null, 'Hello'), document.querySelector('#container')); 以上代码就是最开始的例子, 由babel编译过后生成的js代码, 浏览器看到的也是这个代码. 从这个代码里我们来分析一下jsx的执行.首先创建一个World函数, 返回值是React.createElement创建的一个对象, 对象第五个参数又是一个对象, 不过大概根据内容能猜到是&lt;span&gt; World!&lt;/span&gt;这行代码. 而我们在jsx里写的{...}这种语法, 都被直接转换成了 js 加入到了参数列表中. 接下来我们看看React.createElement这个函数吧(删掉了一点&quot;development&quot; !== 'production'的代码, 不影响逻辑). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ReactElement.createElement = function (type, config, children) { var propName; // Reserved names are extracted var props = {}; var key = null; var ref = null; var self = null; var source = null; if (config != null) { if (hasValidRef(config)) { ref = config.ref; } if (hasValidKey(config)) { key = '' + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object for (propName in config) { if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) { props[propName] = config[propName]; } } } // Children can be more than one argument, and those are transferred onto // the newly allocated props object. var childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength &gt; 1) { var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } // Resolve default props if (type &amp;&amp; type.defaultProps) { var defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);}; 可以看到, 这个函数接收三个参数, type,config,children, type就是span或者我们的World, config是传入的配置信息暂时不用管, children应该就是子节点, 在函数下部分可以看见, 判断如果childrenLength &gt; 1时, 将children拼成数组, 设置到 props 上.这样看来jsx其实很简单, 如果不想写jsx, 也可以手动调用React.createElement创建组件, 不过一般不需要这么做, 了解原理就好了. 组件声明方式无状态组件和有状态组件组件化是react的核心思想, react提供了两种组件声明方式, 上面使用的是函数式声明无状态组件, 还可以使用class extends React.Component方式声明有状态和生命周期的组件. 无状态组件是基于函数式思想, 同样的输入得到同样的输出, 而且react对无状态组件不会产生实例, 无实例化也就不需要分配多余的内存, 从而性能得到一定的提升. 原理上来说就是一直调用函数而已. 有状态组件可以使用react的生命周期函数, 实现一些高级功能. 123456789101112131415161718192021222324252627class World extends React.Component { render() { return ( &lt;div&gt; {this.props.children} &lt;span&gt; World!&lt;/span&gt; &lt;/div&gt; ); }}//jsx编译的代码var World = (function (_React$Component) { _inherits(World, _React$Component); function World() { _classCallCheck(this, World); return _possibleConstructorReturn(this, (World.__proto__ || Object.getPrototypeOf(World)).apply(this, arguments)); } _createClass(World, [ { key: 'render', value: function render() { return React.createElement('div', null, this.props.children, React.createElement('span', null, ' World!')); }, }, ]); return World;})(React.Component); 由编译后的代码可以看见, 在jsx的转换这块, 并没有什么区别. 组件的生命周期react有状态组件是有生命周期的, 从初始化到加载到销毁, 都可以设置相关函数. 下面来看看生命周期函数. getDefaultProps [=&gt; static defaultProps] getInitialState [=&gt; constructor(props, context)] componentWillMount render componentDidMount componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) componentDidUpdate(prevProps, prevState) componentWillUnmount 除开getDefaultProps和getInitialState, react组件一共有 8 个生命周期函数可以使用. getDefaultProps和getInitialState是使用React.createClass()方式时的初始化方法, 在ES6``class类型的组件里面, 已经由static defaultProps和constructor(props, context)替代.这些函数的执行顺序依次是从上到下, 而且在componentWillUpdate和componentDidUpdate中间还会触发一次render函数. 网上有一张比较好的图说明它们的关系. 两种功能组件组件从功能性来说, 可以分为两种功能: 做页面展示和做逻辑交互. 所以我们写组件一般分成两种类型: 展示组件和容器组件. 展示组件 展示组件只做纯页面展示 可以包含子级的展示组件, 一般含有自定义样式 可以使用this.props.children来包含其他组件 一般不依赖其他组件和数据, 所有的数据都是由父级传入 可以有自己的状态变量, 不过一般都是为展示UI使用的变量 大多数都可以写成函数式组件, 除非有自己的状态变量 如果有自己的事件触发, 那么都会有相应的事件响应函数, 响应函数通常由父级传入. 展示组件所在文件夹为component 容器组件 容器组件一般包含很多个展示组件, 也可以有其他容器组件 容器组件一般很少有自定义样式, 基本都是用作包裹的div标签 容器组件负责从后台获取数据, 并交给展示组件负责展示 容器组件可以从展示组件的事件触发回调函数中获取数据并与后台交互 维持许多状态变量, 通常作为数据源 一般使用高阶组件生成(Redux.connect) 容器组件一般有自己的action和reducer 容器组件所在文件夹为container","link":"/2017/08-01-react-day-1/"},{"title":"react 2 - route","text":"route可以说是现在的单页应用必备的功能了, 那么在react里, 官方也提供了一个路由库react-router, 也是唯一的一个路由库, 也提供了官方教程, 下面来看看如何使用吧. 注: 本文基于react-router 4.x先看一个简单的例子, 从这个例子来学习router的基本使用方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, { Component } from 'react';import ReactDOM from 'react-dom';import { BrowserRouter as Router, Route, HashRouter, Link, NavLink } from 'react-router-dom';var destination = document.querySelector('#container');class App extends Component { render() { return ( &lt;div&gt; &lt;h1&gt;Simple SPA&lt;/h1&gt; &lt;ul className='header'&gt; &lt;li&gt; &lt;NavLink exact to='/' activeClassName='active'&gt; Home &lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to='/stuff' activeClassName='active'&gt; Stuff &lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to='/contact' activeClassName='active'&gt; Contact &lt;/NavLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className='content'&gt;{this.props.children}&lt;/div&gt; &lt;/div&gt; ); }}var Home = () =&gt; ( &lt;div&gt; &lt;h2&gt;HELLO&lt;/h2&gt; &lt;p&gt; Cras facilisis urna ornare ex volutpat, et convallis erat elementum. Ut aliquam, ipsum vitae gravida suscipit, metus dui bibendum est, eget rhoncus nibh metus nec massa. Maecenas hendrerit laoreet augue nec molestie. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;p&gt;Duis a turpis sed lacus dapibus elementum sed eu lectus.&lt;/p&gt; &lt;/div&gt;);var Contact = () =&gt; ( &lt;div&gt; &lt;h2&gt;GOT QUESTIONS?&lt;/h2&gt; &lt;p&gt; The easiest thing to do is post on our &lt;a href='http://forum.kirupa.com'&gt;forums&lt;/a&gt;. &lt;/p&gt; &lt;/div&gt;);var Stuff = () =&gt; ( &lt;div&gt; &lt;h2&gt;STUFF&lt;/h2&gt; &lt;p&gt;Mauris sem velit, vehicula eget sodales vitae, rhoncus eget sapien:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Nulla pulvinar diam&lt;/li&gt; &lt;li&gt;Facilisis bibendum&lt;/li&gt; &lt;li&gt;Vestibulum vulputate&lt;/li&gt; &lt;li&gt;Eget erat&lt;/li&gt; &lt;li&gt;Id porttitor&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;);ReactDOM.render( &lt;Router&gt; &lt;App&gt; &lt;Route exact path='/' component={Home} /&gt; &lt;Route path='/Contact' component={Contact} /&gt; &lt;Route path='/Stuff' component={Stuff} /&gt; &lt;/App&gt; &lt;/Router&gt;, destination,); NavLink即我们的a元素, 可以指向要跳转到的url, activeClassName可以指定一个在当前页面url和NavLink指向的url相匹配时候的class, 方便做一些样式高亮设计. Route组件则是路由实现的关键组件, 作用是当to属性里面的url匹配到当前页面, 则展示component中的组件. 在新版本中, Route已经变成随处可用的组件了, 可叠加可嵌套. 而且需要用到的组件都是从react-router-dom包里导出. 更多的例子可以去官网示例中查看. 在一般的项目中, 推荐将一级路由配置在页面最外层的组件里, 方便集中管理和维护, 如果内层组件有自己的router, 可以在组件内实现. 这是为了将子组件和主模块解耦. 如果项目需要权限管理, 推荐配置动态路由, 即路由数据由服务器根据个人权限获得. 而且可以根据需要, 将组件进行异步加载, 优化页面首次加载的速度. Redirect为重定向组件, 表示从path转向to, Switch组件即在下级的路由组件中只匹配一次, 由于匹配是按顺序进行, 所以我们的重定向到首页组件需要写在最后一位. exact属性表示精确匹配, 否则是模糊匹配. 12345678910111213141516&lt;div className='right-content'&gt; &lt;Switch&gt; {this.state.routeList.map((item, index) =&gt; { if (item.get('to')) { return &lt;Redirect key={index} path={item.get('url')} exact={item.get('exact')} to={item.get('to')} /&gt;; } else if (item.get('src')) { return &lt;Route key={index} path={item.get('url')} exact={item.get('exact')} render={() =&gt; &lt;AsyncComponent src={item.get('src')} /&gt;} /&gt;; } else { return null; } })} &lt;Route exact path='/' render={() =&gt; '欢迎来到首页'} /&gt; &lt;Redirect path='*' to='/' /&gt; &lt;/Switch&gt; {this.props.children}&lt;/div&gt; react-router原理hash-router本质上是基于浏览器提供的window.onhashchange事件, 只要改变location.hash, 就会触发该事件, 进行路由拦截和组件加载判断. 但是为了统一化, history模块也将hash-router封装成了和browser-router一样的使用方式和原理. browser-router本来浏览器提供了window.onpopstate来监听浏览器url改变事件, 但是通过js执行history.pushState({},title,url)或者history.replaceState时候, 却不会触发onpopstate事件, 所以只能自己实现一套拦截的体系. react使用的是history模块.在组件初始化的时候通过history.createBrowserHistory生成一个history对象, 该对象里面有一个事件监听列表和相关事件. 在Link组件中的a标签点击时, 使用preventDefault阻止页面跳转, 然后通过history.push/replace(to)进行跳转url. 在Router组件中的componentWillMount时, 会通过history.listen设置监听, 如果url有变化则通过setState进行修改. 而在使用Redux和PureComponent的情况下, setState不会引起下级组件的更新, 那么在ConnectedRouter中的componentWillMount中, 也添加了history.listen来监听url的更改, 同时通过store.dispatch({type: LOCATION_CHANGE,payload: location})来发送action到reducer中, 这就是为什么引入immutable时, 需要手动设置routerReducer在action.type === LOCATION_CHANGE时候的原因了.","link":"/2017/08-02-react-day-2/"},{"title":"react 3 - redux","text":"前言 “如果你不知道是否需要 Redux, 那就是不需要它. “ 虽然有这样一句话, 可是作为开发, 却是必须要学会使用的, 只有你会了以后, 才可以来探讨你的项目里面是否需要Redux. Fluxreact为我们的整个应用提供了界面搭建的方法, 如果你的组件够多, 那么就可以像拼积木一样一点点搭建你的应用. 而react的Render是一个纯函数, 只要组件有同样的state和props, 那么你就会得到同样的view. 而Flux的理念就是使state变成不可写, 而是由action分发的方式在内部处理好数据, 再传给state, 而避免组件自己随意修改state造成不可预知的问题. ReduxRedux是Flux思想的一种实现方式, 与react结合使用更加方便. 而Redux的设计思想很简单, 就两句话: 应用是一个状态机, 视图与状态是一一对应的. 所有的状态, 保存在一个对象里面. 基本概念store在整个应用中, 只有一个store, 它保存着所有数据. 如果想得到某个时间点的数据, 就需要对store生成快照, 生成快照的方法是store.getState(), 那么这个快照自然就叫做state了. 注意, 此state和组件里面的state不是一个概念, 也不会有直接的交集. Redux规定, 一个state对应一个view, 只要state是相同的, 那么生成的view应该也是一样的. actionstate已经有了数据, 那么自然就需要有改变数据的方式, 这个方式就是action, 同时也是唯一的方式. 对于view, 不能直接接触到state和store, 只能通过发送action的方式来改变store. action是一个对象, 其中type属性是必须的, 其他属性都属于携带的信息, 一般通过payload来传递. 1234const action = { type: 'ADD_TODO', payload: {},}; action creatoraction既然是一个对象, 那么创建这个对象肯定不会是手写, 而是有一个方法来自动生成, 那么生成这个action的方法即action creator. 123456static addTodo(v) { return { type: ActionType.ADD_TODO, payload: v, }} addTodo函数即为ADD_TODO的action creator. dispatch有了action creator和生成的action, 那么怎么让store知道这个action呢, store.dispatch(action)就是用来发出action的唯一方法. reducer声明和使用当调用store.dispatch之后, 怎么去改变state呢, 这就是reducer的功能了. 每个reducer都是一个函数, 它的参数是当前state和action, 返回值是一个新的state, 这样view就会根据新的state去绘制界面了. 12345678910const defaultState = 0;const reducer = (state = defaultState, action) =&gt; { switch (action.type) { case ActionType.ADD_TODO: return state + action.payload; default: return state; }};const store = createStore(reducer); 当创建好reducer函数之后, 需要让store知道这个函数, 然后store会在调用dispatch时, 自动触发所有的reducer函数. createStore中的reducer参数就是让store去连接指定的reducer方法. 纯函数reducer必须是一个纯函数, 意义是每次执行会得到相同的结果. 所以不能调用Data.now()或Math.random()等方法. 但是由于是纯函数, 基于函数式编程的理念, 是不能改变原始对象的. 所以如果是对象, 返回值应该是return { ...state, ...newState }. 如果对象结构层级特别深, 那么创建newState就会是一个很麻烦的事情, 而且可能会不小心改变state后也会出现其他错误, 这就是为什么需要immutable的原因. subscribestore提供subscribe方法来设置一个监听函数, 只要state发生改变, 那么就会执行这个监听函数. subscribe方法返回一个解除监听的函数unsubscribe, 执行unsubscribe就可以取消监听. 12let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 工具函数combineReducers一般都会用到的函数, 如果你的reducer有很多个, 那么你就需要用到这个函数创建出一个rootReducers对象来提供给store连接reducer函数. 1234const RootReducer = combineReducers({ todoReducer: todoReducer,});const store = createStore(RootReducer); connectconnect方法可以为你的展示组件创建对应的容器组件. connect方法签名为connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]). mapStateToProps(state, ownProps) : stateProps mapDispatchToProps(dispatch, ownProps): dispatchProps mergeProps(stateProps, dispatchProps, ownProps): props options为选项, 使用到的地方很少 mapStateToProps(state, ownProps) : stateProps从名字可以看出, 此函数是把state的属性赋给props(此处state非组件state, 而是store的state). 当state变化, 或者ownProps变化的时候, mapStateToProps都会被调用(此处ownProps是上级组件的props传入到connect生成的高阶组件的props, 不是被connect的组件的ownProps), 计算出一个新的props更新给组件, 并触发组件的componentWillReceiveProps方法. 12345const mapStateToProps = (state, ownProps) =&gt; { return { count: state.count, }} mapDispatchToProps(dispatch, ownProps): dispatchProps从名字也可以看出来, 是把dispatch方法映射到props上, 不过没有mapStateToProps那么直观. 在ownProps变化时, mapDispatchToProps 也会再次执行, 计算出一个新的值更新到props上. 12345const mapDispatchToProps = (dispatch, ownProps) =&gt; { return { addTodo: (v) =&gt; dispatch(action.addTodo(v)), }} 传入这个函数以后, 在组件的props上, 就可以使用addTodo方法了.redux提供了bindActionCreators用来快速将action生成可调用的函数. 12345const mapDispatchToProps = (dispatch, ownProps) =&gt; { return bindActionCreators({ addTodo: action.addTodo, })} mergeProps(stateProps, dispatchProps, ownProps): props这个函数就是用来将上面两个函数生成的值复制到props里面的函数, 如果不传这个函数, 默认调用的是Object.assign方法. createStorecreateStore(reducer, initialState, enhancer): store是创建store的唯一方法, reducer即全部的reducers, initialState为store的初始化值, enhancer即可以让我们生成加强版本的store的方法. 1234567891011//createStore中enhancer有关的源码if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') { enhancer = preloadedState; preloadedState = undefined;}if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.'); } return enhancer(createStore)(reducer, preloadedState);} 可以看到enhancer应该是一个方法, 接收createStore作为参数, 返回一个新createStore的方法, 再传入reducer, preloadedState参数执行. applyMiddlewareapplyMiddleware方法生成的函数即enhancer所表示的值, 从enhancer实现可以看出, applyMiddleware有两种调用方式. 12345//1const createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);const store = createStoreWithMiddleware(reducer, preloadedState);//2const store = createStore(reducer, preloadedState, applyMiddleware(...middleware)); ReduxThunk重点说说ReduxThunk中间件, 它是与后台交互的必备中间件, 使我们在dispatch中可以发出异步的action. 它的源码也是十分简单. 123456789101112131415function createThunkMiddleware(extraArgument) { return function ({ dispatch, getState }) { return function (next) { return function (action) { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); }; }; };}var thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 使用的时候也很简单. 12345678910111213static addTodo(v) { return (dipatch, getState) =&gt; { return Service.addTodo(v).then( (resultValue) =&gt; { let action = { type: ActionType.ADD_TODO, payload: resultValue, }; dipatch(action); }, ); };} ProviderProvider严格来说应该是组件, 不过class本质也是function, 所以放在一起了. Provider组件即让整个应用都可以直接拿到store的组件. 原理是react中的context. 123456789101112131415161718192021//源码class Provider extends Component { getChildContext() { return { store: this.props.store }; } render() { return this.props.children; }}Provider.childContextTypes = { store: React.PropTypes.object}//使用ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector(&quot;#container&quot;))","link":"/2017/08-03-react-day-3/"},{"title":"react 4 - immutable","text":"这是应该是基本系列的最后一节了. 上节使用了redux, 在redux的reducer里面的返回值应该是一个新的state对象, 而不是在旧的state对象上进行修改, 那么在ES6语法中, 就需要写很多{...state, ...newState}这种代码来创建新对象. 而且如果改变的值的所在对象层次比较深, 那么这样的代码写起来就很痛苦了. 为此, Facebook专门创建了一个库用于解决这种问题 - immutable. 引入immutable后, 整个应用的state应该都变为immutable类型, 那么在createStore时就需要修改一下初始值. 1const store = createStore(RootReducer, Immutable.Map(), applyMiddleware(...middleware)); 然后, 在combineReducers时候, 原来的state是直接使用=赋值替换的, 整个state变成immutable后, 语法也应该变成immutable提供的set方法, 那么combineReducers就需要重写了. 不过幸运的是, 已经有人把这项工作做好了. 使用redux-immutable包提供的combineReducers来替换原来redux提供的combineReducers. 123//import { combineReducers } from 'redux';import { combineReducers } from 'redux-immutable';const RootReducer = combineReducers({...}); 这两项工作做好以后, 我们就可以在reducer和component里使用immutable的数据结构了. 12345678const reducer = (state = defaultState, action) =&gt; { switch (action.type) { case ActionType.ADD_TODO: return state.update('value', (v) =&gt; (v + action.payload)); default: return state; }} 然后需要把router也整合进来, 构成react-router, react-redux, immutable的最佳开发环境. router本身就提供结合redux的方法, 需要自己改动的并不多. 首先需要改造我们的store创建过程. 123456789101112131415161718import { createStore, applyMiddleware } from 'redux';import ReduxThunk from 'redux-thunk';import { routerMiddleware } from 'react-router-redux';import Immutable from 'immutable';import { createLogger } from 'redux-logger';import { createBrowserHistory } from 'history';import RootReducer from './../_reducer'; // 所有的reducerlet history = createBrowserHistory();const middleware = [routerMiddleware(history), ReduxThunk];const initialState = Immutable.Map();const store = createStore(RootReducer, initialState, applyMiddleware(...middleware));export default store;export { history }; 这样创建的store就已经支持了router, 然后我们再加入router的reducer. 123456789101112131415161718192021//router-reducer.jsimport Immutable from 'immutable';import { LOCATION_CHANGE, } from 'react-router-redux';const initialState = Immutable.fromJS({ location: null,});export default function routerReducer(state = initialState, action) { if (action.type === LOCATION_CHANGE) { return state.set('location', Immutable.fromJS(action.payload)); } return state;};export const reducerName = 'routing';//reducer.jsimport { combineReducers } from 'redux-immutable';import routerReducer, { reducerName as routerReducerName } from './../route/route-reducer';const RootReducer = combineReducers({ [routerReducerName] : routerReducer, ...,});export default RootReducer; 这样, router便与immutable能结合使用了.我们再给我们的store做点增强.redux-logger是一个很常见的中间件, 可以为我们的每个action提供日志记录, 我们也将它加入. 12345import logger from 'redux-logger';if (process.env.NODE_ENV === 'development') { //在开发环境下可以看到log middleware.push(logger);} 但是这样生成的log在控制台显示的全是immutable对象, 并不是直接的js对象, 不方便展开查看. 去看redux-logger源码, 发现它也提供一个createLogger方法来让我们自己创建自己的logger. 1234567891011121314151617181920212223242526272829303132const defaultLogger = ({ dispatch, getState } = {}) =&gt; { if (typeof dispatch === 'function' || typeof getState === 'function') { return createLogger()({ dispatch, getState }); }};export { defaults, createLogger, defaultLogger as logger };export default defaultLogger;//createLoggerfunction createLogger(options = {}) { const loggerOptions = Object.assign({}, defaults, options); ...}//改造logger, 其实等于创建一个自己的中间件import { createLogger } from 'redux-logger';if (process.env.NODE_ENV === 'development') { //在开发环境下可以看到log middleware.push(({ dispatch, getState }) =&gt; { return createLogger({ collapsed: true })({//collapsed还可以是个action dispatch, getState: () =&gt; { return getState().toJS(); } }); });}//官方推荐做法是import { Iterable } from 'immutable';const stateTransformer = (state) =&gt; { if (Iterable.isIterable(state)) return state.toJS(); else return state;};const logger = createLogger({ stateTransformer,}); 到目前为止, 一个react + react-router + react-redux + immutable的开发环境工程就搭建完成了.","link":"/2017/08-04-react-day-4/"},{"title":"react 高阶组件和 ES6 修饰器","text":"在以前使用createClass创建组件的时候, react提供mixin方法将其他公用方法注入组件. 但是在extends Component时, 我们可以使用高阶组件以及@decorator来解决这个问题. 高阶组件的原理很简单: 提供一个函数, 函数接受一个组件, 返回一个新的组件. 由于js的特性, 组件也是一个函数, 也可以用来被继承, 所以出现了两种使用方式. 以子组件方式渲染原始组件(Props Proxy) 1234567function ppHOC(WrappedComponent) { return class PP extends React.Component { render() { return &lt;WrappedComponent {...this.props} /&gt;; } };} 在这个高阶组件里, 你可以做一切想做的事情, 包括拦截props, 或者获取子组件实例, 用其他元素包裹原始组件等. 常用的connect方法就是一个这样的函数. 新组件继承子组件(Inheritance Inversion) 1234567function iiHOC(WrappedComponent) { return class Enhancer extends WrappedComponent { render() { return super.render(); } };} 如同代码里看到的, 这种继承方式可以修改子组件的生命周期函数, 可以拦截子组件的render返回值, 并修改(这种情况对子组件是函数式组件无效). 一般用作拦截生命周期比较常见. 使用方法 普通的用法, 类似let HighComponent = connect(...)(Component) ES6提供的修饰器语法 12@connect(params)class MyComponent extends React.Component {...} 再来介绍下修饰器语法提供的一些便利.比如, 想在开发阶段, 把所有有生命周期的组件函数, 在经历生命周期时候, 提供一个日志记录. 这种时候就是使用修饰器方法的时候了. 123456789101112131415function componentLogger(target) { if (process.env.NODE_ENV !== 'development') { return target; } for (const func in funcColors) { if (target.prototype[func]) { ...//相关操作 } } return target;}export default componentLogger;//使用@componentLoggerclass MyComponent extends React.Component {...} 修饰器如果有参数, 一般都可以做得通用一点, 判断如果传入值是function时, 直接使用默认值加载修饰器, 如果传入值是object时, 作为options生成一个新的修饰器, 修饰所需要的内容. 123456789101112131415161718192021222324252627282930313233343536373839404142function ngCmd(arg) { if (_.isFunction(arg)) { const Wrapper = arg; return class WrapperComponent extends React.Component { render() { return &lt;NgCmd {...this.props} &gt;&lt;Wrapper {...this.props} /&gt;&lt;/NgCmd&gt;; } } } else if (_.isArray(arg)) { let i = 0; let args = []; if (arg.length == 0) { args = ['if', 'show', 'hide']; } else { ['if', 'show', 'hide'].forEach((value, index) =&gt; { if (arg.indexOf(value) &gt; -1) { i++; } }) if (i == 0) { throw 'need at least one ng-cmd'; } args = arg; } return (Wrapper) =&gt; { return class WrapperComponent extends React.Component { render() { let cmdsObj = {}; ['if', 'show', 'hide'].forEach((v, i) =&gt; { if (args.indexOf(v) &gt; -1 &amp;&amp; _.has(this.props, v)) { cmdsObj[v] = this.props[v]; } }) return &lt;NgCmd {...cmdsObj} &gt;&lt;Wrapper {...this.props} /&gt;&lt;/NgCmd&gt;; } } } if (_.has(cmdsObj, 'if') &amp;&amp; cmdsObj['if'] == false) { return null; } }}","link":"/2017/08-10-react-higher-order-components/"},{"title":"react component context","text":"在之前看react-redux时, 说到Provider组件是使用context来实现的, 现在就来看看context到底是个什么东西. 按照官方推荐的意思是, 尽量少使用context, 因为可能会造成应用程序不稳定, 而且作为实验性的 API, 可能会在未来版本移除. 好了, 警告看完了, 下面来继续使用它吧. 基本用法context是帮助你的应用更简单的传递多层数据的工具. 就如同Provider组件, 提供了一个store``props, 那么它的子级不管多深, 只需要connect一下, 便可以拿到该store, 完全没有props传递链的那种复杂写法. 12345678910111213class Provider extends Component { getChildContext() { return { store: this.props.store, }; } render() { return this.props.children; }}Provider.childContextTypes = { store: PropTypes.object,}; Provider的实现方法就差不多是这个样子, 通过它来学习context怎么使用. 首先, 提供数据的组件需要实现getChildContext方法, 返回一个对象, 对象值即为能提供的所有属性值, 还需要定义childContextTypes, 表示下级可以获取到的所有属性值. 如果没有定义childContextTypes, 那么下级的context将得到一个空对象.connect返回的是一个高阶组件, 这个组件定义了contextTypes, 然后就可以在组件相关生命周期函数里面获取到对应的值了. 123ConnectComponent.contextTypes = { store: PropTypes.object.isRequired,}; 生命周期函数context在如下五个生命周期函数里面都可以获取和使用: constructor(props, context) componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componentWillUpdate(nextProps, nextState, nextContext) componentDidUpdate(prevProps, prevState, prevContext) 无状态组件在无状态组件中也可以使用context, 会和props一样, 作为函数的第二个参数传入. 123456function FuncComponent(props, context) { return &lt;div&gt;{this.context.user.name}&lt;/div&gt;;}FuncComponent.contextTypes = { user: React.PropTypes.object.isRequired,}; 注意shouldComponentUpdate和props以及state一样, 当上级改变context时候, 会触发下级的相关生命周期函数, 在shouldComponentUpdate返回true时进行重新渲染.而与props和state不同的地方在于, context是可以跨组件传递的. 这就意味着, 可能有部分中间的组件并没有使用context, 而它们的props和state并没有变化, 在shouldComponentUpdate返回false的时候停止了子树的更新, 而子组件是使用context获取上层数据, 但是并没有被触发更新. 这就是为什么react-router需要使用withRouter来包裹connect以后的组件, 因为在connect中实现了shouldComponentUpdate, 会截断子树的render.所以react官方并不推荐更新context, 它应该作为一个固定的值来被全局使用, 否则可能在某些深层组件可能会出现意外的bug.","link":"/2017/08-19-react-context/"},{"title":"react 组件结合 jquery 组件","text":"看接下来的内容之前, 需要明白react以及github上已经提供了足够多的控件来供平常使用, 需要控件的时候可以查看. 如antd, react-components等. 这篇文章只是提供一个改造方案的解决思路, 如果有某些特殊需求的控件需要实现才手动改造. 引入jquery比较推荐全局引入jquery包, 减少打包的依赖而且有cdn可用, 引入其他jquery插件时也比较方便. 坏处是会暴露全局变量$, 不过并不是特别大影响. 如果不想全局引入, 可以在webpack里设置alias和ProvidePlugin结合expose-loader, 也可以达到类似全局效果(通过expose-loader和ProvidePlugin自动解析$变量), 引入其他插件. 引入插件包jquery全局可用以后, 插件包在什么地方加载都没区别, 可以在页面上引入, 也可以使用import. 这次拿来改造举例的是datetime-picker这个插件. 改造插件首先创建自己的组件, 由于是结合jquery, 那么肯定有自己的生命周期函数. 顺便带上componentLogger做生命周期日志. 123456789101112131415161718192021222324import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import classNames from 'classnames';import { componentLogger } from './../../common/decorators';@componentLoggerclass DateTimePicker extends React.PureComponent { static propTypes = {}; constructor(props) { super(props); this.state = {}; } componentDidMount() {} componentWillReceiveProps(nextProps) {} componentDidUpdate() {} render() { return null; } componentWillUnmount() {}}export default DateTimePicker; 先在render中写好结构和样式, 给上ref, 为使用jquery做准备. 这里为了方便自定义样式, 外层div和内层input的className都可以通过props传入. 123456render() { return (&lt;div className={classNames(&quot;date-time-picker input-group date&quot;, this.props.className)} ref=&quot;pickerDiv&quot;&gt; &lt;input ref=&quot;pickerInput&quot; type=&quot;text&quot; readOnly className={classNames(&quot;form-control&quot;, this.props.inputClassName)} {...this.state.inputProps} /&gt; &lt;span className=&quot;input-group-addon&quot;&gt;&lt;span className=&quot;glyphicon glyphicon-calendar&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt;)} 然后给它在componentDidMount中加上初始化函数. 12345678910111213141516componentDidMount() { this.resetDateTimePicker(this.state.options); this.refs.pickerInput.value = this.props.value;}resetDateTimePicker(options) { $(this.refs.pickerDiv).datetimepicker(options) .on('changeDate', (event) =&gt; { if (this.refs.pickerInput.value != this.props.value) { this.props.onChange({ target: this.refs.pickerInput, stopPropagation: event.stopPropagation, preventDefault: event.preventDefault, }); } });} 这里的options便是插件文档中给定可以设置的options了, 需要让它有默认值而且也可以从外部传入, 那么实现的地方应该在constructor和componentWillReceiveProps两个地方了. 123456789101112constructor(props) { super(props); this.state = { ...splitDateTimePickerOptionsAndInputProps(props), }}componentWillReceiveProps(nextProps) { this.setState(...splitDateTimePickerOptionsAndInputProps(nextProps)); if (nextProps.value != this.props.value) { this.refs.pickerInput.value = nextProps.value; }} splitDateTimePickerOptionsAndInputProps这个函数即从props里拿到设置值和混合默认值的函数. 12345678910111213141516171819202122232425262728const defaultDateTimePickerOptions = { language: 'zh-CN', format: &quot;yyyy-mm-dd&quot;, autoclose: true, todayHighlight: true, forceParse: true, minView: 2, maxView: 5, todayBtn: true,};const needRemoveInputProps = ['onChange', 'value', 'className', 'inputClassName'];const splitDateTimePickerOptionsAndInputProps = (props) =&gt; { const propsKeyStartsWith = 'dateTime'; let options = { ...defaultDateTimePickerOptions, }; let inputProps = {}; for (let key in props) { if (key.startsWith(propsKeyStartsWith)) { options[key.substring(propsKeyStartsWith.length)] = props[key]; } else if (needRemoveInputProps.indexOf(key) == -1) { inputProps[key] = props[key]; } } return { options, inputProps };} 需要注意的是, defaultDateTimePickerOptions, needRemoveInputProps, splitDateTimePickerOptionsAndInputProps这种可能会改变或变动的代码, 最好写在组件外面. defaultDateTimePickerOptions即如果没有传入相关设置值的清空下使用的默认值, needRemoveInputProps表示这些值是特殊的, 不会传递到input组件上, 其他的值提取出来后都可以传递到input组件上. 在splitDateTimePickerOptionsAndInputProps函数中, 把以dateTime开头的props都拿出来, 放到options对象中, 其他的放到inputProps对象中, 最后将它们返回. 不过现在还有个问题, 如果外面的props改变了, 控件需要重新加载. 1234567891011componentWillReceiveProps(nextProps) { this.setState({...splitDateTimePickerOptionsAndInputProps(nextProps)}); if (nextProps.value != this.props.value) { this.refs.pickerInput.value = nextProps.value; }}componentDidUpdate(prevProps, prevState) { if (!_.isEqual(prevState.options, this.state.options)) { this.resetDateTimePicker(this.state.options); }} 为了优化性能, 这里使用了lodash来深度比较两个对象, 如果有不同的options, 才重置DateTimePicker. 再在componentWillUnmount中加上析构函数 123componentWillUnmount() { $(this.refs.pickerDiv).datetimepicker('remove');} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import classNames from 'classnames';import { componentLogger } from './../../common/decorators';const defaultDateTimePickerOptions = { language: 'zh-CN', format: 'yyyy-mm-dd', autoclose: true, todayHighlight: true, forceParse: true, minView: 2, maxView: 5, todayBtn: true,};const needRemoveInputProps = ['onChange', 'value', 'className', 'inputClassName'];const splitDateTimePickerOptionsAndInputProps = (props) =&gt; { const propsKeyStartsWith = 'dateTime'; let options = { ...defaultDateTimePickerOptions, }; let inputProps = {}; for (let key in props) { if (key.startsWith(propsKeyStartsWith)) { options[key.substring(propsKeyStartsWith.length)] = props[key]; } else if (needRemoveInputProps.indexOf(key) == -1) { inputProps[key] = props[key]; } } return { options, inputProps };};@componentLoggerclass DateTimePicker extends React.PureComponent { static propTypes = {}; constructor(props) { super(props); this.state = { ...splitDateTimePickerOptionsAndInputProps(props), }; } resetDateTimePicker(options) { $(this.refs.pickerDiv) .datetimepicker(options) .on('changeDate', (event) =&gt; { if (this.refs.pickerInput.value != this.props.value) { this.props.onChange({ target: this.refs.pickerInput, stopPropagation: event.stopPropagation, preventDefault: event.preventDefault, }); } }); } componentDidMount() { this.resetDateTimePicker(this.state.options); this.refs.pickerInput.value = this.props.value; } componentWillReceiveProps(nextProps) { this.setState({ ...splitDateTimePickerOptionsAndInputProps(nextProps) }); if (nextProps.value != this.props.value) { this.refs.pickerInput.value = nextProps.value; } } componentDidUpdate(prevProps, prevState) { if (!_.isEqual(prevState.options, this.state.options)) { this.resetDateTimePicker(this.state.options); } } render() { return ( &lt;div className={classNames('date-time-picker input-group date', this.props.className)} ref='pickerDiv'&gt; &lt;input ref='pickerInput' type='text' readOnly className={classNames('form-control', this.props.inputClassName)} {...this.state.inputProps} /&gt; &lt;span className='input-group-addon'&gt; &lt;span className='glyphicon glyphicon-calendar'&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; ); } componentWillUnmount() { $(this.refs.pickerDiv).datetimepicker('remove'); }}export default DateTimePicker;//使用&lt;span className='toolbar-search '&gt; &lt;span className='toolbar-search-label'&gt;选择时间:&lt;/span&gt; &lt;DateTimePicker type='text' placeholder='请选择时间' {...dataValueBindHandler(this, 'searchParam', 'CompleteTime')} inputClassName='toolbar-search-input' /&gt;&lt;/span&gt;;","link":"/2017/08-22-react-component-with-jquery/"},{"title":"像 angular 一样使用 react 组件","text":"前言写过angularjs的应该对ng-if, ng-show, ng-repeat等内置指令比较熟悉, 在react里面一般都是用js来实现这些功能, 但是这种组件化(指令化)的书写方式比较简单易懂和便于维护, 比一个接一个的if,map,&amp;&amp;,||嵌套简洁得多, 所以可以自己实现几个指令, 方便使用. 需要更多的时候也可以自己再扩展. ng-ifng-if可以说是很简单的指令了, 当if条件为真时, 展示组件, 否则不展示. 123456789101112131415161718192021const NgCmd = ({ if: _if = true, children } = props) =&gt; { if (!_if || !children) return null; return children;};NgCmd.propTypes = { if: React.PropTypes.any,};//使用ReactDOM.render( &lt;div&gt; &lt;NgCmd if={true}&gt; &lt;div&gt;this is true&lt;/div&gt; &lt;span&gt;true&lt;/span&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;div&gt;this is false&lt;/div&gt; &lt;span&gt;false&lt;/span&gt; &lt;/NgCmd&gt; &lt;/div&gt;, document.querySelector('#container'),); 注意, 该指令在react16 以上版本可用, 因为render函数可以返回数组. 低版本不可以, 需要修改返回值. ng-showng-show和ng-hide还有ng-class可以放在一起说, 因为它们本质上都是改变元素的class. 在react里面不需要特殊的支持, 可以使用classnames插件, 比ng-class更方便. 具体使用方法可以参考文档. 12345&lt;div&gt; &lt;div className={classNames({ hide: this.state.hide })}&gt;ng-hide&lt;/div&gt; &lt;div className={classNames({ hide: !this.state.show })}&gt;ng-show&lt;/div&gt; &lt;div className={classNames({ class-one: this.state.needClassOne })}&gt;ng-class&lt;/div&gt;&lt;/div&gt;, ng-cmd为了提供控制式组件, 实现一个ng-cmd, 包括ng-if和ng-show的功能. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';const NgCmd = ({ if: _if = true, show = true, hide = false, children } = props) =&gt; { if (!_if || !children) return null; let classHideName = ''; if (!show || hide) { classHideName = 'hide'; } return React.Children.map(children, (child, index) =&gt; { if (_.isString(child) || _.isNumber(child)) { return classHideName ? null : child; } if (!React.isValidElement(child)) { throw `ng-cmd only has React Element`; } let childProps = child.props; let className = ''; if (child.props.className &amp;&amp; classHideName) { className = child.props.className + ' ' + classHideName; } else if (child.props.className || classHideName) { className = child.props.className || classHideName; } return React.cloneElement(child, { ...childProps, key: index, className: className, }); });};NgCmd.propTypes = { hide: P.any, show: P.any, if: P.any,};//使用const Test = () =&gt; { return ( &lt;div&gt; &lt;NgCmd show={false}&gt; &lt;div&gt;show - false&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;div&gt;show - true&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd hide={false}&gt; &lt;div&gt;hide - false&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd hide={true}&gt; &lt;div&gt;hide - true&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;div&gt;if - false&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;div&gt;if - true&lt;/div&gt; &lt;/NgCmd&gt; &lt;/div&gt; );}; 有个问题需要注意的是, 如果NgCmd组件的子元素是一个自定义组件, 那么需要自己接收props.className并使用到顶级节点上, 否则会造成show和hide失效. 顺便提供一个ngCmd装饰器, 用来装饰组件, 即可在组件中直接使用show,hide,if, 不需要使用NgCmd组件. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//NgCmd for Decorators and function Component -- function Component dont need NgCmdfunction ngCmd(arg) { if (_.isFunction(arg)) { const Wrapper = arg; return class WrapperComponent extends React.Component { render() { return ( &lt;NgCmd {...this.props}&gt; &lt;Wrapper {...this.props} /&gt; &lt;/NgCmd&gt; ); } }; } else if (_.isArray(arg)) { let i = 0; let args = []; if (arg.length == 0) { args = ['if', 'show', 'hide']; } else { ['if', 'show', 'hide'].forEach((value, index) =&gt; { if (arg.indexOf(value) &gt; -1) { i++; } }); if (i == 0) { throw 'need at least one ng-cmd'; } args = arg; } return (Wrapper) =&gt; { return class WrapperComponent extends React.Component { render() { let cmdsObj = {}; ['if', 'show', 'hide'].forEach((v, i) =&gt; { if (args.indexOf(v) &gt; -1 &amp;&amp; _.has(this.props, v)) { cmdsObj[v] = this.props[v]; } }); return ( &lt;NgCmd {...cmdsObj}&gt; &lt;Wrapper {...this.props} /&gt; &lt;/NgCmd&gt; ); } }; }; if (_.has(cmdsObj, 'if') &amp;&amp; cmdsObj['if'] == false) { return null; } }}const Test = () =&gt; { return ( &lt;div&gt; &lt;NgCmd show={false}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={false}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={false}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={false}&gt; &lt;Test5 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test5 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;Test4 if={true} /&gt; &lt;Test4 if={false} /&gt; &lt;Test4 show={true} /&gt; &lt;Test4 show={false} /&gt; &lt;Test4 hide={true} /&gt; &lt;Test4 hide={false} /&gt; &lt;Test5 if={true} /&gt; &lt;Test5 if={false} /&gt; &lt;Test5 show={true} /&gt; &lt;Test5 show={false} /&gt; &lt;Test5 hide={true} /&gt; &lt;Test5 hide={false} /&gt; &lt;Test6 if={true} /&gt; &lt;Test6 if={false} /&gt; &lt;Test6 show={true} /&gt; &lt;Test6 show={false} /&gt; &lt;Test6 hide={true} /&gt; &lt;Test6 hide={false} /&gt; &lt;/div&gt; );};const Test2 = () =&gt; { return 'Test2';};const Test3 = (props) =&gt; { return &lt;div&gt;Test3&lt;/div&gt;;};@ngCmdclass Test4 extends React.Component { render() { return &lt;div className={this.props.className}&gt;Test4-{JSON.stringify(this.props)}&lt;/div&gt;; }}@ngCmd(['hide', 'if'])class Test5 extends React.Component { render() { return &lt;div&gt;Test5-{JSON.stringify(this.props)}&lt;/div&gt;; }}const Test6 = ngCmd((props) =&gt; { return &lt;div className={props.className}&gt;Test6-{JSON.stringify(props)}&lt;/div&gt;;}); ng-switch另一个比较有用的控件为ng-switch, 否则在react中使用switch只能使用立即执行函数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var Test = (props) =&gt; { return (&lt;div className=&quot;test&quot;&gt; //不使用NgSwitch {(function(){ switch(props.value){ case '1':return &lt;div&gt;one&lt;/div&gt;; case '2':return &lt;div&gt;two&lt;/div&gt;; case '3':return &lt;div&gt;threee&lt;/div&gt;; default : return &lt;div&gt;default&lt;/div&gt;; } })()} //使用NgSwitch &lt;NgSwitch when={props} get={(v) =&gt; (v.a)}&gt; &lt;NgDefault&gt;default&lt;/NgDefault&gt; &lt;NgCase is=&quot;1&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/NgCase&gt; &lt;NgCase is=&quot;2&quot;&gt;2&lt;/NgCase&gt; &lt;NgCase is=&quot;3&quot;&gt;3&lt;/NgCase&gt; &lt;/NgSwitch&gt; &lt;/div&gt;)&lt;Test value=&quot;1&quot;/&gt;&lt;Test value=&quot;2&quot;/&gt;&lt;Test value=&quot;3&quot;/&gt;&lt;Test value=&quot;4&quot;/&gt;//NgSwitch.jsimport React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import Immutable from 'immutable';const NgSwitch = ({ when, get, children, } = props) =&gt; { if (_.isNil(when) || _.isNil(children)) { return null; } let child = null; let defaultChild = null; React.Children.forEach(children, function (element) { if (!React.isValidElement(element)) return; if (element.type != NgCase &amp;&amp; element.type != NgDefault) return; if (element.type == NgDefault &amp;&amp; !defaultChild) { defaultChild = element; return; } else if (element.type == NgDefault &amp;&amp; defaultChild) { throw 'ng-switch can not has two default' } if (child == null &amp;&amp; element.props.is == (_.isFunction(get) ? get(when) : when)) { child = element; } }); return child || defaultChild;};NgSwitch.propTypes = { when: P.any.isRequired, get: P.func,}const NgCase = ({ is, children } = props) =&gt; { if (!is) { return null; } return children;};NgCase.propTypes = { is: P.any.isRequired,}const NgDefault = ({ children, } = props) =&gt; { return children;};} 在NgSwitch组件中, 可以自定义获取函数get, 如果使用的是immutable, 只需要设置get={(v) =&gt; (v.get('value'))}即可. ng-repeatng-repeat作为angular里面的一大利器, 使得循环一个dom结构再也不是很麻烦的事情, 结合ng-if以及ng-class, 可以方便的定义重复元素. 这里也仿造ng-repeat实现一个循环组件, 而且不会有像ng-repeat造成性能不好的问题, 和原始的map写法相比性能可能还有提升(有提供测试 demo, 可以自行测试). 同时为了方便项目组使用, 兼容immutable数据结构和原生数据结构, 提供自定义key(track by), filter函数, sortBy函数. 内置提供$$index, $$isOdd, $$total等相关属性. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import Immutable from 'immutable';const NgFor = ({ for: _for, of: _of = 'item', filter = null, sortBy = null, trackBy = null, render } = props) =&gt; { if (!_for || !render) { return; } const _obj = {}; if (Immutable.isCollection(_for)) { if (filter) { _for = _for.filter(filter); } const _size = _for.count(); if (_size == 0) { return null; } return _for .sortBy((v) =&gt; v[sortBy]) .map((value, index) =&gt; { _obj[_of] = value; const key = Immutable.fromJS(value).get(trackBy) || index; var ele = render({ ..._obj, $$index: index, $$isEnd: index + 1 === _size, $$isStart: index === 0, $$isOdd: index % 2 != 0, $$isEven: index % 2 == 0, $$total: _size, $$key: key, key: key, }); //when you need High performance, you need set the 'key' props by yourself ?? not sure return ele.key ? ele : React.cloneElement(ele, { key }); }); } else { _for = _.filter(_for, filter); const _size = _.size(_for); if (_size == 0) { return null; } return _.map(_.sortBy(_for, sortBy), (value, index) =&gt; { _obj[_of] = value; const key = value[trackBy] || index; var ele = render({ ..._obj, $$index: index, $$isEnd: index + 1 === _size, $$isStart: index === 0, $$isOdd: index % 2 != 0, $$isEven: index % 2 == 0, $$total: _size, $$key: key, key: key, }); return ele.key ? ele : React.cloneElement(ele, { key }); }); }};NgFor.propTypes = { for: P.any.isRequired, of: P.string.isRequired, filter: P.func, sort: P.func, trackBy: P.string,};NgFor.defaultProps = { of: 'item',};var Test = (props) =&gt; { var start = [ { id: 'a1', value: 'av1' }, { id: 'a2', value: 'av2' }, { id: 'a3', value: 'av3' }, ]; var arrays = []; for (var i = 0; i &lt; 5000; i++) { //for (var i = 0; i &lt; 20000; i++) { arrays.push({ id: 'a1', value: 'av1', }); } var arraysIm = Immutable.fromJS(arrays); return ( &lt;div className='test'&gt; {console.log('NgFor no set self key')} {console.time('NgFor no set self key')} &lt;NgFor for={arrays} of='item' render={function (_props) { return ( &lt;div id={_props.item.id}&gt; {_props.item.value} &amp;nbsp;length: {arrays.length} &lt;/div&gt; ); }} &gt;&lt;/NgFor&gt; {console.timeEnd('NgFor no set self key')} {console.log('NgFor set self key')} {console.time('NgFor set self key')} &lt;NgFor for={arrays} of='item' render={function (_props) { return ( &lt;div id={_props.item.id} key={_props.key}&gt; {_props.item.value} &amp;nbsp;length: {arrays.length} &lt;/div&gt; ); }} &gt;&lt;/NgFor&gt; {console.timeEnd('NgFor set self key')} {console.log('NgFor Immutable set self key')} {console.time('NgFor Immutable set self key')} &lt;NgFor for={arraysIm} of='item' render={function (_props) { return ( &lt;div id={_props.item.get('id')} key={_props.key}&gt; {_props.item.get('value')} &amp;nbsp;length: {arraysIm.count()} &lt;/div&gt; ); }} &gt;&lt;/NgFor&gt; {console.timeEnd('NgFor Immutable set self key')} {console.log('js Map set self key')} {console.time('js Map set self key')} {arrays.map((value, index) =&gt; { return ( &lt;div id={value.id} key={index}&gt; {value.value} &amp;nbsp;length: {arrays.length} &lt;/div&gt; ); })} {console.timeEnd('js Map set self key')} &lt;/div&gt; );};export { Test };export default NgFor; 性能测试截图(5000):","link":"/2017/08-23-react-component-like-angular/"},{"title":"react 中的数据双向绑定","text":"在react中, 如果不使用双向绑定, 那么获取一个受控制的input的数据需要写一个onChange回调函数来获取输入值, 再通过setState来将value传入input做展示. 少量的输入框的情况下, 还可以使用这种方法, 但是如果在比较大和复杂的表单中, 这种写法就会觉得太麻烦了. 旧版本的valueLink在以前的版本中, 可以通过mixin:[LinkedStateMixin]这种方法来实现简易的双向绑定, 它的底层方法是react为input提供的valueLink属性, 可以通过传递一个含有value和requestChange属性的对象, 来实现value和onChange的同时绑定. 但是在react 15中, valueLink已经被标记为deprecated, 如果你继续使用, 会出现提示: Note: LinkedStateMixin is deprecated as of React v15. The recommendation is to explicitly set the value and change handler, instead of using LinkedStateMixin. 而在react 16这个版本中, valueLink已经正式消失了, 对此, react官方的说法是, No easy/messy 2-way data binding with modern React!, 不过这只是说说而已, 来看看新版本的双向绑定怎么实现比较好. 新版本使用当不使用双向绑定的时候, react的做法是为input提供value和onChange属性, 那么如果想简写时, ES6的扩展运算符...则提供了很大的方便性, 我们只需要返回一个含有value和onChange的对象即可. 1234567function twoway(){ return { value : 'value', onChange : function, }}&lt;input {...twoway()}/&gt; 这便是最基础的用法了, 那么基于此来扩展一下. 首先, value所在key肯定是需要作为参数传入的, 而读取和设置state的方法, 也是组件特有的. 那么我们需要直接把组件实例传入即可. 1234567891011function twoway(component, key) { return { value: component.state[key], onChange: (e) =&gt; { component.setState({ [key]: event.target.value, }); }, };}&lt;input {...twoway(this, 'testValue')} /&gt;; 加入path好了, 初步的双向绑定方法就完成了, 下一步来优化它. 首先, 不应该所有的value都是直接保存在state上, 可能是保存在state中某个对象上, 那么所在对象的深层path也应该作为参数传入, 而key是作为state的key传入. 123456789101112131415161718192021222324252627282930313233343536373839import _ from 'lodash';function twoway(component, key, path) { let hasPath = _.isArray(path) &amp;&amp; path.length &gt; 0; if (!hasPath) { return { value: component.state[key], onChange: (event) =&gt; { component.setState({ [key]: event.target.value, }); }, }; } else { return { value: _.get(component.state[key], path), onChange: (event) =&gt; { component.setState({ [key]: { ..._.set(component.state[key] || {}, path, event.target.value) }, }); }, }; }}class Test extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return ( &lt;div&gt; &lt;input {...twoway(this, 'testValue')} /&gt; &lt;input {...twoway(this, 'testValueObject', ['Lv1', 'Lv2'])} /&gt; &lt;div&gt;testValue : {this.state.testValue}&lt;/div&gt; &lt;div&gt;testValueObject : {JSON.stringify(this.state.testValueObject)}&lt;/div&gt; &lt;/div&gt; ); }} 加入immutable支持而我们推荐整个项目里面的对象尽量使用immutable结构, 达到优化性能和避免state对象深度拷贝的目的, 那么twoway方法也需要加入对immutable结构的支持. 顺便也加入对checkbox的支持. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import _ from 'lodash';import Immutable from 'immutable';function twoway(component, key, path) { if (!key) { throw 'dataValueBindHandler to bind state need one key'; } const bindFun = (event) =&gt; { const ele = event.target; const value = ele.type === 'checkbox' ? ele.checked : ele.value; const stateValue = component.state[key] || {}; if (Immutable.isCollection(stateValue)) { const setFuncName = _.isArray(path) ? 'setIn' : 'set'; component.setState({ [key]: path ? component.state[key][setFuncName](path, value) : value, }); } else { component.setState({ [key]: path ? { ..._.set(stateValue, path, value) } : value, }); } }; let value = ''; if (Immutable.isCollection(component.state[key])) { value = path ? component.state[key][_.isArray(path) ? 'getIn' : 'get'](path) : component.state[key]; } else { value = path ? _.get(component.state[key], path) : component.state[key]; } return { value: value, onChange: bindFun, };}class Test extends React.Component { constructor(props) { super(props); this.state = { testValue: '', testValueObject: { Lv1: { Lv2: 'val', }, }, testValueImmutableObject: Immutable.Map().setIn(['Lv1', 'Lv2'], 'valImmutable'), }; } render() { return ( &lt;div&gt; &lt;input {...twoway(this, 'testValue')} /&gt; &lt;input {...twoway(this, 'testValueObject', ['Lv1', 'Lv2'])} /&gt; &lt;input {...twoway(this, 'testValueImmutableObject', ['Lv1', 'Lv2'])} /&gt; &lt;div&gt;testValue : {this.state.testValue}&lt;/div&gt; &lt;div&gt;testValueObject : {JSON.stringify(this.state.testValueObject)}&lt;/div&gt; &lt;div&gt;testValueImmutableObject : {JSON.stringify(this.state.testValueImmutableObject)}&lt;/div&gt; &lt;/div&gt; ); }} 加入onChange方法缓存对于这个函数, 还可以再优化一下, 因为每次执行twoway方法, 都会生成一个新的bindFun函数, 如果你的input使用的是自定义组件, 则会因为改变props中onChange变化而不是value变化而执行render函数, 那么需要将onChange变成一个固定的函数, 不需要每次重新生成, 则不会因为变化onChange而不是value时触发子组件的render函数了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React from 'react';import _ from 'lodash';import Immutable from 'immutable';const dataValueBindHandler = (component, key, path) =&gt; { if (!key) { throw 'dataValueBindHandler to bind state need one key'; } let dataHandleBindMap = component.__dataHandleBindMap || Immutable.Map(); let mapKey = `key:${key}`; if (path) { mapKey += `::path:${_.isArray(path) ? path.join('__') : path}`; } let onChange = null; if (dataHandleBindMap.has(mapKey)) { onChange = dataHandleBindMap.get(mapKey); } else { const bindFun = (event) =&gt; { const ele = event.target; const value = ele.type === 'checkbox' ? ele.checked : ele.value; const stateValue = component.state[key] || {}; if (Immutable.isCollection(stateValue)) { const setFuncName = _.isArray(path) ? 'setIn' : 'set'; component.setState({ [key]: path ? component.state[key][setFuncName](path, value) : value, }); } else { component.setState({ [key]: path ? { ..._.set(stateValue, path, value) } : value, }); } }; component.__dataHandleBindMap = dataHandleBindMap.set(mapKey, bindFun); onChange = bindFun; } let value = ''; if (Immutable.isCollection(component.state[key])) { value = path ? component.state[key][_.isArray(path) ? 'getIn' : 'get'](path) : component.state[key]; } else { value = path ? _.get(component.state[key], path) : component.state[key]; } return { value: value, onChange: onChange, };};export default dataValueBindHandler;class Test extends React.Component { constructor(props) { super(props); this.state = { testValue: '', testValueObject: { Lv1: { Lv2: 'val', }, }, testValueImmutableObject: Immutable.Map().setIn(['Lv1', 'Lv2'], 'valImmutable'), }; } render() { return ( &lt;div&gt; &lt;input {...dataBindHandler(this, 'testValue')} /&gt; &lt;input {...dataBindHandler(this, 'testValueObject', ['Lv1', 'Lv2'])} /&gt; &lt;input {...dataBindHandler(this, 'testValueImmutableObject', ['Lv1', 'Lv2'])} /&gt; &lt;div&gt;testValue : {this.state.testValue}&lt;/div&gt; &lt;div&gt;testValueObject : {JSON.stringify(this.state.testValueObject)}&lt;/div&gt; &lt;div&gt;testValueImmutableObject : {JSON.stringify(this.state.testValueImmutableObject)}&lt;/div&gt; &lt;/div&gt; ); }}","link":"/2017/09-17-react-two-way-data-binding/"},{"title":"react 性能优化之函数绑定","text":"在react中创建组件的时候, 如果有用到回调方法传递到下级组件, 而在方法中需要使用this参数时候, 有两种方法可以使用, 一种是使用bind方法绑定this, 还一种是使用箭头函数绑定this. 一般推荐都是使用bind方法, 因为箭头函数在每次执行render方法时都会重新生成一次, 造成传入的props改变, 重新触发render. 123451.this.childChange = this.childChange.bind(this);&lt;Child onChange={this.childChange}/&gt;2.&lt;Child onChange={(event)=&gt;{this.childChange(event)}}/&gt; 在第 2 种写法中, 当Child组件是PureComponent时, 也会在每次父组件执行render之后执行render, 因为props.onChange属性改变了. 那么, 一般在需要传入回调函数时候, 都使用bind之后的函数就可以了, 但是在某些特殊情况下, 必须要使用箭头函数时, 如何优化呢. 1234567891011childChange(event, index){ ...;}&lt;NgFor for={arraysItem} of=&quot;item&quot; render={ function (_props) { return (&lt;Child onChange={(event)=&gt;{this.childChange(event, _props.$$index)} /&gt;) }}&gt;&lt;/NgFor&gt;{arrays.map((value, index) =&gt; { return (&lt;Child onChange={(event)=&gt;{this.childChange(event, index)} /&gt;)})} 当使用闭包传入值的时候, 即使执行bind后的方法, 也需要在里面使用箭头函数调用, 传入index值. 那么需要用到bind函数的args来优化.自定义一个bindOnce方法, 传入组件和要绑定的方法以及其他参数, 对方法进行bind和缓存. 123456789101112131415161718192021222324import Immutable from 'immutable';var __bindOnce = function (component, func, ...args) { if (!component.__bindFuncs) { component.__bindFuncs = Immutable.Map(); } let __bindFuncs = component.__bindFuncs; let argsMap = Immutable.fromJS(args); if (__bindFuncs.has(func)) { if (__bindFuncs.get(func).has(argsMap)) { return __bindFuncs.get(func).get(argsMap); } else { let bindFunc = func.bind(component, ...args); component.__bindFuncs = __bindFuncs.update(func, (v) =&gt; v.set(argsMap, bindFunc)); return bindFunc; } } else { let bindFunc = func.bind(component, ...args); component.__bindFuncs = __bindFuncs.set(func, Immutable.Map().set(argsMap, bindFunc)); return bindFunc; }};export default bindOnce; 这里使用了immutable的Map来作为缓存字典, 因为Map结构可以使用Object和function作为Key. 使用方法: 1234567891011childChange(index, event){ ...;}&lt;NgFor for={arraysItem} of=&quot;item&quot; render={ function (_props) { return (&lt;Child onChange={bindOnce(this, this.childChange, _props.$$index)} /&gt;) }}&gt;&lt;/NgFor&gt;{arrays.map((value, index) =&gt; { return (&lt;Child onChange={bindOnce(this, this.childChange, index)} /&gt;)})} 可以见到, 唯一需要改变的就是, 在childChange中, event参数的位置在最后, 这是因为onChange总会传入event参数, 而先bind的参数会出现在参数列表前面. 当使用了bindOnce之后, Child便不会因为props中onChange变化而重新render了.","link":"/2017/09-25-react-once-bind-function/"},{"title":"react 异步加载组件","text":"在angular中, 异步加载组件时, 需要加载完mod.js之后使用$provide来将mod注册到angular全局, 才能实现异步组件中指令的加载和识别. 而在react中, 组件原本就是js函数, 理论上比angular中异步加载组件简单得多. 然而复杂的地方在于与webpack的结合. 首先, 在ES6中, import是导入export模块的语法, import()可以用作动态导入模块, 但是webpack在使用import()时, 底层调用的是require, 所以需要在模块底下加上require的导出语法. 1234567const Demo = () =&gt; ( &lt;div&gt; &lt;span&gt;Demo!&lt;/span&gt; &lt;/div&gt;);module.exports = Demo; //这个是动态模块需要加上的export default Demo; 然后是, webpack对动态模块的支持性. 当直接在import()中给定url时, webpack会在编译时分析所加载文件, 并将其打包为单独的文件. 如果url为动态内容或者是从后台获取到的内容, 那么就会存在问题. 查webpack官方文档时, 可以看到它是支持动态模块的, 但是语法和例子都没写清楚. 不过后来在网上查资料时, 看到了Sean Larkin(webpack Maintainer)在知乎上的一个回答, 所以解决了这个问题. 1const getTemplate = (templateName, templatePath) =&gt; import(`../../../../project-template/pc/${templatePath)/js/common/${templateName}.html`) 简单理解就是, 当在webpack中使用动态导入时, 需要给定partial path, 这样webpack才能找到你所需的模块. 以上两个问题解决以后, 实现一个异步加载的组件就比较简单了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React from 'react';import { PropTypes as P } from 'prop-types';import Loading from './../loading';class AsyncComponent extends React.PureComponent { static propTypes = { src: P.string.isRequired, loadingStart: P.func, loadingEnd: P.func, }; static defaultProps = { loadingStart: () =&gt; {}, loadingEnd: () =&gt; {}, }; constructor(props) { super(props); if (!props.src) { throw 'AsyncComponent need src'; } this.state = { component: null, }; } getComponentFromFileAsync(src) { this.props.loadingStart(); import(`./../../_container/${src}.js`).then((v) =&gt; { if (!this._isMounted) return; this.props.loadingEnd(); this.setState({ component: v, }); }); } componentDidMount() { this._isMounted = true; this.getComponentFromFileAsync(this.props.src); } componentWillReceiveProps(nextProps, nextState) { if (nextProps.src != this.props.src) { this.getComponentFromFileAsync(nextProps.src); } } componentWillUnmount() { this._isMounted = false; } render() { let Com = this.state.component; if (!Com) { return &lt;Loading /&gt;; } else { return &lt;Com {...this.props} src={undefined} /&gt;; } }}export default AsyncComponent; 推荐配合router一起使用, 也可做动态配置的权限控制, 使用方法 : 12345678910111213&lt;Switch&gt; {this.state.routeList.map((item, index) =&gt; { if (item.get('to')) { return &lt;Redirect key={index} path={item.get('url')} exact={item.get('exact')} to={item.get('to')} /&gt;; } else if (item.get('src')) { return &lt;Route key={index} path={item.get('url')} exact={item.get('exact')} render={() =&gt; &lt;AsyncComponent src={item.get('src')} /&gt;} /&gt;; } else { return null; } })} &lt;Route exact path='/' render={() =&gt; '欢迎来到首页'} /&gt; &lt;Redirect path='*' to='/' /&gt;&lt;/Switch&gt;","link":"/2017/10-13-react-async-component/"},{"title":"react redux-form 使用","text":"react中的表单验证, 输入限制等功能并不完善, 好在有redux-form库来提供比较方便的复杂表单实现功能. 注册reducer1234567import { combineReducers } from 'redux-immutable';import { reducer as formReducer } from 'redux-form/immutable';let _reducer = {};_reducer['form'] = formReducer;const RootReducer = combineReducers(_reducer); 实现常用的带验证输入框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//TextField.jsimport React from 'react';import classNames from 'classnames';import { NgCmd, } from './../../_component';const TextField = ({ input, label, labelClassName, inputDivClassName, className, type, maxLength, row, meta: { touched, error, warning },}) =&gt; ( &lt;div className={classNames(className, 'has-feedback', { 'has-error': touched &amp;&amp; error, 'has-warning': touched &amp;&amp; !error &amp;&amp; warning, 'has-success': touched &amp;&amp; !error &amp;&amp; !warning, })}&gt; &lt;label className={classNames('control-label', labelClassName)}&gt;{label}&lt;/label&gt; &lt;div className={classNames(inputDivClassName, { 'hint--bottom-right hint-error': touched &amp;&amp; error, 'hint--bottom-right hint-warning': touched &amp;&amp; !error &amp;&amp; warning, })} aria-label={error || warning}&gt; &lt;NgCmd if={!row}&gt; &lt;input className=&quot;form-control&quot; type={type || 'text'} maxLength={maxLength} {...input} /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={!!row}&gt; &lt;textarea className=&quot;form-control&quot; row={row} maxLength={maxLength} {...input} /&gt; &lt;/NgCmd&gt; &lt;span className={classNames('glyphicon form-control-feedback', { 'glyphicon-remove': touched &amp;&amp; error, 'glyphicon-warning-sign': touched &amp;&amp; !error &amp;&amp; warning, 'glyphicon-ok': touched &amp;&amp; !error &amp;&amp; !warning, })} /&gt; &lt;/div&gt; &lt;/div&gt; )export default TextField;//DateTimePickerField.jsimport React from 'react';import classNames from 'classnames';import { DateTimePicker, } from './../../_component';const DateTimePickerField = ({ input, label, labelClassName, inputDivClassName, className, meta: { touched, error, warning }, ...rest, }) =&gt; ( &lt;div className={classNames(className, 'has-feedback date-time-picker', { 'has-error': touched &amp;&amp; error, 'has-warning': touched &amp;&amp; !error &amp;&amp; warning, 'has-success': touched &amp;&amp; !error &amp;&amp; !warning, })}&gt; &lt;label className={classNames('control-label', labelClassName)}&gt;{label}&lt;/label&gt; &lt;div className={classNames(inputDivClassName, { 'hint--bottom-right hint-error': touched &amp;&amp; error, 'hint--bottom-right hint-warning': touched &amp;&amp; !error &amp;&amp; warning, })} aria-label={error || warning}&gt; &lt;DateTimePicker {...input} {...rest} /&gt; &lt;span className={classNames('glyphicon form-control-feedback', { 'glyphicon-remove': touched &amp;&amp; error, 'glyphicon-warning-sign': touched &amp;&amp; !error &amp;&amp; warning, 'glyphicon-ok': touched &amp;&amp; !error &amp;&amp; !warning, })} /&gt; &lt;/div&gt; &lt;/div&gt; )export default DateTimePickerField; 定义Form组件内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const ImmutableForm = reduxForm({ form: personToDoItemFormName,})((props) =&gt; { const { handleSubmit, pristine, reset, submitting, submit } = props; return ( &lt;form onSubmit={handleSubmit} className='form-horizontal'&gt; &lt;div className='form-group'&gt; &lt;Field name='ItemName' type='text' component={TextField} label='事项名称' maxLength='50' validate={validateHelper({ required: true, tips: '事项名称必填', validates: 'validName' })} warn={validateHelper({ minLength: 5, tips: '建议名称不少于5个字符' })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;Field name='ItemContent' row='3' type='text' component={TextField} label='事项内容' maxLength='500' validate={validateHelper({ required: true, tips: '事项内容必填', maxLength: 500 })} warn={validateHelper({ minLength: 5, tips: '建议内容不少于5个字符' })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;Field name='ItemRemark' row='3' type='text' component={TextField} label='备注' maxLength='500' validate={validateHelper({ tips: '备注不能超过500字符', maxLength: 500 })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;Field name='CompleteTime' component={DateTimePickerField} label='完成时间' dateTimeformat={props.dateTimeformat} dateTimestartDate={new Date().Format('yyyy-MM-dd hh:mm')} dateTimeminView='0' validate={validateHelper({ tips: '必须为日期格式', regex: /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$/ })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;/form&gt; );}); 使用Form组件和表单事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const mapDispatchToProps = (dispatch) =&gt; ({ fn: { openNewWindow: (windowParam) =&gt; { dispatch(PopupWindowListAction.openNewWindow(windowParam)); }, alertMsg: (windowParam) =&gt; { dispatch(PopupWindowListAction.alertMsg(windowParam)); }, closeWindow: (windowId) =&gt; { dispatch(PopupWindowListAction.closeWindow({ windowId })); }, getInitItemInfo: () =&gt; { dispatch(Action.getInitItemInfo()); }, getItemInfo: (id) =&gt; { dispatch(Action.getItemInfo(id)); }, initialize: (values, keepDirty) =&gt; { dispatch(initialize(formName, values, keepDirty)); }, submit: () =&gt; { dispatch(submit(formName)); }, touch: () =&gt; { dispatch(touch(formName)); }, saveOrUpdateItem: (info) =&gt; { dispatch(Action.saveOrUpdateItem(info)); }, },});clickSave() { this.props.fn.touch(); if (this.props.formState.get('syncErrors')) { let err = ''; _.forIn(this.props.formState.get('syncErrors'), function (value, key) { err += value + '&lt;br /&gt;'; }); this.props.fn.alertMsg(`表单未填写完成:&lt;br /&gt;${err}`); } else { this.props.fn.saveOrUpdateItem(this.props.formState.get('values').toJS()); }}//render&lt;span className=&quot;btn btn-success btn-text&quot; onClick={this.clickSave}&gt;保存&lt;/span&gt;&lt;ImmutableForm /&gt; 附validateHelpervalidateHelper是自己实现的一个简单的验证生成器, 支持缓存验证器, 多种内置验证器, 多个验证器, 自定义错误提示, 自定义正则验证即提示等功能. 具体使用方法可以看上面的例子. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import Immutable from 'immutable';import _ from 'lodash';let validateHelpers = Immutable.Map();const defaultValidates = { validCode: { test: /^[a-zA-Z_][a-zA-Z0-9._-]{1,49}$/i, tips: `格式应该为code`, }, validName: { test: (v) =&gt; v.length &gt;= 2 &amp;&amp; v.length &lt;= 50, tips: `格式应该为name`, }, validMoney: { test: /(^[1-9][0-9]{0,5}(\\.[0-9]{1,4})?$)|(^(0){1}$)|(^[0-9]\\.[0-9]([0-9]){0,3}$)/i, tips: `格式应该为money`, },};function validateHelper(options = {}) { const { required, maxLength, minLength, regex, tips, validates } = options; const key = Immutable.fromJS({ required, maxLength, minLength, regex, tips, validates, }); if (validateHelpers.has(key)) { return validateHelpers.get(key); } else { const fun = function (value, allValues, props, name) { const valueStr = _.toString(value); if (required &amp;&amp; _.isEmpty(valueStr)) { let defaultTips = '该字段必填'; return tips ? (_.isString(tips) ? tips : tips['required'] || tips.default || defaultTips) : defaultTips; } if (minLength &amp;&amp; valueStr.length &lt; minLength) { let defaultTips = `该字段最小长度为${minLength}`; return tips ? (_.isString(tips) ? tips : tips['minLength'] || tips.default || defaultTips) : defaultTips; } if (maxLength &amp;&amp; valueStr.length &gt; maxLength) { let defaultTips = `该字段最大长度为${maxLength}`; return tips ? (_.isString(tips) ? tips : tips['maxLength'] || tips.default || defaultTips) : defaultTips; } if (regex &amp;&amp; !regex.test(value)) { let defaultTips = `该字段格式不对`; return tips ? (_.isString(tips) ? tips : tips['regex'] || tips.default || defaultTips) : defaultTips; } let validatesArr = _.isString(validates) ? [validates] : validates || []; for (let i = 0; i &lt; validatesArr.length; i++) { var valid = defaultValidates[validatesArr[i]]; if (valid) { if (_.isFunction(valid.test) &amp;&amp; !valid.test(valueStr)) { return tips ? (_.isString(tips) ? tips : tips.default || valid.tips) : valid.tips; } else if (_.isFunction(valid.test.test) &amp;&amp; !valid.test.test(valueStr)) { return tips ? (_.isString(tips) ? tips : tips.default || valid.tips) : valid.tips; } } else { throw `${validatesArr[i]}未找到`; } } }; validateHelpers = validateHelpers.set(key, fun); return fun; }}export default validateHelper;","link":"/2017/10-23-react-redux-form/"},{"title":"react redux-form 中异步提交文件","text":"在之前看redux-form的时候, 只实现了两种比较简单的Field组件, TextField和DateTimeField, 现在来看看一个麻烦一点的FileField. 文件上传是比较常用的功能, 尽量做到简单易用的组件化形式为好, 首先定义FileField组件. 1234567891011121314151617181920212223242526272829303132333435363738394041class FileField extends React.PureComponent { static propTypes = {}; render() { let { input, label, inputFile, labelClassName, inputDivClassName, className, inputClassName, meta: { touched, error, warning }, } = this.props; return ( &lt;div className={classNames(className, 'has-feedback', { 'has-error': touched &amp;&amp; error, 'has-warning': touched &amp;&amp; !error &amp;&amp; warning, 'has-success': touched &amp;&amp; !error &amp;&amp; !warning, })} &gt; &lt;label className={classNames('control-label', labelClassName)}&gt;{label}&lt;/label&gt; &lt;div className={classNames(inputDivClassName, { 'hint--bottom-right hint-error': touched &amp;&amp; error, 'hint--bottom-right hint-warning': touched &amp;&amp; !error &amp;&amp; warning, })} aria-label={error || warning} &gt; &lt;div className='input-group cursor-p'&gt; &lt;input type='text' readOnly className={classNames('form-control cursor-p', inputClassName)} {...input} /&gt; &lt;span className='input-group-addon'&gt; &lt;span className='glyphicon glyphicon-file'&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;input ref='selectFileInput' type='file' className='hide' {...inputFile} /&gt; &lt;/div&gt; ); }} 然后给组件加入点击事件和触发打开弹窗的事件. 123456789101112131415161718192021222324252627282930313233&lt;div className=&quot;input-group cursor-p&quot; onClick={this.clickOpenSelectFileWindow}&gt;&lt;input ref=&quot;selectFileInput&quot; type=&quot;file&quot; className=&quot;hide&quot; onChange={this.clickSelectFileChange} {...inputFile} /&gt;const mapDispatchToProps = (dispatch) =&gt; ({ fn: { change: (form, field, value) =&gt; { dispatch(change(form, field, value)); }, },});@connect(null, mapDispatchToProps)class FileField extends React.PureComponent { constructor(props) { super(props); this.state = {}; this.clickOpenSelectFileWindow = this.clickOpenSelectFileWindow.bind(this); this.clickSelectFileChange = this.clickSelectFileChange.bind(this); } clickOpenSelectFileWindow(event) { this.refs.selectFileInput.click(); if (event) { event.preventDefault(); event.stopPropagation(); } } clickSelectFileChange(event) { let fileName = event.target.files.length &gt; 0 ? event.target.files[0].name : ''; this.props.fn.change(this.props.formName, this.props.input.name, fileName); this.props.fn.change(this.props.formName, this.props.input.name + 'Files', event.target.files); }}//使用&lt;Field name=&quot;SelectFile&quot; component={FileField} label=&quot;选择文件&quot; labelClassName=&quot;col-sm-2&quot; inputDivClassName=&quot;col-sm-10&quot; formName={toDoItemFormName} /&gt; 这样基本实现了点击输入框, 会弹出选择文件, 选择完成以后会显示选择文件的名字, 而选择到的文件保存在redux-form的state中同名field加后缀Files下. 在提交时只需要提取相应文件传入到后台即可. 这里使用jquery-form来实现异步提交文件. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var postFile = function (data, files) { var $form = $('&lt;form&gt;&lt;input name=&quot;CommandName&quot; value=&quot;' + data.CommandName + '&quot;/&gt;&lt;/form&gt;'); var $newInput = $('&lt;input name=&quot;myFile&quot; type=&quot;file&quot;/&gt;'); $newInput[0].files = files; $form.append($newInput); var params = _.isString(data.params) ? data.params : JSON.stringify(data.params); $form.append($('&lt;input type=&quot;text&quot; name=&quot;data&quot; value=&quot;' + encodeURIComponent(params) + '&quot;/&gt;')); var promise = new Promise((resolve, reject) =&gt; { $form.ajaxSubmit({ url: url, type: &quot;POST&quot;, dataType: &quot;json&quot;, success: function (resultValue) { let action = resolveResultValue(resultValue); if (action.action === ActionType.SUCCESS) { return resolve(resultValue); } else { return reject(action); } }, error: function (resultValue) { return reject({ action: ActionType.NETWORK_ERROR, payload: resultValue.responseText }); }, }); }).then((resultValue) =&gt; { ...//log return resultValue.returnValue; }).catch(({ action, payload }) =&gt; { ...//异常处理 return Promise.reject(payload); }) return promise;}//service.jssaveOrUpdateItemWithFile: (info) =&gt; { return commonAjaxService.postFile({ CommandName: 'Service$SaveOrUpdateInfoWithFiles', params: info, }, info.SelectFileFiles);},//action.jsstatic saveOrUpdateItemWithFile(info) { return (dipatch, getState) =&gt; { let action = { type: ActionType.SAVE_ITEM_START, payload: null, }; dipatch(action); dipatch(startSubmit(toDoItemFormName)); return Service.saveOrUpdateItemWithFile(info).then( (resultValue) =&gt; { dipatch(setSubmitSucceeded(toDoItemFormName)); let action = { type: ActionType.SAVE_ITEM_END, payload: resultValue, }; dipatch(action); }, (error) =&gt; { dipatch(setSubmitFailed(toDoItemFormName)); let action = { type: ActionType.SAVE_ITEM_END, payload: null, }; dipatch(action); } ); };} 还有个情况是, 想在别的地方触发该文件选择框. 那么提供一个传入函数, 在函数返回当前组件实例(类似 ref), 在需要触发的时候执行ref.clickOpenSelectFileWindow(event)即可. 1234567891011121314151617//file-field.jsstatic propTypes = { componentRef: P.func.isRequired,}componentDidMount() { if (this.props.componentRef) { this.props.componentRef(this); }}//使用bindInputFileRef(ref){ this.inputFileRef = ref;}targetOpenFileSelectWindow(event){ this.inputFileRef.clickOpenSelectFileWindow(event);}&lt;Field componentRef={bindInputFileRef} name=&quot;SelectFile&quot; component={FileField} label=&quot;选择文件&quot; labelClassName=&quot;col-sm-2&quot; inputDivClassName=&quot;col-sm-10&quot; formName={personToDoItemFormName} /&gt;","link":"/2017/10-29-react-redux-form-post-file/"},{"title":"JavaScript 填坑之 flow 和 WebAssembly 技术","text":"js的坑作为一门只用了十天时间赶工出来的动态语言, JavaScript已经做得很好了, 但是有些不得不解决的问题也逐渐暴露出来了. 下面是一些坑列表. 运行性能, 由google的v8引擎解决. 类型继承, 由ES6语法糖和phototype对象构成原型链解决. 模块化, 由ES6的import和exports实现. 全局变量(window), 社区方案使用Global统一替换. 回调函数机制, 由promise解决. 动态语言导致的大型项目类型检查, 使用React.PropTypes和flowjs, 或者使用TypeScript. v8引擎编译性能, WebAssembly技术. flowjsflowjs是Facebook为了大型js项目拥有类型检查而发明的一个库. 使那些需要类型检查的项目不需要使用重量级的TypeScript的另一个解决方案. 基本作用是通过可选的类型声明, 在写代码时自动检查类型是否匹配. 语法也不会很麻烦, 基本都是在变量后面加上:type来声明. 但是我看了一圈, 好像没有解构赋值时的类型语法, 这样就有点麻烦了. 1234567891011121314/* @flow */function foo(x: ?number): string { if (x) { return x; } return &quot;default string&quot;;}//报错:5: return x; ^ number. This type is incompatible with the expected return type of3: function foo(x: ?number): string { ^ string v8引擎在说WebAssembly之前, 必须看看v8引擎的原理和不足. chrome现在这么高的市场占有率有一半都是靠着v8引擎的速度取得的. v8引擎底层由C++实现, 可以作为一个独立模块, 被任何C++应用引用. 如Node.js框架就是基于v8引擎. v8基本功能也是编译, 执行js代码, 管理内存, 负责垃圾回收, 与宿主语言交互等功能. 而这种运行时编译的语言都存在一个问题, 即类型改变. v8中编译技术为JIT(Just in time compiling), JIT基于运行期分析编译, 而JavaScript是一个没有类型的语言, 于是大部分时间, JIT编译器其实是在猜测JavaScript中的类型, 如开始一个函数执行的是add(1,1), 那么JIT会将它编译成add(int a,int b)来执行, 并保存, 但如果下次调用add('a','b'), 那么JIT则需要重新编译一遍. 在js这种动态类型的情况下, 一个函数会发生很多次编译, 重新编译开销又非常大, 这便是v8或者说js引擎无法避免的问题. Google也发明过声明, 认为js是一门天生残疾的语言, 然后就不再继续发力v8虚拟机了. v8其实已经事实上代表了js能达到的运行时性能顶峰, 而Google也认为基于这种动态类型无法再继续提升虚拟机性能了. asm.jsasm是mozilla提出的一个解决方案, 和js语法相同, 只是在火狐浏览器中会特别解析语法, 直接编译成机器语言, 极大的加快执行速度. 但是存在的一个问题是浏览器支持率并不高, 而且也不是官方解决方案. WebAssembly这时候, 几大浏览器厂家(Mozilla, Google, Microsoft, Apple)觉得这种思路还是可以的, 那么就升级一下, 变为WebAssembly技术. 这种技术基本等于浏览器执行原生代码. 和Java调用JNI一样的速度. start需要安装的内容有点多, 参考官方文档和所需工具. Emscripten Binaryen WABT (WebAssembly Binary Toolkit) 在非开发版的浏览器中, Firefox对WebAssembly支持比较好, 在浏览器控制台中粘贴以下代码, 如果可以运行而且不报错, 说明支持WebAssembly. 1234567891011121314151617181920WebAssembly.compile(new Uint8Array(` 00 61 73 6d 01 00 00 00 01 0c 02 60 02 7f 7f 01 7f 60 01 7f 01 7f 03 03 02 00 01 07 10 02 03 61 64 64 00 00 06 73 71 75 61 72 65 00 01 0a 13 02 08 00 20 00 20 01 6a 0f 0b 08 00 20 00 20 00 6c 0f 0b`.trim().split(/[\\s\\r\\n]+/g).map(str =&gt; parseInt(str, 16)))).then(module =&gt; { const instance = new WebAssembly.Instance(module) const { add, square } = instance.exports console.log('2 + 4 =', add(2, 4)) console.log('3^2 =', square(3)) console.log('(2 + 5)^2 =', square(add(2 + 5)))})//运行结果Promise { &lt;state&gt;: &quot;pending&quot; }2 + 4 = 63^2 = 9(2 + 5)^2 = 49 WebAssembly有明确的数据类型, 上面函数运行时传入参数应该为int 32类型, 不过如果传其他值会被动态转换, 所以add('2',3) = 5, add('2',{a:1}) = 2. 但是不推荐这样使用, 因为具体会转换成什么不能确定, 通常是0. 编译C/C++到WebAssembly使用WebAssembly技术, 肯定不能直接写二进制代码, 否则为什么要用js. WebAssembly一般都是由其他语言编译过来, 如C/C++等. 网上有个在线工具可以查看WasmExplorer, 生成的wast文件可以转换成wasm文件并下载下来. 先写一段C代码, 然后执行emcc demo.c -Os -s WASM=1 -s SIDE_MODULE=1 -o demo.wasm, 即可生成wasm文件. 执行wasm文件执行wasm目前只有一种方法, 即通过javascript. 官网文档里也有提供初略的例子. 123456789101112131415161718192021222324252627//demo.cint addThree(int a, int b, int c){ return a + b + c;}//index.htmlfunction loadWebAssembly(filename, imports = {}) { return fetch(filename) .then(response =&gt; response.arrayBuffer()) .then(buffer =&gt; WebAssembly.compile(buffer)) .then(module =&gt; { imports.env = imports.env || {} Object.assign(imports.env, { memoryBase: 0, tableBase: 0, memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }), table: new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }) }) return new WebAssembly.Instance(module, imports) })}loadWebAssembly('/demo.wasm') .then(instance =&gt; { const addThree = instance.exports._addThree console.log('1 + 2 + 3 =', addThree(1, 2, 3)) }) asm.js编译成WebAssemblyasm.js既然是带类型的js, 那么也可以生成WebAssembly文件. 官方有提供工具Binaryen和WABT (WebAssembly Binary Toolkit). 流程基本是由js生成wast文件, 再转换成wasm文件. WebAssembly调用JavaScript目前来说, 调用方法还是比较麻烦的, 需要将调用的函数通过imports参数传入模块中, 而且需要在wast文件中, 添加import和调用call方法才可以执行. 期待以后简单点的写法互相调用, 那么就可以实现任何语言来写js代码了, 而且运行速度将大大加快.","link":"/2017/11-16-flowjs-and-webassembly/"},{"title":"量子计算原理入门","text":"最近 IBM 出了一款 50bit 的量子计算机. 于是好奇的去学了下量子计算原理. 在经典计算机中, 用高电平表示1, 低电平表示0, 使用与, 或, 非三种门来实现对二进制位的基本操作, 比如计算1+1等. 这样的计算结果能保证准确可靠, 不过由于电流是’单线程’的, 那么在多次计算的时候, 便只能不停的循环计算. 比如需要计算1+1, 再计算2+2, 计算机只能先计算出一个结果, 再去计算另一个. 在量子计算机中, 这一切都不同了. 首先量子计算机在运行时没有准确的1和0状态. 就像’薛定谔的猫’一样, 只有在观测的时候才能准确的知道该量子状态是1还是0. 那么使用量子计算机的时候, 便可以假设所有位都是1和0的混合状态. 如果对某一位进行操作, 那么会同时对1和0两种状态进行操作, 生成两种结果, 但是该结果在观测的时候是随机的由1或0生成的结果, 各自比例为50%. 如果对多位进行同时操作, 那么会对它们都造成影响, 生成的结果有2^n个, 观测时候结果为某一位, 概率为1/2^n. 到这一步了以后可能就觉得量子计算不就是坑爹的嘛, 全凭计算出的运气随机观测结果, 结果到底是不是对的也不知道, 就如进行1+1, 可能的结果为: 0,1,1,2. 这时候算法大神们就出场了. Grover算法为一个对数据库进行随机搜索的量子算法. 在传统计算机和数据库中, 如果需要根据某个条件查找一条数据(非主键和索引)时, 需要从头到尾一条条数据循环查找, 这样的计算复杂度为O(N). 而在量子计算机中, 可以将所有数据导入到量子比特中, 只需要占用log2(N)个量子比特, 然后同时对该条件求值, 那么会生成N个计算结果, 而且必有 1 个结果为正确结果, 但是每个结果发生的概率均为1/N. Grover算法思想是, 同时计算出这么多结果以后, 先不要去读取结果, 即不’观测’, 先通过量子操作, 增加正确结果发生的概率. 在一系列复杂的量子操作以后, 该概率会增加一点, 在进行π * √N / 4次操作以后, 要找到的那个数据的发生概率会达到最大, 最大值为1 - 1/2^N. 这时候再去读取数据, 就会以极大的概率读取到正确的数据. 该搜索算法在量子计算机中, 可以将普通搜索的O(N)复杂度变为O(√N), 但是不足之处在于成功读取正确数据的概率永远都不是100%, 所以并不能算完美. 其他使用量子计算机的算法原理也基本类似, 所以都不可能达到完美的结果. 那么量子计算的应用领域也比较清晰了, 适合大量并行任务进行的场景, 如’猜密码’等. 而且需要特殊设计算法, 用于对所有结果进行计算而且选出正确结果的特殊算法. 参考:Grover 算法实现","link":"/2017/12-25-quantum-computing/"},{"title":"微信跳一跳自动辅助","text":"最近微信跳一跳在元旦一周火了起来, 刚玩的时候能艰难的跳到120+分, 看了网上的站立加分能跳到280+. 使用GGuardian让每次踩中心能加32分能跳到接近1000, 然而每次重开太累了, 于是抽晚上和周末写了个自动跳. 目前最高分有4000+, 不过是因为要玩手机而手动停止, 并不是算法问题. 想直接使用的看这里 思路 手机截图发送到电脑 电脑读取图片像素, 分析图片, 得到跳跃距离 根据跳跃距离和计算函数得出按压时间 发送按压时间到手机长按 -&gt; 跳! 再次截图, 并循环 手机截图还好使用的是android, 可以直接使用adb shell进行截图, 并发送到电脑. 百度一下可以得到以下几个命令. 1234//调用截图, 并将截图保存到/sdcard/screenshot.pngadb shell /system/bin/screencap -p /sdcard/screenshot.png//将截图从手机复制到电脑目录adb pull /sdcard/screenshot.png d:/screenshot.png 然后再带一个删除图片的linux命令, 免得截图太多浪费内存空间. 1adb shell rm /sdcard/screenshot.png 按压命令顺便查了一下发送输入事件到手机的命令, 也挺简单的. 1234//点击x,y坐标adb shell input tap x y//使用n毫秒从(x1,y1)滑动到(x2,y2), 模拟长按事件adb shell input swipe 500 500 501 501 2000 测试了一下, 发现一般距离按个300ms-400ms, 基本都能跳到. 算测试成功, 进行下一步. 开始帮助类库首先还是使用.Net + C#, 毕竟window平台下最好用的语言. 图片的读取和写入还是使用之前读取支付宝 AR 红包时候用的Byte[]和System.Runtime.InteropServices.Marshal, 性能远远优于.Net自带的图片像素颜色读取写入. 方法也类似之前的方法, 只是数组改成二维数组了, 方便一些, 由于有半透明图片的读取, 所以还添加了一个读取RGBA值的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public static void GetRGB(this Bitmap image, int startX, int startY, int w, int h, int[][] rgbArray){ const int PixelWidth = 3; const PixelFormat PixelFormat = PixelFormat.Format24bppRgb; // En garde! if (image == null) throw new ArgumentNullException(&quot;image&quot;); if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;); if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;); if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;); if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;); if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;); BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.ReadOnly, PixelFormat); try { byte[] pixelData = new Byte[data.Stride]; for (int i = 0; i &lt; h; i++) { rgbArray[i] = new int[w]; Marshal.Copy(data.Scan0 + (i * data.Stride), pixelData, 0, data.Stride); for (int j = 0; j &lt; w; j++) { // PixelFormat.Format32bppRgb means the data is stored // in memory as BGR. We want RGB, so we must do some // bit-shuffling. rgbArray[i][j] = (pixelData[j * PixelWidth + 2] &lt;&lt; 16) + // R (pixelData[j * PixelWidth + 1] &lt;&lt; 8) + // G pixelData[j * PixelWidth]; // B } } } finally { image.UnlockBits(data); }}public static void GetRGBA(this Bitmap image, int startX, int startY, int w, int h, long[][] rgbArray){ const int PixelWidth = 4; const PixelFormat PixelFormat = PixelFormat.Format32bppArgb; // En garde! if (image == null) throw new ArgumentNullException(&quot;image&quot;); if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;); if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;); if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;); if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;); if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;); BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.ReadOnly, PixelFormat); try { byte[] pixelData = new Byte[data.Stride]; for (int i = 0; i &lt; h; i++) { rgbArray[i] = new long[w]; Marshal.Copy(data.Scan0 + (i * data.Stride), pixelData, 0, data.Stride); for (int j = 0; j &lt; w; j++) { // PixelFormat.Format32bppARgb means the data is stored // in memory as BGRA. We want ARGB, so we must do some // bit-shuffling. rgbArray[i][j] = (((long)pixelData[j * PixelWidth + 3]) &lt;&lt; 24) + // A (pixelData[j * PixelWidth + 2] &lt;&lt; 16) + // R (pixelData[j * PixelWidth + 1] &lt;&lt; 8) + // G pixelData[j * PixelWidth]; // B } } } finally { image.UnlockBits(data); }}public static void SetRGB(this Bitmap image, int startX, int startY, int w, int h, int[][] rgbArray){ const int PixelWidth = 3; const PixelFormat PixelFormat = PixelFormat.Format24bppRgb; // En garde! if (image == null) throw new ArgumentNullException(&quot;image&quot;); if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;); if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;); if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;); if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;); if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;); BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.WriteOnly, PixelFormat); try { int dst_bytes = data.Stride * h; byte[] dstValues = new byte[dst_bytes]; IntPtr dstPtr = data.Scan0; Marshal.Copy(dstPtr, dstValues, 0, dst_bytes); int position = 0; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { position = (i * data.Stride) + j * PixelWidth; dstValues[position + 0] = (byte)(rgbArray[i][j]); dstValues[position + 1] = (byte)(rgbArray[i][j] &gt;&gt; 8); dstValues[position + 2] = (byte)(rgbArray[i][j] &gt;&gt; 16); } } Marshal.Copy(dstValues, 0, dstPtr, dst_bytes); } finally { image.UnlockBits(data); }} 开始的想法是, 从左上往右下扫描图片, 当碰到顶点的时候, 就能确定该顶点是目标物体, 然后根据顶点颜色找到整个目标面, 计算下平均坐标, 即可得到目标点.而自己的坐标确认方法, 看了一下好像自己的颜色不会变化, 那么就去PS里面, 把自己的棋子单独截出来, 当作Res资源图片, 在扫描时候碰见自己棋子颜色的时候, 就去和资源图片比对, 如果相关像素点颜色都一样, 那么就可以确定该点为自己的棋子, 再根据起点坐标和资源图片计算偏移, 即可得到自己的准确坐标. 那么就开始干活. 首先定义一个结构struct记录点的颜色, 为什么不是class而是struct呢, 因为性能好一些, 而且不会有引用值类型传错的可能. .Net还有个好处就是和C一样, 能重载+, ‘-‘, ‘*‘, ‘/‘, ‘==’这种运算符, 这样算法写起来也简单. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public struct RGB{ public static char[] RGBNAME = new char[] { 'A', 'R', 'G', 'B' }; public RGB(long color, bool hasAlpha = false) { //this.R = color &gt;&gt; 16; //this.G = (color &amp; 65280) &gt;&gt; 8; //this.B = (color &amp; 255); this.A = hasAlpha ? (byte)(color &gt;&gt; 24) : 255; this.R = (byte)(color &gt;&gt; 16); this.G = (byte)(color &gt;&gt; 8); this.B = (byte)(color); } public static RGB FromInt(long color, bool hasAlpha = false) { return new RGB(color, hasAlpha); } public int ToInt() { return (this.R &lt;&lt; 16) + (this.G &lt;&lt; 8) + this.B; } public long ToLong(bool hasAlpha = false) { return (hasAlpha ? ((long)this.A) &lt;&lt; 24 : 0) + (this.R &lt;&lt; 16) + (this.G &lt;&lt; 8) + this.B; } public RGB(int r, int g, int b) { this.R = r; this.G = g; this.B = b; this.A = 255; } public RGB(int r, int g, int b, int a) { this.R = r; this.G = g; this.B = b; this.A = a; } public int Get(char key) { if (key &gt; 90) { key = (char)(key - 32); } switch (key) { case 'A': return this.A; case 'R': return this.R; case 'G': return this.G; case 'B': return this.B; } throw new ArgumentOutOfRangeException(&quot;字符不对&quot;); } public static RGB operator +(RGB color1, RGB color2) { return new RGB( color1.R + color2.R, color1.G + color2.G, color1.B + color2.B ); } public static RGB operator -(RGB color1, RGB color2) { return new RGB( color1.R - color2.R, color1.G - color2.G, color1.B - color2.B ); } public static RGB operator *(RGB color, int m) { return new RGB( color.R * m, color.G * m, color.B * m ); } public static RGB operator /(RGB color, int m) { return new RGB( color.R / m, color.G / m, color.B / m ); } public static RGB operator ~(RGB color) { return new RGB( 255 - color.R, 255 - color.G, 255 - color.B ); } public static bool operator ==(RGB color1, RGB color2) { return color1.A == color2.A &amp;&amp; color1.R == color2.R &amp;&amp; color1.G == color2.G &amp;&amp; color1.B == color2.B; } public static bool operator !=(RGB color1, RGB color2) { return !(color1 == color2); } public int R; public int G; public int B; public int A; public override string ToString() { return string.Format(&quot;R:{0},G:{1},B:{2},A:{3}&quot;, this.R, this.G, this.B, this.A); } public override bool Equals(object obj) { if (obj != null &amp;&amp; obj is RGB) { return this == (RGB)obj; } return base.Equals(obj); } public override int GetHashCode() { return this.ToLong(true).GetHashCode(); }} 有这个struct来帮助将颜色和bitmap里面存的int进行互相转换和计算以后, 就可以开始正式做图片识别相关的了, 目前还是使用的传统算法实现图片识别, 而不是网上比较多的人工智能Tensorflow + 训练集来识别图片. 两种算法各有优劣, 传统算法优势是意义明确, 可以清楚的知道代码是如何识别图片和如果失败哪里出现了问题, 人工智能识别的好处就是不用费心想算法…而且以后万一图片改了, 直接换个训练集一样能上能识别. 分析主函数先定义分析主函数double AnalyseSpace(), 主要流程是从图片中读取颜色信息, 然后分析图片, 计算出目标点坐标和自己点坐标, 根据位置求两点距离. 12345678910111213var bitmap = (Bitmap)Image.FromFile(ImgBoxResolved.ImageLocation);if (bitmap.Width != 1080 || bitmap.Height != 1920){ MessageBox.Show(&quot;图片错误&quot;); return 0;}var imgRGBArray = new int[1920][];bitmap.GetRGB(0, 0, 1080, 1920, imgRGBArray);var chessPoint = GetMySelfChessPosition(imgRGBArray);var targetPoint = FindTargetPoint(imgRGBArray);return calcSpace(chessPoint, targetPoint); 计算目标点坐标如何计算目标点坐标是个比较困难的问题, 最开始想的是扫描图片, 取最上方的节点颜色, 然后从该点开始取周围所有相同颜色的坐标, 最后求平均值就能得到中心点即目标点坐标了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private Point FindTargetPoint(int[][] imgRGBArray){ //从500开始逐行扫描 RGB tempRGB; RGB tempBoxColorRGB = new RGB(); Point startPoint = new Point(0, 0); Point endPoint = new Point(0, 0); Point rightPoint = new Point(0, 0); int rightHeight = 0; int maybeHeight = 0; var isFindStart = false; var isInBox = true; var isFindRight = false; var findCount = 400; var currentRowMaxJ = 0; for (var i = 500; i &lt; imgRGBArray.Length; i++) { currentRowMaxJ = 0; for (var j = 0; j &lt; imgRGBArray[i].Length; j++) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); if (!isFindStart) { if (!IsBgColor(tempRGB)) { isFindStart = true; startPoint.Y = i; startPoint.X = j; endPoint.X = j; rightPoint.X = j; tempBoxColorRGB = tempRGB; imgRGBArray[i][j] = (~tempRGB).ToInt(); currentRowMaxJ = j; } } else if (findCount &gt;= 0) { if (RGB.FromInt(imgRGBArray[i][j]) == tempBoxColorRGB) { currentRowMaxJ = j; if (!isFindRight) { imgRGBArray[i][j] = (~tempBoxColorRGB).ToInt(); } else if (isFindRight &amp;&amp; (i - startPoint.Y) &lt; (2 * maybeHeight + 20)) { imgRGBArray[i][j] = (~tempBoxColorRGB).ToInt(); endPoint.Y = i; } else if (isFindRight &amp;&amp; (i - startPoint.Y) &gt;= (2 * maybeHeight + 20)) { isInBox = false; break; } } } } if (isFindStart) { findCount--; //该行循环完成 if (rightPoint.X &lt; currentRowMaxJ) { rightPoint.X = currentRowMaxJ; rightPoint.Y = i; rightHeight = 0; } else if (rightPoint.X == currentRowMaxJ) { rightHeight++; } else if (rightPoint.X &gt; currentRowMaxJ) { isFindRight = true; maybeHeight = rightPoint.Y - startPoint.Y + rightHeight / 2; } } if (findCount &lt; 0 || !isInBox) { break; } } return new Point((startPoint.X + endPoint.X) / 2, (startPoint.Y + endPoint.Y) / 2);} 但是这样做了以后, 发现的问题是… 跳到后面一点以后, 有颜色完全不同的方块出来了… 忘记了这一点, 如果改成全用非背景识别区域, 那么后期也会存在一个问题, 距离特别近的时候, 棋子会覆盖住这片空白空间, 用非背景色判断也会存在问题. 那么就只能换种思路了. 再从头分析一下, 跳一步以后, 下一个方块从上方落下, 随机一个点, 但是一定是最上方, 那么换一种计算方式, 先找到目标物的顶点, 而光照是从右边往左边的, 那么下一步去找目标物的右端点, 如果右端点被棋子挡住了, 说明棋子在右边, 然后去寻找左端点, 就不会出现左端点被阴影挡住了的情况. 那么接下来的分析函数就简单了, 分成几个小函数实现. 寻找顶点坐标这里有个要注意的情况, 即棋子最高点有可能是比顶点还高的, 需要处理下这种情况, 所以需要先找到棋子位置再传入. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/// &lt;summary&gt;/// 寻找顶点的方法/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point FindTopPoint(int[][] imgRGBArray, Point chessPoint){ RGB tempRGB; Point topPoint = new Point(0, 0); var hasFindTopPoint = false; var isFirstFindIsNotBg = 0; for (var i = 500; i &lt; imgRGBArray.Length; i++) { for (var j = 0; j &lt; imgRGBArray[i].Length; j++) { isFirstFindIsNotBg++; if (!hasFindTopPoint) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); //if (!IsBgColor(tempRGB) &amp;&amp; !tempRGB.TotalLike(SelfCheesColor, 30)) if (!IsBgColor(tempRGB)) { if (isFirstFindIsNotBg == 1) { MessageBox.Show(string.Format(&quot;第一个点就不是BG,出错,BG颜色:{0},当前点颜色:{1}&quot;, BgColorAverage, tempRGB)); return ErrorPoint; } //如果当前点在自己点的空间中 if ((j &gt; chessPoint.X - 32) &amp;&amp; (j &lt; chessPoint.X + 50) &amp;&amp; (i &gt; chessPoint.Y - 2) &amp;&amp; (i &lt; chessPoint.Y + 200)) { continue; } else { hasFindTopPoint = true; topPoint.Y = i; topPoint.X = j; break; } } } } if (hasFindTopPoint) { break; } } if (!hasFindTopPoint) { MessageBox.Show(&quot;未找到合适的顶点&quot;); return ErrorPoint; } return topPoint;} 寻找右端点坐标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/// &lt;summary&gt;/// 先寻找右端点, 如果未找到或者右端点在自己棋子区间, 返回ErrorPoint/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point FindRightPoint(int[][] imgRGBArray, Point chessPoint, Point topPoint){ RGB tempRGB; var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]); //从顶点开始往右边找 //最高高度设置为200 var maxHeight = 200; var maxWidth = 300; Point rightPoint = new Point(0, 0); var hasFindRightPoint = false; for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++) { var thisRowIsAllBG = true; var currentRowHasBgInMiddle = false; for (var j = topPoint.X; j &lt; topPoint.X + maxWidth &amp;&amp; j &lt; imgRGBArray[i].Length; j++) { if (!hasFindRightPoint) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); //如果当前点是背景颜色, 跳过该行 if (!thisRowIsAllBG &amp;&amp; tempRGB.Like(currentBGColor, 10)) { currentRowHasBgInMiddle = true; } if (!IsBgColor(tempRGB)) { thisRowIsAllBG = false; //如果当前点不是背景,而下一个点是背景 if (!currentRowHasBgInMiddle &amp;&amp; IsBgColor(RGB.FromInt(imgRGBArray[i][j + 1]))) { if (rightPoint.X &lt; j)//如果已经有的rightPoint在当前点左边 { rightPoint.Y = i; rightPoint.X = j; } else if (rightPoint.X == j) { //如果已有的rightPoint和当前点的X坐标相同, //那么需要接下来的几个点都不是背景,才能确定是最终点 var isFinal = true; for (int m = 1; m &lt; 3; m++) { if (!IsBgColor(RGB.FromInt(imgRGBArray[i + m][j + 1]))) { isFinal = false; break; } } if (isFinal) { hasFindRightPoint = true; break; } } else if (rightPoint.X &gt; j) { hasFindRightPoint = true; break; } } } } } if (hasFindRightPoint) { break; } } if (!hasFindRightPoint) { return ErrorPoint; //MessageBox.Show(&quot;未找到合适的右端点, 去寻找左端点&quot;); } return rightPoint;} 寻找左端点坐标1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/// &lt;summary&gt;/// 如果右端点不存在或者出错的情况下, 开始寻找左端点/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point FindLeftPoint(int[][] imgRGBArray, Point chessPoint, Point topPoint){ var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]); var topPointColor = RGB.FromInt(imgRGBArray[topPoint.Y][topPoint.X]); //从顶点开始往右边找 //最高高度设置为200 var maxHeight = 200; var hasFindLeftPoint = false; var leftPoint = new Point(0, 0); //寻找左边端点 for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++) { for (var j = 100; j &lt; topPoint.X; j++) { if (!hasFindLeftPoint) { //如果当前点不是背景色 if (!RGB.FromInt(imgRGBArray[i][j]).Like(currentBGColor, 10)) { //如果以下8个点都不是背景, //而且前一位的8个点都是背景 //那么就是左端点 var isFinal = true; for (var m = 1; m &lt;= 8; m++) { if (!RGB.FromInt(imgRGBArray[i + m][j - 1]).Like(currentBGColor, 10) || RGB.FromInt(imgRGBArray[i + m][j]).Like(currentBGColor, 10)) { isFinal = false; break; } } if (isFinal) { leftPoint.Y = i; leftPoint.X = j; hasFindLeftPoint = true; break; } } } } if (hasFindLeftPoint) { break; } } if (!hasFindLeftPoint) { return ErrorPoint; } return leftPoint;} 寻找自己棋子坐标这个坐标寻找方式就和之前的找目标点完全不同了, 因为棋子是不会变化的, 那么从PS中截出棋子的图片, 然后当作res把图片信息加载进来, 再整个图片查找一下对应点和像素, 就能找到自己的点了. 需要注意的是, 为了防止色差, 对自己棋子的点的颜色比较设定了一个容差5. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#region 棋子位置和颜色函数private RGB[][] imgMySelfChessRGBColorArray;private RGB[][] mySelfChessStart3x3Point;private void InitMyImgARGBArray(){ var bitmap = (Bitmap)Image.FromFile(PublicPath + @&quot;/Res/WX-MY.png&quot;); if (bitmap.Width != 80 || bitmap.Height != 220) { MessageBox.Show(&quot;资源图片错误&quot;); return; } var imgMySelfRGBArray = new long[220][]; Point StartPoint = new Point(-1, -1); imgMySelfChessRGBColorArray = new RGB[imgMySelfRGBArray.Length][]; bitmap.GetRGBA(0, 0, 80, 220, imgMySelfRGBArray); for (var i = 0; i &lt; imgMySelfRGBArray.Length; i++) { imgMySelfChessRGBColorArray[i] = new RGB[imgMySelfRGBArray[i].Length]; for (var j = 0; j &lt; imgMySelfRGBArray[i].Length; j++) { var tempRGB = RGB.FromInt(imgMySelfRGBArray[i][j], true); imgMySelfChessRGBColorArray[i][j] = tempRGB; if (tempRGB.A == 255 &amp;&amp; StartPoint.X == -1) { StartPoint.Y = i; StartPoint.X = j; } } } mySelfChessStart3x3Point = new RGB[3][]; for (var i = 0; i &lt; mySelfChessStart3x3Point.Length; i++) { mySelfChessStart3x3Point[i] = new RGB[3]; for (var j = 0; j &lt; mySelfChessStart3x3Point[i].Length; j++) { mySelfChessStart3x3Point[i][j] = imgMySelfChessRGBColorArray[StartPoint.Y + i][StartPoint.X + j]; } }}private Point GetMySelfChessPosition(int[][] imgRGBArray){ int temp_i = 0; int temp_j = 0; RGB tempRGB = new RGB(); var isFindStart = false; var findCount = 50; for (var i = 500; i &lt; 1500; i++) { for (var j = 100; j &lt; 1000; j++) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); if (!isFindStart) { if (IsMySelfChess(imgRGBArray, i, j)) { isFindStart = true; temp_i = i; temp_j = j; } } } if (isFindStart) { findCount--; } if (findCount &lt; 0) { break; } } return new Point(temp_j, temp_i);}private bool IsMySelfChess(int[][] imgRGBArray, int _i, int _j){ for (var i = 0; i &lt; mySelfChessStart3x3Point.Length; i++) { for (var j = 0; j &lt; mySelfChessStart3x3Point[i].Length; j++) { if (!mySelfChessStart3x3Point[i][j].Like(RGB.FromInt(imgRGBArray[_i + i][_j + j]), 5)) { return false; } } } return true;}#endregion 计算距离最开始直接使用的两点距离计算公式, 后来发现可能需要只计算轴向距离的间隔. 但是最终测试以后, 发现直接计算距离好像也可以. 12345678//计算轴向距离var l = Math.Sqrt(Math.Pow(targetPoint.X - cheesCenterPoint.X, 2) + Math.Pow(targetPoint.Y - cheesCenterPoint.Y, 2));var angle = Math.Atan2(Math.Abs(targetPoint.Y - cheesCenterPoint.Y), Math.Abs(targetPoint.X - cheesCenterPoint.X)) * 180 / Math.PI;var space = l * Math.Cos((angle - 30) * Math.PI / 180);//计算点距离var space = Math.Sqrt(Math.Pow(targetPoint.X - cheesCenterPoint.X, 2) + Math.Pow(targetPoint.Y - cheesCenterPoint.Y, 2)); 计算跳跃时间这个值…纯粹靠猜和试, 毕竟分辨率不同, 测出来的像素距离也会不同… 123456789101112131415/// &lt;summary&gt;/// 根据距离计算按压时间/// * 可能距离超过一定长度的时候需要减少按压时间/// &lt;/summary&gt;/// &lt;param name=&quot;space&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public int GetPressTimeBySpace(double space){ double result = space * 1.4; if (space &gt; 600) { result = space * 1.35; } return (int)(result);} 优化&amp;流程到这里以后, 基本上功能就完成了, 然后添加一些小的修补功能和自动化流程以后, 就能使用了. 不过还有个优化的地方, 就是在一次跳在正中心点以后, 下一个目标物上会出现一个白色小圈圈, 表示跳那里能出现2x加分. 利用好这个点, 可以极大的缩减点位计算幅度. 那么流程就变成如下: 寻找自己点坐标; 寻找顶点坐标(需要排除自己的位置); 试图根据顶点坐标寻找白圈; 如果找到白圈 -&gt; 返回; 如果没找到, 寻找右端点; 如果右端点不存在或者被自己挡住, 寻找左端点; 根据端点计算出目标点距离, 返回; 试图寻找中心白圈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/// &lt;summary&gt;/// 试图寻找下一步中间的白点(如果上一步是中心点)/// 从顶点开始, 寻找整个可能的格子空间,/// 记录所有颜色值为白点的点./// 如果这些点最终能构成符合大小的圆形,/// 那么可以确定为中心点./// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point TryFindCenterWhitePoint(int[][] imgRGBArray, Point chessPoint, Point topPoint){ var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]); //从顶点开始往右边找 //最高高度设置为200 var maxHeight = 200; var maxWidth = 300; Point centerPoint = new Point(0, 0); var hasFindCenterPoint = false; for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++) { for (var j = topPoint.X; j &lt; topPoint.X + maxWidth; j++) { if (!hasFindCenterPoint) { if (topPoint.X - j &gt; 0 &amp;&amp; RGB.FromInt(imgRGBArray[i][topPoint.X - j]) == TargetCenterWhitePointColor) { var centerPointMay = TryFindWhiteCircleAtPosition(imgRGBArray, i, topPoint.X - j); if (centerPointMay == ErrorPoint) { break; } else { centerPoint = centerPointMay; hasFindCenterPoint = true; } } if (j &lt; imgRGBArray[i].Length &amp;&amp; RGB.FromInt(imgRGBArray[i][j]) == TargetCenterWhitePointColor) { var centerPointMay = TryFindWhiteCircleAtPosition(imgRGBArray, i, j); if (centerPointMay == ErrorPoint) { break; } else { centerPoint = centerPointMay; hasFindCenterPoint = true; } } } } if (hasFindCenterPoint) { break; } } if (hasFindCenterPoint) { return centerPoint; } return ErrorPoint;}/// &lt;summary&gt;/// 在指定坐标(白色圆形顶部)判断是否能找到白色圆形/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;_i&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;_j&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point TryFindWhiteCircleAtPosition(int[][] imgRGBArray, int _i, int _j){ var maxWhiteCircleHeight = 28; var maxWhiteCircleWidth = 45; var startPointSpaceBetweenCircle = maxWhiteCircleWidth / 2; var minWhiteCircleHeight = 20; var minWhiteCircleWidth = 35; var leftTopPoint = new Point(1920 - 1, 1080 - 1); var rightBottomPoint = new Point(0, 0); var centerPoint = new Point(0, 0); var centerPointAddCount = 0; //根据平均统计,找到最中心的点 for (var i = _i; i &lt; _i + maxWhiteCircleHeight; i++) { for (var j = _j - startPointSpaceBetweenCircle; j &lt; _j + maxWhiteCircleWidth + startPointSpaceBetweenCircle; j++) { if (j &lt; 0 || j &gt; imgRGBArray[0].Length) { continue; } if (RGB.FromInt(imgRGBArray[i][j]) == TargetCenterWhitePointColor) { leftTopPoint.Y = Math.Min(leftTopPoint.Y, i); leftTopPoint.X = Math.Min(leftTopPoint.X, j); rightBottomPoint.Y = Math.Max(rightBottomPoint.Y, i); rightBottomPoint.X = Math.Max(rightBottomPoint.X, j); centerPoint.Y += i; centerPoint.X += j; centerPointAddCount++; } } } centerPoint = new Point(centerPoint.X / centerPointAddCount, centerPoint.Y / centerPointAddCount); var middlePoint = new Point((leftTopPoint.X + rightBottomPoint.X) / 2, (leftTopPoint.Y + rightBottomPoint.Y) / 2); //判断该点周围全是白色 for (var i = centerPoint.Y - 3; i &lt;= centerPoint.Y + 3; i++) { for (var j = centerPoint.X - 10; j &lt;= centerPoint.X + 10; j++) { if (RGB.FromInt(imgRGBArray[i][j]) != TargetCenterWhitePointColor) { return ErrorPoint; } } } //最大距离之外不是白色, 最小距离之内全是白色 if (RGB.FromInt(imgRGBArray[centerPoint.Y - maxWhiteCircleHeight / 2][centerPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y + maxWhiteCircleHeight / 2][centerPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X - maxWhiteCircleWidth / 2]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X + maxWhiteCircleWidth / 2]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y - minWhiteCircleHeight / 2][centerPoint.X]) != TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y + minWhiteCircleHeight / 2][centerPoint.X]) != TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X - minWhiteCircleWidth / 2]) != TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X + minWhiteCircleWidth / 2]) != TargetCenterWhitePointColor) { return ErrorPoint; } //最大边框处不应该有白色 if (RGB.FromInt(imgRGBArray[leftTopPoint.Y][leftTopPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[leftTopPoint.Y][rightBottomPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[rightBottomPoint.Y][rightBottomPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[rightBottomPoint.Y][leftTopPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } SetPointWithRectColor(imgRGBArray, leftTopPoint.Y, leftTopPoint.X, 3, CenterBoxColor); SetPointWithRectColor(imgRGBArray, leftTopPoint.Y, rightBottomPoint.X, 3, CenterBoxColor); SetPointWithRectColor(imgRGBArray, rightBottomPoint.Y, rightBottomPoint.X, 3, CenterBoxColor); SetPointWithRectColor(imgRGBArray, rightBottomPoint.Y, leftTopPoint.X, 3, CenterBoxColor); return centerPoint;} 自动化开启一个新线程执行循环跳, 再点一次干掉线程. 1234567891011121314151617181920212223242526272829private void BtnStartJump_Click(object sender, EventArgs e){ isDoingJump = !isDoingJump; if (isDoingJump) { myLog.AppendToFile(LogFilePath, &quot;开始跳...&quot;); BtnStartJump.Text = &quot;正在跳...&quot;; jumpThread = new Thread(() =&gt; { while (isDoingJump) { GetAndroidScreen(); var space = AnalyseSpace(); System.Threading.Thread.Sleep(JumpDelay); var pressTime = GetPressTimeBySpace(space); ExecCmd(ADBPath + string.Format(&quot;shell input swipe 500 500 501 501 {0}&quot;, pressTime)); System.Threading.Thread.Sleep(pressTime + ShotScreenDelay); } }); jumpThread.Start(); } else { myLog.AppendToFile(LogFilePath, &quot;跳完了&quot;); BtnStartJump.Text = &quot;开始跳!&quot;; jumpThread.Abort(); jumpThread = null; }} 日志记录然后就是加入日志模块, 和图片保存, 将每次跳和计算的结果都保存起来, 以供之后分析. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class JumpLog{ public JumpLog() { } public JumpLog(DateTime shotScreenTime) { this.ShotScreenTime = shotScreenTime; } public DateTime ShotScreenTime { get; set; } public DateTime AnalyseStartTime { get; set; } public DateTime AnalyseEndTime { get; set; } public int AnalyseTime { get { return (int)(AnalyseEndTime - AnalyseStartTime).TotalMilliseconds; } } public double AnalyseSpace { get; set; } public Point TopPointPosition { get; set; } public Point RightPointPosition { get; set; } public Point LeftPointPosition { get; set; } public Point CenterWhitePointPosition { get; set; } public JumpLogPointPositionType GetPointPositionType { get; set; } public Point TargetPointPosition { get; set; } public Point SelfChessPointPosition { get; set; } public int PressTime { get; set; } public string ScreenImageFileName { get; set; } public void AppendToFile(string filePath, string content) { using (var fileStream = File.Open(filePath, FileMode.Append, FileAccess.Write)) { var writeStream = new StreamWriter(fileStream, Encoding.UTF8); writeStream.WriteLine(string.Format(&quot;[{0}] : {1}&quot;, DateTime.Now.GetCommonDateString(), content)); writeStream.Flush(); writeStream.Close(); } } public void AppendToFile(string filePath) { AppendToFile(filePath, GetLogString()); } private string GetLogString() { return string.Format(&quot;[截图时间:{0}] [分析耗时:{1}ms] [分析最终距离:{2}px] [按压时间:{3}] [定位模式:{4}] [顶点坐标:{5}] [定位点坐标:{6}] [目标点坐标:{7}] [棋子坐标:{8}] [图片名称:{9}]&quot;, ShotScreenTime.GetCommonDateString(), AnalyseTime, AnalyseSpace.ToString(&quot;0.00&quot;), PressTime, GetPointPositionType.GetDescription(), TopPointPosition.ToString(), GetRightAnchorPointPosition().ToString(), TargetPointPosition.ToString(), SelfChessPointPosition.ToString(), ScreenImageFileName); } private Point GetRightAnchorPointPosition() { switch (GetPointPositionType) { case JumpLogPointPositionType.Center: return CenterWhitePointPosition; case JumpLogPointPositionType.Right: return RightPointPosition; case JumpLogPointPositionType.Left: return LeftPointPosition; } return new Point(-1, -1); }}public enum JumpLogPointPositionType{ [Description(&quot;通过中心白点定位&quot;)] Center = 1, [Description(&quot;通过右端点定位&quot;)] Right = 2, [Description(&quot;通过左端点定位&quot;)] Left = 4,}public static class StaticJumpLogPointPositionTypeHelp{ public static string GetDescription(this JumpLogPointPositionType type) { FieldInfo EnumInfo = type.GetType().GetField(type.ToString()); DescriptionAttribute[] EnumAttributes = (DescriptionAttribute[])EnumInfo. GetCustomAttributes(typeof(DescriptionAttribute), false); if (EnumAttributes.Length &gt; 0) { return EnumAttributes[0].Description; } return type.ToString(); }} 运行结果","link":"/2018/01-08-wechat-jump-game/"},{"title":"xposed 插件开发","text":"换了新手机，装上了Xposed加上各种插件，简直完美。以前一直想了解Xposed是如何工作的，正好有个插件有点 Bug，于是了解一下。 首先看文档，安装好Android Studio，下载开发包，导入项目，修改好gradle里的配置，这些网上都有直接的教程，没有很大问题。然后在AndroidMenafest.xml文件里声明为Xposed模块，创建Hook类，并创建xposed_init文件，声明好入口。 1234567@Overridepublic void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (!PackageList.contains(lpparam.packageName)) { return; } XposedBridge.log(String.format(&quot;Hello xposed!&quot;));} 安装运行代码以后，可以在Xposed里找到刚刚安装的 APP，勾上并开启，重启手机便能看到在Xposed日志里打印的Hello xposed!了。 开发Xposed比较麻烦的地方在于每次改代码以后安装都需要重启，而且调试其他APP只能通过日志查看，于是我找到了可以使用Android Studio断点调试功能的方法。首先需要建一个自己的APP，调用会触发Xposed的代码，在Android Studio里面运行附加调试，调试的内容是调试Xposed插件的代码而不是那个APP，这样在APP中触发了Xposed应用代码以后，断点即可进入了。 剩下的内容便很简单了，找到原来那个插件的代码，发现它的调用方式有问题，去查看Android源码，找到正确的调用方式，使用反射拿到对象并调用，于是便解决了问题。唯一的麻烦就是查Android源码需要将各个版本的都下载下来并查看，而国内的网速… 有了这个插件以后，之前的那个有问题的插件也不用安装了，直接卸载，用这个替代，为了解决之前插件的一些缺陷，还准备做个可视化界面，目前只是把数据写入数据库，可以使用sqlite editor查看。 还有个情况是，好像在初始化的时候不能读取数据库和文件，于是做不到动态判断哪些包是需要拦截哪些不需要。可能底层 C 语言可以做到，但是太麻烦了，以后如果还涉及到这种插件可以研究下动态加载拦截包如何实现。 这个插件如果有需要也可以自由下载代码编译，个人比较懒，也不想发布到Xposed市场里。","link":"/2018/03-12-xposed-sport-edit/"},{"title":"webview-bridge","text":"在实现游戏内嵌直播平台的时候, 有些需求需要与游戏本体进行互动, 如关闭游戏音乐或调用游戏内接口等, 项目内旧版的接口调用方式是使用原生注入 js 接口来提供 js 调用, 这样新增接口的成本较高, 所以在调研过后决定和客户端同学一起将协议换成拦截url加载 在webview内调用时候自动生成callbackId并注入到全局, 客户端处理完事件后调用此callback进行回调 约定好返回值的数据结构, 客户端可以做到统一处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445const invokes = {};let invokeId = 1;function removeInvoke(invoke) { window[invoke.callback] = null; if (invoke.iframe) { document.body.removeChild(invoke.iframe); } delete invokes[invoke.callback];}function invokeNative(func, params, onSuccess, onError) { const invoke = { func: func, callback: 'webviewToNativeCallback' + invokeId, params: params, }; const iframe = document.createElement('iframe'); iframe.src = 'webview://' + encodeURIComponent(JSON.stringify(invoke)); iframe.className = 'native-iframe'; invoke.iframe = iframe; invokes[invoke.callback] = invoke; window[invoke.callback] = function (res) { if (res &amp;&amp; res.errno) { console.log(res); onError &amp;&amp; onError(res); } else { onSuccess &amp;&amp; onSuccess(res); } removeInvoke(invoke); }; setTimeout(() =&gt; { // 移除iframe后某些地方调用会有问题 // document.body.removeChild(invoke.iframe); invoke.iframe = null; }, 1000); document.body.appendChild(iframe); invokeId++;}export function callGameFunction() { invokeNative('callGameFunction');}export default invokeNative;","link":"/2018/03-15-webview-bridge/"},{"title":"react-native 入门","text":"上次的Xposed插件少个可视化界面，如果直接使用Android开发也不是不行，但是那样太无聊了，正好试试一直想使用的React Native技术来开发一个简单的界面。 开发工具同样是简单的Android Studio，按照RN中文网上的开发步骤先搭建一个Hello World，基于这个demo先做一个不读取数据的展示页面，顺便学习一下导航栏的使用。 RN 与原生的数据交互是通过NativeModules这个对象进行异步操作的，可以通过async和await使操作更简单，并封装一个调用原生的方法 12345import { NativeModules } from 'react-native';export async function JsDBHelperCall(func, ...args) { return await NativeModules.JsDBHelper[func](...args);} 简单的应用里也无需使用redux来管理数据，直接使用Props传递即可，其他的代码基本和写React一样，然后运行起来并写好java端的代码，实现数据流通便算完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class JsDBHelper extends ReactContextBaseJavaModule { private DBHelper db = null; private SportEditorDao sportEditorDao = null; public JsDBHelper(ReactApplicationContext reactContext) { super(reactContext); db = new DBHelper(reactContext); sportEditorDao = new SportEditorDao(reactContext); } @Override public String getName() { return this.getClass().getSimpleName(); } @ReactMethod public void ExecSQL(String sql, ReadableArray selectionArgs) { try { JSONArray args = ArrayUtil.toJSONArray(selectionArgs); db.ExecSQL(sql, args.toJavaList(String.class)); } catch (JSONException e) { e.printStackTrace(); } } @ReactMethod public void QueryForMap(String sql, ReadableArray selectionArgs) { try { JSONArray args = ArrayUtil.toJSONArray(selectionArgs); Map&lt;String, String&gt; result = db.QueryForMap(sql, args.toJavaList(String.class)); } catch (JSONException e) { e.printStackTrace(); } } @ReactMethod public void QueryForListMap(String sql, ReadableArray selectionArgs, Promise promise) { ... } @ReactMethod public void GetConfigByPackageName(String packageName, Promise promise) { ... } @ReactMethod public void GetConfigs(Promise promise) { ... } @ReactMethod public void SaveConfig(ReadableMap selectionArgs, Promise promise) { ... }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export default class HomeScreen extends React.PureComponent { constructor(props) { super(props); this.state = { configs: Immutable.fromJS([]), refreshing: false, isLoading: true, }; this.onRefresh = this.onRefresh.bind(this); this.rowClick = this.rowClick.bind(this); } async componentDidMount() { let configs = await JsDBHelperCall('GetConfigs'); this.setState({ isLoading: false, configs: Immutable.fromJS(configs), }); console.log(configs); } async onRefresh() { this.setState({ refreshing: true, }); let configs = await JsDBHelperCall('GetConfigs'); this.setState({ refreshing: false, configs: Immutable.fromJS(configs), }); console.log(configs); } rowClick(config, index) { this.props.navigation.navigate('Detail', { config: config, callBack: this.onRefresh, }); } render() { const emptyText = this.state.isLoading ? 'Loading...' : this.state.errorMsg ? 'Error!' : 'No data.'; return ( &lt;View&gt; &lt;ImmutableVirtualizedList immutableData={this.state.configs} keyExtractor={(item, index) =&gt; item.get('packageName')} ListHeaderComponent={() =&gt; &lt;AppRowHeader /&gt;} renderItem={({ item, index }) =&gt; &lt;AppRow config={item} rowClick={this.rowClick} index={index} /&gt;} onRefresh={this.onRefresh} refreshing={this.state.refreshing} renderEmptyInList={emptyText} /&gt; &lt;/View&gt; ); }} 然后再将原来的Xposed APP代码原样移植到这边的java层，丢到手机运行，收工！ 这个插件如果有需要也可以自由下载代码编译，个人比较懒，也不想发布到Xposed市场里。","link":"/2018/06-05-react-native-start/"},{"title":"FastDFS 搭建小文件存储集群","text":"背景最近某个系统在使用内部 S3 存储的时候发现内部 S3 功能不完善, 每个桶最大支持 100w 份文件(标准 S3 无上限), 而我们系统内的文件基本上都是大量的小份文件存储, 所以需要调研下是否有其他的解决方案, 查看网上部分解决方案后, 决定选用FastDFS测试一下. 简介FastDFS 分为三种角色: Cliet : 需要上传文件的客户端 Tracker Server : 负责管理 Storage 的节点, 负责分发请求, 可以集群化, 每个节点对等 Storage Server : 实际存储数据节点, 可以集群化, 每个节点对等, 存储数据的过程由 Tracker 分配 整体方案 使用 openresty+lua 转发文件到 fastdfs 存储, 支持任意客户端使用标准 HTTP 上传文件 实现自定义脚本定时删除过期文件 上传流程图sequenceDiagram participant C as Client participant T as Tracker Server participant S as Storage Server S -->> T: 1. 定时向Tracker上传状态信息 C ->> T: 2. 发起上传请求 T ->> T: 3. 查询可用Storage T -->> C: 4. 返回Storage信息(ip和端口) C ->> S: 5. 上传文件(file content和metadata) S ->> S: 6. 生成file_id S ->> S: 7. 将上传内容写入磁盘 S -->> C: 8. 返回file_id C ->> C: 9. 存储文件信息 下载流程图sequenceDiagram participant C as Client participant T as Tracker Server participant S as Storage Server S -->> T: 1. 定时向Tracker上传状态信息 C ->> T: 2. 发起下载请求 T ->> T: 3. 查询可用Storage(检验同步状态) T -->> C: 4. 返回Storage信息(ip和端口) C ->> S: 5. file_id(组名, 路径, 文件名) S ->> S: 6. 集群内查找文件 S -->> C: 7. 返回file_content Docker 化 搭建一个 2 个tracker节点, 2 组storage服务, 每组storege里有 2 个存储节点, 一个nginx入口的Docker集群 这样搭建的好处是所有节点只需修改自己的配置就可以做到动态/自由扩容 tracker 镜像1234567891011121314151617181920212223242526272829303132FROM debian:stableRUN apt-get update &amp;&amp; apt-get -y install git wget ca-certificates libpcre3 libpcre3-devWORKDIR /home/tracker-server/var/tmp/RUN git clone https://github.com/happyfish100/libfastcommon.gitRUN wget https://github.com/happyfish100/fastdfs/archive/master.tar.gz -O fastdfs-master.tar.gzWORKDIR /home/tracker-server/var/tmp/libfastcommonRUN ./make.sh &amp;&amp; ./make.sh installRUN export LD_LIBRARY_PATH=/usr/lib/RUN ln -s /usr/lib/libfastcommon.so /usr/local/lib/libfastcommon.soWORKDIR /home/tracker-server/var/tmp/RUN tar xzf fastdfs-master.tar.gzWORKDIR /home/tracker-server/var/tmp/fastdfs-masterRUN ./make.sh &amp;&amp; ./make.sh installCOPY ./conf/common /home/tracker-server/var/conf/trackerCOPY ./conf/tracker /home/tracker-server/var/conf/trackerRUN mkdir -p /home/tracker-server/var/log/trackerRUN mkdir -p /home/tracker-server/data/storage0ENTRYPOINT /usr/bin/fdfs_trackerd /home/tracker-server/var/conf/tracker/tracker.conf &amp; tail -f /dev/null storage 镜像 注意, 这里的storege group的内容区别是根据storage.conf这个文件内容区分的, 需要多少个group, 创建多少个storage.conf就行, 或者在Docker启动的时候指定环境变量通过脚本注入也行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849FROM debian:stableRUN apt-get update &amp;&amp; apt-get -y install git wget ca-certificates libpcre3 libpcre3-devWORKDIR /home/storage-server/var/tmp/RUN git clone https://github.com/happyfish100/libfastcommon.gitRUN wget https://github.com/happyfish100/fastdfs/archive/master.tar.gz -O fastdfs-master.tar.gzRUN wget https://nginx.org/download/nginx-1.14.0.tar.gz -O nginx-1.14.0.tarRUN wget https://github.com/happyfish100/fastdfs-nginx-module/archive/master.tar.gz -O fastdfs-nginx-module-master.tar.gzWORKDIR /home/storage-server/var/tmp/libfastcommonRUN ./make.sh &amp;&amp; ./make.sh installRUN export LD_LIBRARY_PATH=/usr/lib/RUN ln -s /usr/lib/libfastcommon.so /usr/local/lib/libfastcommon.soWORKDIR /home/storage-server/var/tmp/RUN tar xzf fastdfs-master.tar.gzRUN tar xzf nginx-1.14.0.tarRUN tar xzf fastdfs-nginx-module-master.tar.gzWORKDIR /home/storage-server/var/tmp/fastdfs-masterRUN ./make.sh &amp;&amp; ./make.sh installCOPY ./conf/storage/storage.conf /home/storage-server/var/conf/storage/storage.confCOPY ./conf/storage/mime.types /home/storage-server/var/conf/fdfs/mime.typesCOPY ./conf/storage/anti-steal.jpg /home/storage-server/var/conf/fdfs/anti-steal.jpgCOPY ./conf/storage/fastdfs-nginx-module.config /home/storage-server/var/tmp/fastdfs-nginx-module-master/src/configCOPY ./conf/storage/fastdfs-nginx-module.mod_fastdfs.conf /home/storage-server/var/conf/fdfs/mod_fastdfs.confCOPY ./conf/common/http.conf /home/storage-server/var/conf/fdfs/http.confCOPY ./conf/common/nginx.conf /home/storage-server/var/conf/nginx/nginx.confRUN mkdir -p /home/storage-server/var/log/storageRUN mkdir -p /home/storage-server/data/storage0WORKDIR /home/storage-server/var/tmp/nginx-1.14.0RUN ./configure --add-module=../fastdfs-nginx-module-master/src/RUN make &amp;&amp; make installRUN mkdir /home/storage-server/data/storage0/dataRUN ln -s /home/storage-server/data/storage0/data /home/storage-server/data/storage0/data/M00RUN cp /usr/local/nginx/conf/mime.types /home/storage-server/var/conf/nginx/mime.typesENTRYPOINT /usr/bin/fdfs_storaged /home/storage-server/var/conf/storage/storage.conf &amp; /usr/local/nginx/sbin/nginx -c /home/storage-server/var/conf/nginx/nginx.conf -g &quot;daemon off;&quot; 定时清除过期文件脚本1234567891011121314151617181920212223242526# delete_cron0,5,10,15,20,25,30,35,40,45,50,55 * * * * root (/bin/bash -c &quot;find /home/storage-server/data/storage0/data/ -type f -cmin +5 -exec /home/storage-server/running/fastdfs/crash-upload-file-server/conf/storage/delete.sh {} \\;&quot; &gt;&gt; /home/storage-server/var/log/storage/crontab.log 2&gt;&amp;1)# delete.sh#!/bin/bashgroup=&quot;group1&quot;function delete_file () { file_name=$1 file_name=${file_name##*/data/} file_name=$group/M00/$file_name /usr/bin/fdfs_delete_file /home/storage-server/running/fastdfs/crash-upload-file-server/conf/common/client.conf $file_name # /usr/bin/fdfs_delete_file /home/storage-server/var/conf/client/client.conf $file_name echo &quot;remove file $file_name&quot;}delete_file $1# how to use# edit client.conf -&gt; tracker_server# find /home/storage-server/data/storage0/data/ -type f -cmin +5# find /home/storage-server/data/storage0/data/ -type f -cmin +5 -exec ./delete.sh {} \\; nginx 镜像123456789101112131415161718192021222324252627FROM debian:stableRUN apt-get update &amp;&amp; apt-get -y install libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl make build-essential curl wgetWORKDIR /home/nginx-server/var/tmp/RUN wget https://openresty.org/download/openresty-1.13.6.2.tar.gzRUN tar -xzvf openresty-1.13.6.2.tar.gzWORKDIR /home/nginx-server/var/tmp/openresty-1.13.6.2/RUN ./configure --prefix=/opt/openresty --with-luajit --without-http_redis2_module --with-http_iconv_moduleRUN make &amp; make installCOPY ./conf/nginx/nginx.conf /home/nginx-server/var/conf/openresty/nginx.confWORKDIR /opt/openresty/nginx/sbin/COPY ./lua /home/nginx-server/running/fastdfs/crash-upload-file-server/lua/COPY ./index.html /home/nginx-server/running/fastdfs/crash-upload-file-server/RUN mkdir -p /home/nginx-server/var/log/openresty/ENTRYPOINT ./nginx -c /home/nginx-server/var/conf/openresty/nginx.conf -g &quot;daemon off;&quot;# RUN ./nginx -c /home/upload/conf/nginx.conf# RUN cat ../logs/error.log docker compose123456789101112131415161718192021222324252627282930313233343536373839404142tracker-server: image: fastdfs-trackertracker-server-2: image: fastdfs-trackerstorage-server-group1-1: image: fastdfs-storage links: - tracker-server:tracker-server - tracker-server-2:tracker-server-2storage-server-group1-2: image: fastdfs-storage links: - tracker-server:tracker-server - tracker-server-2:tracker-server-2storage-server-group2-1: image: fastdfs-storage_2 links: - tracker-server:tracker-server - tracker-server-2:tracker-server-2storage-server-group2-2: image: fastdfs-storage_2 links: - tracker-server:tracker-server - tracker-server-2:tracker-server-2nginx_test: image: nginx_test ports: - '20022:22' - '20080:80' links: - tracker-server:tracker-server - tracker-server-2:tracker-server-2 - storage-server-group1-1:storage-server-group1-1 - storage-server-group1-2:storage-server-group1-2 - storage-server-group2-1:storage-server-group2-1 - storage-server-group2-2:storage-server-group2-2 性能打包好相关镜像后, 使用compose直接拉起, 做一下简单的性能压测, 总体来说性能是很不错的, 基本能达到单机峰值, 而且由于各角色的节点都是可以平行扩容的, 所以拓展起来也没有太大压力 压测环境: 2 tracker + 2*2 storage 文件大小: 平均 4M QPS: 60 上传 - 90%响应时间: 3.5s 上传 - 最大请求时间: 5s 下载 - 最大响应时间: 1s 容器间网络带宽: 1Gb 其他方案还看过一个其他方案Ceph, Ceph支持快存储, 但是使用文档较少, 所以最终还是选择了FastDFS 参考文档","link":"/2018/07-23-fastdfs/"},{"title":"Python 函数装饰器(Decorators)","text":"背景最近在维护一个比较旧的web站点, 前端是比较熟悉的angularjs, 而后端是和js有点类似的python+Flask. 最近碰到一个需求, 需要对部分接口加上用户操作日志, 这种情况就是典型的AOP方法了, 研究了一下, python也有装饰器Decorators, 使用起来非常简单 原理Python的装饰器本质上也是对函数的二次封装, 但是由于Flask有threadLocal支持线程/协程的本地全局变量, 所以在装饰器里直接读写全局变量即可 手动实现装饰器下面是通用教程里的相关方法, 和js的高阶函数实现基本一致, 但是js不支持对函数使用装饰器, 因为会存在变量提升 1234567891011121314151617181920212223242526272829303132333435363738def a_new_decorator(a_func): def wrapTheFunction(): print(&quot;I am doing some boring work before executing a_func()&quot;) a_func() print(&quot;I am doing some boring work after executing a_func()&quot;) return wrapTheFunctiondef a_function_requiring_decoration(): print(&quot;I am the function which needs some decoration to remove my foul smell&quot;)a_function_requiring_decoration()#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)#now a_function_requiring_decoration is wrapped by wrapTheFunction()a_function_requiring_decoration()#outputs:I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func()@a_new_decoratordef a_function_requiring_decoration(): &quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot; print(&quot;I am the function which needs some decoration to &quot; &quot;remove my foul smell&quot;)a_function_requiring_decoration()#outputs: I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func()#the @a_new_decorator is just a short way of saying:a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 这样实现的装饰器可以用, 但是如果调用获取函数信息的一些方法就会存在异常, 会返回装饰器自己的函数相关信息 12print(a_function_requiring_decoration.__name__)# Output: wrapTheFunction 解决这个问题也很简单, 在装饰器函数返回的时候, 将返回的函数信息从原始函数信息里复制过来再返回, 比如functools里面的update_wrapper实现 123456789101112131415161718WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')WRAPPER_UPDATES = ('__dict__',)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): for attr in assigned: try: value = getattr(wrapped, attr) except AttributeError: pass else: setattr(wrapper, attr, value) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, {})) wrapper.__wrapped__ = wrapped return wrapper wraps上面描述了一个装饰器函数的功能和流程, 而为了避免自己实现, 我们可以直接使用functools里提供的wraps修饰器, 而且wraps里依赖的partial函数是使用C实现的, 不过官方也给出了python实现的代码 1234567891011121314151617from functools import wrapsdef wrapper(f): @wraps(f) def wrapper_function(*args, **kwargs): &quot;&quot;&quot;这个是修饰函数&quot;&quot;&quot; return f(*args, **kwargs) return wrapper_function@wrapperdef wrapped(): &quot;&quot;&quot;这个是被修饰的函数 &quot;&quot;&quot; print('wrapped')print(wrapped.__doc__) # 输出`这个是被修饰的函数`print(wrapped.__name__) # 输出`wrapped` 操作日志记录装饰器实现根据上面的原理, 实现我们需要的装饰器 利用闭包将模块传入到运行时 利用flask的threadLocal提供的g变量作为全局变量保存空间 123456789101112from flask import gfrom functools import wrapsdef operation_log(module=''): def deco_log(f): @wraps(f) def f_log(*args, **kwargs): g._operation_log['module'] = module g._need_operation_log = True return f(*args, **kwargs) return f_log return deco_log 装饰器使用1234567from decorators import operation_logclass Config(restful.Resource): @operation_log(module='config') def post(self): # ... 请求日志初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344def register_site(app): # ... @app.before_request def add_operation_log(): g._need_operation_log = False g._operation_log = { 'address': '%s:%s'%(request.headers.environ.get('REMOTE_ADDR', ''), request.headers.environ.get('REMOTE_PORT', '')), 'time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'module': '', 'path': request.base_url, 'ref': request.headers.environ.get('HTTP_REFERER', '').split('?')[0], 'method': request.headers.environ.get('REQUEST_METHOD', ''), 'user_agent': request.headers.environ.get('HTTP_USER_AGENT', ''), 'args': json.dumps(request.args), 'body': '', 'request_time': time.time(), 'status_code': 200, 'error': None, # ... 其他值 } if g._operation_log['method'] == 'post' and len(request.data) &lt; 2000: g._operation_log['body'] = request.data @app.after_request def put_operation_log(response=None): g._operation_log['request_time'] = time.time() - g._operation_log['request_time'] g._operation_log['status_code'] = response.status_code save_operation_log(g._operation_log) return response def error_handler(error): g._operation_log['request_time'] = time.time() - g._operation_log['request_time'] g._operation_log['status_code'] = 500 g._operation_log['error'] = str(error) save_operation_log(g._operation_log) return error app.handle_exception = error_handler def save_operation_log(log): # 有error一定会写日志 if g._need_operation_log or g._operation_log.get('error') is not None: # 将log落地 # saveLog(g._operation_log) 其他JavaScript 的装饰器 JavaScript的装饰器无法用于函数, 只能用于class, 因为存在变量提升 以下代码基于第一版装饰器提案, 已经过时, 不一定适用于最新提案 1234567891011121314151617181920212223242526272829303132// 声明var counter = 0;var add = function () { counter++;};@addfunction foo() {}// 实际执行@addfunction foo() {}var counter;var add;counter = 0;add = function () { counter++;};// 声明var readOnly = require(&quot;some-decorator&quot;);@readOnlyfunction foo() {}// 实际执行var readOnly;@readOnlyfunction foo() {}readOnly = require(&quot;some-decorator&quot;); 如果有类似的需求, 可以直接采用高阶函数实现, 类似 redux 的做法 123456789101112function doSomething(name) { console.log('Hello, ' + name);}function loggingDecorator(wrapped) { return function () { console.log('Starting'); const result = wrapped.apply(this, arguments); console.log('Finished'); return result; };}const wrapped = loggingDecorator(doSomething);","link":"/2018/08-06-python-decorator/"},{"title":"Egg 使用迭代器实现分段下载","text":"背景后台管理项目中最常见的需求就是导出数据了, 在C#和Java等框架中, 因为数据库请求和文件io基本都是同步操作, 所以可以简单的用while来实现数据的分段导出, 而在nodejs中, 因为异步callback和promise的写法问题, 都会导致代码非常难写, 想起ES6里有Generator函数, 可以用它来实现下载场景 实现Generator异步函数如果我们需要从一个有状态的地方, 或者一个一直写入的流里去获取数据, 一直到获取完成, 那么使用Generator会是比较优雅的方案, 而从无状态的数据源获取数据, 可以很简单的使用循环来实现 模拟有状态获取数据 下面方法执行后, 可以看到curl的log是按时间实时输出的, 很清晰的反应了分段下载的过程 ctx.runInBackground是官方推荐的在后台执行任务的方法, 会自动记录异常, 这里需要用到它是为了避免阻塞中间件, 可以让日志记录中间件实时记录响应返回的状态, 而不是在整体下载完成之后才记录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class ApiService extends Service { async apiGeneratorExportFile() { const { ctx } = this; ctx.logger.info('In apiGeneratorExportFile'); ctx.response.attachment('GeneratorExportFile.txt'); ctx.response.set('Transfer-Encoding', 'chunked'); ctx.response.set('Content-Type', 'text/plain; charset=utf-8'); ctx.response.set('X-Content-Type-Options', 'nosniff'); ctx.status = 200; ctx.body = new stream.PassThrough(); ctx.runInBackground(async () =&gt; { const bodyStream = ctx.body; try { for await (const data of this.getDataGen(bodyStream)) { if (!bodyStream.destoryed &amp;&amp; bodyStream.writable) { // 加上cork是为了去掉服务端缓冲, 避免客户端打印不及时 bodyStream.cork(); bodyStream.write(data); bodyStream.uncork(); } } } catch (e) { ctx.logger.error(e); } finally { if (!bodyStream.destoryed &amp;&amp; bodyStream.writable) { bodyStream.end(''); } } }); } async *getDataGen(bodyStream) { try { let data = 'Start'; const startTime = new Date().getTime(); while (data !== 'End' &amp;&amp; !bodyStream.destoryed &amp;&amp; bodyStream.writable) { data = await this.getDataSleep(startTime); this.ctx.logger.info(`get data ${data}`); yield data; } } catch (e) { this.ctx.logger.error(`get data fail, ${_.toString(e)}`); yield `get data fail, ${_.toString(e)}`; } } sleep(time) { return new Promise((r) =&gt; setTimeout(r, time)); } async getDataSleep(startTime) { await this.sleep(_.random(3, 5, false) * 1000); if (Math.random() &lt; 0.05) { throw new Error(`Random error`); } if (Math.random() &lt; 0.1) { return 'End'; } return `Get data success at ${new Date().getTime() - startTime}ms\\n`; }} 测试结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 下载到一半的时候出错的情况curl -vv http://127.0.0.1:7001/api/v1/generator-export-file* Trying 127.0.0.1...* TCP_NODELAY set* Connected to 127.0.0.1 (127.0.0.1) port 7001 (#0)&gt; GET /api/v1/generator-export-file HTTP/1.1&gt; Host: 127.0.0.1:7001&gt; User-Agent: curl&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Content-Type: text/plain; charset=utf-8&lt; Content-Disposition: attachment; filename=&quot;GeneratorExportFile.txt&quot;&lt; Transfer-Encoding: chunked&lt; x-content-type-options: nosniff&lt; x-frame-options: SAMEORIGIN&lt; x-xss-protection: 1; mode=block&lt; x-download-options: noopen&lt; x-readtime: 11&lt; Connection: keep-alive&lt; Keep-Alive: timeout=5&lt;Get data success at 4007msGet data success at 9016msGet data success at 14020msGet data success at 19033msGet data success at 24042msGet data success at 28045msGet data success at 33047msGet data success at 38054msGet data success at 41066msGet data success at 46077msget data fail, Error: Random error* Connection #0 to host 127.0.0.1 left intact# 下载成功完成curl -vv http://127.0.0.1:7001/api/v1/generator-export-file* Trying 127.0.0.1...* TCP_NODELAY set* Connected to 127.0.0.1 (127.0.0.1) port 7001 (#0)&gt; GET /api/v1/generator-export-file HTTP/1.1&gt; Host: 127.0.0.1:7001&gt; User-Agent: curl&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Content-Type: text/plain; charset=utf-8&lt; Content-Disposition: attachment; filename=&quot;GeneratorExportFile.txt&quot;&lt; Transfer-Encoding: chunked&lt; x-content-type-options: nosniff&lt; x-frame-options: SAMEORIGIN&lt; x-xss-protection: 1; mode=block&lt; x-download-options: noopen&lt; x-readtime: 3&lt; Connection: keep-alive&lt; Keep-Alive: timeout=5&lt;Get data success at 5003msGet data success at 8020msGet data success at 11033msGet data success at 16037msGet data success at 20044msGet data success at 23051msGet data success at 27060msGet data success at 30072msGet data success at 34087msGet data success at 39103msGet data success at 43105msGet data success at 48122msGet data success at 52129msGet data success at 57132msGet data success at 60146msGet data success at 63150msGet data success at 68165msGet data success at 71167msGet data success at 76178msEnd* Connection #0 to host 127.0.0.1 left intact 模拟无状态获取数据 基本流程和有状态一样, 只是将Generator函数换成了循环调用执行 ctx.runInBackground同样是为了避免阻塞中间件的返回 12345678910111213141516171819202122232425262728293031323334353637class ApiService extends Service { async apiLoopExportFile() { const { ctx } = this; ctx.logger.info('In apiLoopExportFile'); ctx.response.attachment('LoopExportFile.txt'); ctx.response.set('Transfer-Encoding', 'chunked'); ctx.response.set('Content-Type', 'text/plain; charset=utf-8'); ctx.response.set('X-Content-Type-Options', 'nosniff'); ctx.status = 200; ctx.body = new stream.PassThrough(); ctx.runInBackground(async () =&gt; { const bodyStream = ctx.body; try { let data = 'Start'; const startTime = new Date().getTime(); bodyStream.cork(); bodyStream.write(data); bodyStream.uncork(); do { data = await this.getDataSleep(startTime); if (!bodyStream.destoryed &amp;&amp; bodyStream.writable) { bodyStream.cork(); bodyStream.write(data); bodyStream.uncork(); } } while (data !== 'End'); } catch (e) { ctx.logger.error(e); } finally { if (!bodyStream.destoryed &amp;&amp; bodyStream.writable) { bodyStream.end(''); } } }); }} 测试结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 下载到一半的时候出错的情况curl -vv http://127.0.0.1:7001/api/v1/loop-export-file* Trying 127.0.0.1...* TCP_NODELAY set* Connected to 127.0.0.1 (127.0.0.1) port 7001 (#0)&gt; GET /api/v1/loop-export-file HTTP/1.1&gt; Host: 127.0.0.1:7001&gt; User-Agent: curl&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Content-Type: text/plain; charset=utf-8&lt; Content-Disposition: attachment; filename=&quot;LoopExportFile.txt&quot;&lt; Transfer-Encoding: chunked&lt; x-content-type-options: nosniff&lt; x-frame-options: SAMEORIGIN&lt; x-xss-protection: 1; mode=block&lt; x-download-options: noopen&lt; x-readtime: 10&lt; Connection: keep-alive&lt; Keep-Alive: timeout=5&lt;StartGet data success at 3006msGet data success at 7008msGet data success at 12021msGet data success at 15036msGet data success at 18049msget data fail, Error: Random error* Connection #0 to host 127.0.0.1 left intact# 下载成功完成curl -vv http://127.0.0.1:7001/api/v1/loop-export-file* Trying 127.0.0.1...* TCP_NODELAY set* Connected to 127.0.0.1 (127.0.0.1) port 7001 (#0)&gt; GET /api/v1/loop-export-file HTTP/1.1&gt; Host: 127.0.0.1:7001&gt; User-Agent: curl&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Content-Type: text/plain; charset=utf-8&lt; Content-Disposition: attachment; filename=&quot;LoopExportFile.txt&quot;&lt; Transfer-Encoding: chunked&lt; x-content-type-options: nosniff&lt; x-frame-options: SAMEORIGIN&lt; x-xss-protection: 1; mode=block&lt; x-download-options: noopen&lt; x-readtime: 11&lt; Connection: keep-alive&lt; Keep-Alive: timeout=5&lt;StartGet data success at 5007msGet data success at 8009msGet data success at 13018msGet data success at 17020msGet data success at 20034msGet data success at 24042msEnd* Connection #0 to host 127.0.0.1 left intact","link":"/2018/09-17-egg-chunked-data/"},{"title":"Egg和koa中间件分析","text":"前言最近有个项目需要实现一个简单的用于转发服务端, 调研过后决定使用Egg.js来开发, 它是基于Koa又封装了一层支持插件和多进程的企业级框架, 可以减少很多初期的踩坑成本 在启动好初步的框架后, 面临的最初两个问题就是 没有很方便的统一返回码和错误处理方案 如果一个接口同时支持body和query-string, 取值方式会不一样 经过对koa的初步研究之后, 决定使用中间件来实现这两个功能 koa中间件原理在github上翻一下koa的源码, 发现它的内部实现极其简单, 只有四个类型的封装, 而对request的处理在一个非常简单的函数里就完成了 123456789101112class Application extends Emitter { // ... handleRequest(ctx, fnMiddleware) { const res = ctx.res; res.statusCode = 404; const onerror = (err) =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); } // ...} 看完相关资料之后才发现, koa的所有其他功能都是基于中间件做的, 比如koa-router就是在中间件中拦截匹配到的路径, koa-bodyparser是解析body的插件等 而koa的中间件是用compose函数来实现中间件调用和分发的, 仔细分析源码后发现实现非常巧妙, 通过闭包和二次封装实现了中间件顺序调用和传值 123456789101112131415161718192021222324function compose(middleware) { if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!'); for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!'); } return function (context, next) { // last called middleware # let index = -1; return dispatch(0); function dispatch(i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')); index = i; let fn = middleware[i]; if (i === middleware.length) fn = next; if (!fn) return Promise.resolve(); try { return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err); } } };} 开发中间件merge-request-args首先实现一个最简单的, 将body和query-string上来的参数统一到一起, 并以body优先 不过这里还是存在一个问题, 因为ctx.params是使用koa-router解析的, 而koa-router加载在此中间件之后, 所以在此中间件无法取到ctx.params的值, 尽量避免这种使用方式就行 1234567module.exports = (options) =&gt; { return async function mergeRequest(ctx, next) { // in this middleware cant find ctx.params ctx.args = Object.assign({}, ctx.request.query, ctx.request.body, ctx.request.form); return await next(); };}; wrapper这个中间件会复杂一点, 需要捕获内部调用的报错, 并提供统一的结构返回给前端. 而正常的返回值也需要一层填充 这里后续有个优化的部分, 在此处直接使用返回值数组解析了code和msg, 实际上可以封装一个class来处理这种情况就行, 如果需要返回特殊的code和msg, 判断返回值是否这个class实例即可 12345678910111213141516171819202122232425262728async function wrapper(ctx, next) { try { let result = await next(); // !! 接口不要直接返回array, 会造成这里判断有误 if (!ctx.body &amp;&amp; !_.isUndefined(result)) { if (_.isArray(result)) { let [_result, code = 200, msg = ''] = result; ctx.body = ctx.wrap({ data: _result, code, msg }); } else { ctx.body = ctx.wrap({ data: result }); } } return result; } catch (e) { if (!_.isError(e)) { e = new Error(e); } ctx.logger.error(e); if (!ctx.res.finished) { result = ctx.wrap({ success: false, code: 500, msg: _.toString(e.message || e) }); if (ctx.app.config.env !== 'prod') { result.stack = e.stack || undefined; } ctx.body = result; ctx.status = 500; } }} 扩展 ctxabort在一般异常情况下, 可以直接使用throw new Error('msg')来返回异常信息, 但是如果需要特殊指定code和附带其他信息的时候, throw使用就不太方便了, 于是提供一个通用的ctx.abort方法 123456789101112131415161718192021module.exports = { abort(code = 500, error = '', data = null) { this.status = code; if (code === 404) { this.res.end(); } else { this.res.end( JSON.stringify({ success: false, errorcode: code, msg: error, data: data, time: Date.now(), trace_id: this.getTraceId(), }), ); } this.res.destroy(); throw new Error(_.isString(error.msg) ? error.msg : JSON.stringify(error.msg)); },}; validateegg官方推荐的是使用egg-validate插件来验证输入值是否正常, 但是此插件不会将验证错误的原因返回给前端, 于是封装ctx.validate用于字段校验 12345678910module.exports = { validate(rules, args, msg = `Validation Failed`) { const errors = this.app.validator.validate(rules, args); if (_.size(errors)) { throw new Error( [msg, ...errors.map(({ field, code, message }) =&gt; `[${field}] value [${_.get(args, field, '')}] is error:[${code}] ${message}`)].join('\\n'), ); } },};","link":"/2018/09-27-egg-middleware/"},{"title":"Egg日志系统完善","text":"Egg 日志系统完善Egg已经内置了比较全面的日志了, 比如common-error和egg-web等, 会自动把错误日志聚集到一起等, 但是还缺少后端服务里比较关键的一类: access_log, 以及node用于转发请求较多的情况下, 记录转发的其他请求日志:request_log. 而且现在服务基本都是部署在Docker容器中, Egg日志都是打印在本地磁盘上, 如果需要统一收集也会比较麻烦, 需要一个简单轻量的解决方案 自定义 logger 根据Egg的文档, 添加一个自定义logger非常简单, 只需要在config里添加相关配置, 使用时候获取就行了 同时记得打开前置代理模式, 我们的服务一般都会部署在负载均衡后面, 如果不打开获取的用户IP会是错误的 1234567891011121314// config.default.jsmodule.exports = (appInfo) =&gt; { config.customLogger = { accessLogger: { file: path.join(appInfo.root, 'logs', appInfo.name, 'access.log'), consoleLevel: 'DEBUG', }, requestLogger: { file: path.join(appInfo.root, 'logs', appInfo.name, 'request.log'), consoleLevel: 'DEBUG', }, }; config.proxy = true;}; access_log首先来看看接口访问日志如何实现, 在上一篇内容中已经介绍了中间件和开发了错误处理中间件, 那么访问日志就很简单了, 在此中间件中加上相关逻辑就行. 同时这里也会有个问题, 在此中间件之前的报错是无法收集到日志的, 比如csrf中间件, 实际使用中需要注意这个问题. 这里最开始是自动生成request_id, 后来发现我们的LBC有接入tracing, 于是在接入tracing后, 日志里也加入了相关内容, 做到日志全链路打通 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061module.exports = ({ level = 'DEBUG' }, app) =&gt; { const logger = app.getLogger('accessLogger'); return async function wrapper(ctx, next) { const now = new Date(); let access_log = { time: now.toISOString(), id: ctx.getTraceId(), remote_ip: ctx.ip || '', host: ctx.request.host, method: ctx.request.method, uri: ctx.href, user_agent: ctx.header['user-agent'] || '', http_referer: ctx.header.referer || '', status: 200, error: '', latency: 0, latency_human: '0', bytes_in: ctx.request.length || 0, bytes_out: 0, snapshot: LOG_UTILS.getValidateLogMap(ctx.args), response_body: {}, }; try { let result = await next(); // !! 接口不要直接返回array, 会造成这里判断有误 if (!ctx.body &amp;&amp; !_.isUndefined(result)) { if (_.isArray(result)) { let [_result, code = 200, msg = ''] = result; ctx.body = ctx.wrap({ data: _result, code, msg }); } else { ctx.body = ctx.wrap({ data: result }); } } return result; } catch (e) { if (!_.isError(e)) { e = new Error(e); } e.trace_id = ctx.getTraceId(); ctx.logger.error(e); if (!ctx.res.finished) { result = ctx.wrap({ success: false, code: 500, msg: _.toString(e.message) }); if (level == 'DEBUG') { result.stack = e.stack || undefined; } ctx.body = result; ctx.status = 500; } access_log.error = _.toString(e.message); } finally { access_log.status = ctx.status; const spendTime = Date.now() - now.getTime(); access_log.latency_human = `${spendTime}ms`; access_log.latency = spendTime * 1000000; const logStr = JSON.stringify(access_log); logger.log('INFO', [logStr], { raw: true }); } };}; 这里面稍微有点坑的地方在于logger.log, 如果不加第三个参数{ raw: true }会发现日志里会自动加上一些时间/进程/级别的头部信息, 导致此条日志不是一个合法的json格式, 解析起来会有问题. 最开始还担心改动起来比较麻烦, 查完源码后发现使用这个参数就能完美的解决这个问题了 request_log 当app启动的时候, 在app.httpclient相关事件中注入日志埋点数据 123456789101112131415161718192021222324class AppBootHook { constructor(app) { const requestLogger = app.getLogger('requestLogger'); app.httpclient.on('request', (req) =&gt; { req.__start_time = new Date(); }); app.httpclient.on('response', ({ req, res, ctx }) =&gt; { const http_log = { time: req.__start_time.toISOString(), id: ctx ? ctx.getTraceId() : '', method: req.options.method, uri: req.url, status: res.status, latency: res.rt * 1000000, latency_human: `${res.rt}ms`, bytes_in: req.size, request_time: res.rt, snapshot: this.getValidateLogMap(req.args.data), result: this.getValidateLogMap(res.data), }; logger.log('INFO', [JSON.stringify(http_log)], { raw: true }); }); }} rsyslog上面的两个日志内容开发完成后, 在运行时就能在本地/日志文件夹中看到对应的日志记录了, 现在面临的问题是, 如何把本地Docker容器的日志无缝发送到远端日志收集器中. 了解之后发现使用rsyslog是一个比较好的方案. Transport查看Egg文档后, 发现它有提供将日志打印到其他媒介上的很简单的方案: 实现transport, 同时还不会影响到本地日志打印, 先实现一下大概框架 12345678910111213141516171819202122232425262728// rsyslog-transport.jsclass RsyslogTransport extends Transport { constructor(options) { super(options); } log(level, args, meta) { const result = super.log(level, args, meta); // todo } close() { // todo }}// app.jsclass AppBootHook { constructor(app) { app.getLogger(loggerKey).set( 'rsyslog', new RsyslogTransport({ ...app.config.logger, level: logger.level, app, rsyslogConfig: { ...app.config.rsyslog.config }, }), ); }} node-rsyslog上面的内容开发完后, 发现自定义的日志传输通道就已经生效了, 剩下的就是将日志内容发送到远端的rsyslog-server中 但是试了下npm提供的rsyslog包之后, 发现它不支持TCP发送, 只支持UDP发送, 而且有些细节实现貌似和标准也不一致, 于是只能参考它自己实现一个node-rsyslog. 1234567891011121314151617181920212223242526272829303132333435const _ = require('lodash');const Transport = require('egg-logger').Transport;const { RSyslog, SEVERITY } = require('./tools/node-rsyslog');class RsyslogTransport extends Transport { constructor(options) { super(options); this.rsyslogConfig = options.rsyslogConfig; this.initRsysLog(); } initRsysLog() { this._rsyslog = new RSyslog(this.rsyslogConfig); this._rsyslog.on('error', (err) =&gt; { this.options.app.logger.error(err); this._rsyslog = null; if (!this._rsyslog_timer) { // 实现简单的自动重连, 但是消息丢了不会重发 this._rsyslog_timer = setTimeout(() =&gt; { this.initRsysLog(); this.options.app.logger.info(`Reconnect rsyslog server`); this._rsyslog_timer = null; }, 1000); } }); } log(level, args, meta) { const result = super.log(level, args, meta); this._rsyslog &amp;&amp; this._rsyslog.send(SEVERITY.NOTICE, _.trim(result).replace(/\\r?\\n/gi, ' ')); } close() { this._rsyslog &amp;&amp; this._rsyslog.disconnect(); }}module.exports = RsyslogTransport; 整合最后就剩下将rsyslog的配置抽离到config文件中了, 并且实现不同的日志打印到不同的facility中 123456789101112131415161718192021222324252627282930313233343536373839404142// config.jsmodule.exports = (appInfo) =&gt; { config.rsyslog = { enable: true, config: { host: '', port: 0, method: 'TCP', appname: `${appInfo.name}-${config.appEnvTag}`, hostname: os.hostname(), procid: process.pid, }, logger: { logger: { appname: `${appInfo.name}-egg`, facility: FACILITY.local0 }, coreLogger: { appname: `${appInfo.name}-${config.appEnvTag}-core`, facility: FACILITY.local0 }, errorLogger: { appname: `${appInfo.name}-${config.appEnvTag}-error`, facility: FACILITY.local0 }, scheduleLogger: { appname: `${appInfo.name}-${config.appEnvTag}-schedule`, facility: FACILITY.local0 }, accessLogger: { appname: `${appInfo.name}-${config.appEnvTag}-access`, facility: FACILITY.local2 }, requestLogger: { appname: `${appInfo.name}-${config.appEnvTag}-request`, facility: FACILITY.local4 }, }, };};// app.jsclass AppBootHook { constructor(app) { if (app.config.rsyslog.enable) { _.map(app.config.rsyslog.logger, (loggerConfig, loggerKey) =&gt; { const logger = app.getLogger(loggerKey); logger.set( 'rsyslog', new RsyslogTransport({ ...app.config.logger, level: logger.level, app, rsyslogConfig: { ...app.config.rsyslog.config, ...loggerConfig }, }), ); }); } }} 日志收集在Docker中直接启动rsyslog, 然后在config文件中配置好地址后, 就可以在有日志的时候, 同步看见rsyslog服务器中的日志打印, 日志收集器也只需要在此机器上采集日志存储到ELK","link":"/2018/10-16-egg-logger/"},{"title":"Next 动态页面","text":"背景最近需要开发一套有通用流程的页面, 但是有各自的样式和交互, 不能直接通过css来实现, 所以需要研究动态加载的方案. 同时这个页面又是直接给到外部用户使用的, 所以选择服务端渲染比较好, 最终选择Next.js来实现这套框架 流程图graph LR A[用户] -->|访问| B1(站点A) A[用户] -->|访问| B2(站点B) A[用户] -->|访问| B3(站点C) B1 --> C(Next.js) B2 --> C B3 --> C C -->|请求| D[Node Server] D -->|请求| E[Backend] 开发环境解决方案面临的主要的问题有: 使用同一套前端公用组件库 前端web只需要部署一套 前端封装一个通用的请求, 所有页面复用, 便于维护 看了文档之后, 发现Next自带dynamic方法解决动态加载组件的问题, 于是问题就比较简单了, 生成一份对应的配置文件即可, 访问的时候本地配置Host指定域名访问就行 12345678910111213141516171819// sites.config.jsimport dynamic from 'next/dynamic';export default { sites: { siteA: { hosts: ['site-a.local.com:3000'], page: dynamic({ loader: () =&gt; import('./views/site-a'), }), }, siteB: { hosts: ['site-b.local.com:3000'], page: dynamic({ loader: () =&gt; import('./views/site-b'), }), }, },}; 1234567891011121314151617181920212223242526272829303132333435363738// pages/index.jsimport React from 'react';import Head from 'next/head';import Link from 'next/link';import axios from 'axios';import config from '../site.config';function getSiteIdFromHost(host) { for (const site of Object.keys(config.sites)) { const hosts = config.sites[site].hosts; if (hosts.includes(host)) { return site; } } return null;}export default class extends React.Component { static async getInitialProps(props) { const { isServer, req } = props; const site = getSiteIdFromHost(req ? req.headers.host : window.location.host); return { site, }; } render() { const { site } = this.props; const SitePage = config.sites[site]; return ( &lt;div&gt; &lt;SitePage /&gt; &lt;Link href='/cowsay' prefetch&gt; &lt;a&gt;cowsay&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; ); }} 正式环境打包部署最初是直接把next部署到服务器上提供访问, 那么和开发版本没有多大区别, 但是后面后期优化想要打包成静态文件的版本, 那么就需要解决打包时的站点区分了, 实现原理很简单, 通过环境变量指定打包的项目, 并分别输出即可 123456789101112// 修改获取Host代码, 兼容静态打包生成/服务端渲染/客户端渲染方式let host = '';if (process.env &amp;&amp; process.env.BUILD_HOST) { host = process.env.BUILD_HOST;}if (!host &amp;&amp; req &amp;&amp; req.headers &amp;&amp; req.headers.host) { host = req.headers.host;}if (!host) { host = window.location.host;} 123# 修改package.json, 添加导出不同站点的命令&quot;export-site-a&quot;: &quot;cross-env BUILD_HOST='site-a.local.com' next export -o ./out-site-a&quot;,&quot;export-site-b&quot;: &quot;cross-env BUILD_HOST='site-b.local.com' next export -o ./out-site-b&quot;, 这样打包过后, 不同站点部署在不同文件夹就没问题了, 接口层再统一通过 nginx 转发, 达成首页秒开的效果. 但是最后存在一个不够完美的地方, next的webpack在打包输出的时候, 会将其他站点的.js文件同样打包出来, 虽然不会实际加载到, 但是会影响打包速度, 以后有空了可以看看如何通过webpack插件解决这个问题","link":"/2018/11-13-next-dynamic-page/"},{"title":"Eggjs接入Jaeger和OpenTracing","text":"背景OpenTracing是一套标准的分布式链路追踪协议, 主要概念有Trace和Span两个类型, 功能比较全面, 在业界内使用比较广泛, 由于我们这边的服务也存在长链路互相调用的过程, 接入OpenTracing后可以很方便的分析调用过程 Jaeger是Uber开发的分布式追踪系统, 兼容OpenTracing标准, 我们基于它来搭建整个服务 数据流由于我们的接口可能是被前端直接调用, 也可能是由其他服务调用过来的, 那么我们需要在请求解析中加入判断是否正在一个trace中, 如果不在, 那么需要自己创建一个trace 同时, 我们的服务端也需要调用其他的后端服务, 那么我们需要在调用时传递给其他服务完整的trace信息, 并做好相关记录, 实现完整的链路追踪 Egg 接入 在Egg.js启动时, 我们将tracer实例注入到app中, 这样可以在全局任意地方都可以获取使用 在全局中间件中加入trace相关判断和日志上传, 中间件开发可以参考此文档 在app.httpclient的相关事件中加入对应header, 即可将目前的trace信息传给其他服务 由于内部服务互通, 所以用的不是标准的trace-header, 这里用x-custom-trace-id来代替 12345678910111213141516171819202122232425262728293031323334353637383940// app.js - 全局注入`tracer`实例和`app.httpclient`事件class AppBootHook { constructor(app) { this.app = app; if (app.config.jaeger.enable) { jeagetUtils.setupJaegerClient(app); } }}// jeagetUtilsconst Jaeger = require('jaeger-client');class JaegerUtils { constructor() {} setupJaegerClient(app) { const { config, options } = app.config.jaeger; app.tracer = Jaeger.initTracer(config, options); app.httpclient.on('request', (req) =&gt; { req.reqSpan = req.ctx.startSpan(req.url); const traceId = req.reqSpan._spanContext.toString(); req.args.headers = { ...req.args.headers, 'x-custom-trace-id': traceId, }; }); app.httpclient.on('response', ({ req, res, ctx }) =&gt; { if (req.reqSpan) { req.reqSpan.setTag('status', res.status); req.reqSpan.finish(); } }); }}const jeagetUtils = new JaegerUtils();module.exports = jeagetUtils; 在ctx里封装相关trace方法, 方便外部调用, 并保存rootSpan 12345678910111213141516171819202122232425262728293031323334353637383940// extend/context.jsmodule.exports = { getTraceId() { if (!this.__trace_id) { this.__trace_id = this.header['x-custom-trace-id'] || uuidv4().replace(/-/gi, ''); } return this.__trace_id; }, createRootSpan(operationName) { if (!this.app.tracer) { return null; } if (!this.__rootSpan) { const lbcSpan = this.app.tracer.extract(FORMAT_HTTP_HEADERS, { 'x-custom-trace-id': this.getTraceId(), }); this.__rootSpan = this.app.tracer.startSpan(operationName, { childOf: lbcSpan }); } return this.__rootSpan; }, startSpan(operationName = '', options = {}) { if (!this.app.tracer) { return null; } if (!options.childOf) { if (!this.__rootSpan) { this.app.logger.error(`Not found root span`); } else { options.childOf = this.__rootSpan; } } if (!operationName) { this.app.logger.error(`Not set operationName`); operationName = 'unknow'; } return this.app.tracer.startSpan(operationName, options); },}; 在wrapper里创建rootSpan, 并最终完成trace记录 123456789101112131415161718// wrapper.jsmodule.exports = (config, app) =&gt; { return async function wrapper(ctx, next) { const rootSpan = ctx.createRootSpan(ctx.path); try { let result = await next(); return result; } catch (e) { // ... } finally { if (rootSpan) { rootSpan.setTag('status', ctx.status); rootSpan.finish(); } } };}; 定时任务上面步骤完成之后, 外部发起的请求已经可以完整的打印调用链路日志了, 但是内部的定时任务调用因为不走wrapper中间件, 所以没有rootSpan, 就无法记录trace信息 这个问题解决起来也很简单, 我们只需要在schedule初始化的时候创建rootSpan就行 1234567891011121314151617181920// schedule/test-task.jsmodule.exports = (app) =&gt; { return { schedule: { immediate: false, type: 'worker', }, async task(ctx) { const rootSpan = ctx.createRootSpan(`test-task`); const startTime = Date.now(); const job = new Job(ctx, app); await job.do(); app.logger.info(`use time: ${Date.now() - startTime}ms to finish test-task`); if (rootSpan) { rootSpan.finish(); } }, };}; 搭建 jaeger代码开发完成之后, 我们需要测试一下整体流程和观察一下数据上报的效果, 需要自己搭建一个测试的Jaeger服务, 由于Jaeger提供Docker镜像, 这一步也非常简单, 参考官方命令启动即可 123456789docker run -d --name jaeger-all-in-one \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 14250:14250 \\ jaegertracing/all-in-one 然后将配置的collectorEndpoint指向本地服务, 将采样率调整为1, 打开http://localhost:16686, 随便造几个请求, 就能看到完整的链路调用信息了","link":"/2018/11-19-egg-jaeger/"},{"title":"Eggjs实现通用可定制化服务","text":"背景在开发一些通用服务的情况下, 往往会有不可避免的出现一些特殊条件下的定制需求, 这种情况下比较常见的有三种实现模式 暴力开发: 使用if/else填充逻辑 面向对象抽象实现: 使用接口或继承实现特殊条件下的逻辑处理 定制插件: 在主要代码中加入相关生命周期和hooks入口, 使用不同插件去hook各自需要处理的地方, 耦合性较小, 开发成本较高 对于我目前项目的需求特点来说, 有基本明确统一的流程, 而且是用于后端服务, 不会有太多特殊处理的地方, 使用方案2会是比较合理的选择, 接下来就是看看基于egg如何比较优雅的实现 开发router既然是通用服务, 对外暴露的api接口最好是稳定和一致的, 直接按常规定义路由即可. 如何区分项目条件后续再处理. 123// router.jsrouter.get(`${urlPrefix}/info`, controller.api.getInfo);router.get(`${urlPrefix}/list`, controller.api.getList); middleware请求在经过router之前, 就会经过全局middleware处理, 随后再经过router指定的中间件, 但是它们本质上是不会互相影响的, 而且对外往往考虑是先看router, 所以将middleware写在router之后也没有太大的理解问题 在此中间件中需要区分出具体的请求来源和条件, 因为服务前面有一层nginx, 所以选择了简洁的配置方案: 通过http-header传参来区分具体项目, 对于nginx转发配置起来也非常简单, 也便于调试 这里使用http-header来传参的原因是因为项目不会特别大, 为了节省成本只会部署一套通用服务. 如果是用于大型项目的情况下, 更好的方案是通过环境变量在启动时指定服务项目参数, 就不需要通过nginx和其他配置来指定项目了 123// middleware/wrapper.jsctx.project = ctx.header['x-project'];ctx.validate(ctx.project); // 验证是否符合 controllerrouter已经将所有同类的请求都转发到了controller/api.js, middleware也已经区分好了访问的项目, 然后分发的逻辑在这里处理就会非常简单 12345678910111213141516// controller/api.jsclass ApiController extends Controller { get projectService() { const service = this.service[`${this.ctx.project}ProjectApi`]; if (!service) { return this.service.commonApi; } return service; } async getInfo() { return await this.projectService.getInfo(); } async getList() { return await this.projectService.getList(); }} serviceservice的架构是通用与可定制化的核心, 将基础服务用baseService实现, 其他定制服务继承它, 实现需要定制的接口 用继承还有个好处是方便代码编辑器自动给出方法提示 123456789101112131415161718192021// service/common-api.jsclass CommonApiService extends Service { get projectConfig() { return this.app.config.projectConfig[this.ctx.project]; } async getInfo() { return info; } async getList() { return list; }}// service/test-project-api.jsclass TestProjectService extends CommonApiService { async getInfo() { const info = await super.getInfo(); // 自定义修改逻辑 return info; }} config可以看到在service中, 有个读取不同项目的配置的地方, 配置的加载和管理也是比较简洁的方案 1234567891011121314151617181920212223// config/config.default.jsconst projectConfig = require('./project.config.default');config.projectConfig = projectConfig(appInfo);// config/project.config.default/index.jsconst testproject = require('./testproject');module.exports = (appInfo) =&gt; { const projectConfig = (exports = {}); projectConfig.testproject = testproject(appInfo); return projectConfig;};// config/project.config.default/testproject.jsmodule.exports = (appInfo) =&gt; { return { project: 'testproject', host: 'testproject-host', };}; nginx最后补充一下nginx的自定义header的配置方法, 部署在不同地方的nginx的header头可以根据环境变量在启动时设置进去, 也可以根据server或者其他参数固定写入 12345678# default.conflocation /api/v1/ { proxy_pass http://api-server:7001; proxy_set_header X-project &quot;testproject&quot;; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect default;} 测试unittest由于使用header来作为区分方案, 那么单元测试实现也会非常简单和稳定 如果需要只测试某个项目, 可以指定测试参数: npm run test ./test/app/controller/api/testproject.test.js 1234567891011121314151617181920212223242526272829303132333435363738394041// test/app/controller/api/common.test.jsconst project = path.basename(__filename, '.test.js');describe(`test/app/controller/${project}.test.js`, () =&gt; { const urlPrefix = '/api/v1'; let app; let job; before(async () =&gt; { const _init = await init(); app = _init.app; job = _init.job; }); it(`should GET GAME: ${project} [getInfo] ${urlPrefix}/getInfo`, async () =&gt; { const req = await app.httpRequest().get(`${urlPrefix}/getInfo`).query(reqdata).set('x-project', project); assert.ok(_.isString(req.body.data), `response result is '${req.body.data}'`); assert.ok(_.isString(req.body.data), `response result is '${req.body.data}'`); });});// test/app/controller/api/testproject.test.jsconst project = path.basename(__filename, '.test.js');describe(`test/app/controller/${project}.test.js`, () =&gt; { const urlPrefix = '/api/v1'; let app; let job; before(async () =&gt; { const _init = await init(); app = _init.app; job = _init.job; }); it(`should GET GAME: ${project} [getInfo] ${urlPrefix}/getInfo`, async () =&gt; { const req = await app.httpRequest().get(`${urlPrefix}/getInfo`).query(reqdata).set('x-project', project); assert.ok(_.isString(req.body.data), `response result is '${req.body.data}'`); assert.ok(_.isString(req.body.data), `response result is '${req.body.data}'`); });}); 小结这串流程下来就实现了一个既满足通用性, 又支持高度定制化的可复用的项目框架, 在用于通用的对内/对外服务上可以实现快速稳定的开发迭代","link":"/2018/11-26-egg-multi-server/"},{"title":"Eggjs使用agent实现pub&#x2F;sub配置同步","text":"背景开发项目过程中一般需要维护一个统一的配置缓存, 以及监听配置缓存变动, 在Java等语言中可以使用全局单例模式实现, 但是在Node中因为每个进程是独立的运行环境, 所以需要有个其他的解决方案, 下面来看看在Egg中如何优雅的实现配置同步 原理Egg内置实现的进程模型分为三个角色: Master、Agent、Worker, 而其中每个Worker自己的运行环境是独立的, 而且是不稳定的, 如果由每个Worker自己订阅配置和变更, 消耗会比较高, 所以Egg官方更推荐的是在Agent里处理 Master VS Agent VS Worker当一个应用启动时，会同时启动这三类进程。 类型 进程数量 作用 稳定性 是否运行业务代码 Master 1 进程管理，进程间消息转发 非常高 否 Agent 1 后台运行工作（长连接客户端） 高 少量 Worker 一般设置为 CPU 核数 执行业务代码 一般 是 架构设计sequenceDiagram participant C as ConfigManager participant R as Redis participant A as Agent participant W as Worker alt 首次启动 C -->> R: 0. 写入原始配置 R ->> A: 1. Agent启动, subscribe redis A ->> W: 2. Worker启动, 监听Agent下发事件 R ->> W: 3. Worker拉取redis最新配置 W -->> W: 4. Worker将配置写入本地 end alt 配置更新 C ->> R: 5. config修改, 写入redis C ->> R: 6. redis.publish(), 发送消息 R ->> A: 7. redis通知Agent R -->> C: 8. redis返回接收到的客户端数量 R ->> A: 9. Agent从redis获取最新配置 A ->> W: 10. Agent通知Worker更新配置 W -->> W: 11. Worker加载最新配置 end 开发由于Egg官网提示, 需要等到Worker启动成功后才能使用进程间通信, 所以在app.js启动时候需要主动直接去Redis里获取一份当前最新配置, 同时订阅Agent下发的事件 如果在worker启动的时候通过messenger通信是能成功的, 但是会出现如下warning: agent can't call sendTo before server started app.js12345678910111213141516171819'use strict';class AppBootHook { constructor(app) { this.app = app; console.log(`app pid: ${process.pid}`); } async willReady() { this.app.messenger.on('push_config', (data) =&gt; { this.logger.info(`Received push_config data: [${JSON.stringify(data)}]`); this.app.customConfig = data.config; }); this.app.customConfig = JSON.parse(await this.app.redis.get('CONFIG')); } async didReady() {} async serverDidReady() {}}module.exports = AppBootHook; agent.js12345678910111213141516171819202122232425262728293031323334'use strict';class AgentHook { constructor(agent) { this.agent = agent; console.log(`agent pid: ${process.pid}`); } configWillLoad() {} configDidLoad() {} async willReady() { await new Promise((resolve, reject) =&gt; { const client = this.agent.redis.duplicate(); client.on('message', async (channel, message) =&gt; { this.logger.info(`Received subscribe message, channel [${channel}] message [${message}]`); this.agent.messenger.sendToApp('push_config', { config: JSON.parse(await this.agent.redis.get('CONFIG')) }); }); client.on('ready', () =&gt; { client.subscribe(this.agent.config.redisConfigChannel, (err, count) =&gt; { this.logger.info(`Subscribe channel ${this.agent.config.redisConfigChannel}, error: ${err}, count: ${count}.`); }); this.logger.info('Redis is connected and ready use.'); resolve(); }); client.on('error', (err) =&gt; { this.logger.error(`Redis is error. Error: ${err}`); reject(err); }); }); } async didReady() {} async serverDidReady() {}}module.exports = AgentHook;","link":"/2018/12-26-egg-agent-redis-sub/"},{"title":"Nginx使用geoip模块识别客户端地区","text":"前言想根据IP获取用户所在地点有各种方案, 今天来介绍一下比较简单和无侵入性的一种: 通过nginx插件自动识别IP地区 Dockerfile现在的nginx镜像里已经都自带了ngx_http_geoip_module.so模块, 位于/etc/nginx/modules/目录下, 所以我们只需要参考文档, 将需要的GeoIP.dat数据包打入镜像, 并配置好参数即可 12345678FROM nginx:stableRUN apt-get update &amp;&amp; apt-get install -y vim less curlCOPY ./conf/ip.mmdb /home/var/data/ip.mmdbCOPY ./conf/nginx.conf /etc/nginx/nginx.confCOPY ./conf/default.conf /etc/nginx/conf.d/default.conf nginx 配置123456789101112131415161718# nginx.conf# 加载geoip模块load_module &quot;modules/ngx_http_geoip_module.so&quot;;http { # ...}# default.confgeoip_country /home/var/data/ip.mmdb;location /api/v1 { proxy_set_header x-country-code $geoip_country_code; # ...} 配置完成之后启动nginx镜像, 就可以在后端转发的服务header中获取到用户地区了 结论这种方案是对后端比较友好的一种方式, 由于nginx一般在负载均衡的最前端, 所以可以拿到最准确的用户IP, 对后端也没有侵入性修改, 而且由于是nginx本地数据提供的解析, 非常方便扩容, 数据的更新和维护也比较方便, 是一种比较轻量的解决方案 参考文档: http://nginx.org/en/docs/http/ngx_http_geoip_module.html","link":"/2019/01-14-nginx-geoip/"},{"title":"Eggjs实现通用化sql查询","text":"背景Egg官方推荐的mysql使用方法是类似orm的方式, 但是这种方式对于复杂查询或者表结构的调整来说不太友好, 于是试着开发一套直接基于sql语句的友好的开发方式, 类似Java的MyBatis 框架设计sql统一管理首先需要将SQL文件统一管理, 不能散落在各Service中, 否则极其不好维护. 然后通过node的动态require实现自动加载文件夹下的所有sql文件, 合并sql数据, 同时给每个查询分配唯一ID, 在启动时就能检测如果有重复ID直接启动报错, 这样保证线上运行不会有问题 123456789101112131415161718192021222324252627282930// app/sql/index.jsconst fs = require('fs');const path = require('path');const _ = require('lodash');const sqls = {};fs.readdirSync(__dirname).map((filename) =&gt; { if (filename == 'index.js') { return; } const filepath = path.join(__dirname, filename); const sql = require(filepath); if (!_.isObject(sql)) { throw new Error('Sql file need export an OBJECT of sql map'); } for (const id in sql) { if (sqls[id]) { throw new Error('Duplicate sql id'); } } Object.assign(sqls, sql);});module.exports = (id) =&gt; { if (sqls[id]) { return sqls[id]; } throw new Error(`Not found sql: ${id}`);}; 实现sql-service考虑到比较多简单查询或者列表通用查询等实际上是可以由页面直接发起的, 可以在做好参数校验的情况下直接提供查询入口, 但是对于修改数据的需求也是需要后端逻辑验证后才能执行, 所以在sql-service层提供不同的入口和方式, 以及在sql文件中定义好支持的类型 参考js的通用做法, 约定以_.开头的文件和sql是只有服务端内部才能调用的 sql, 其他的都可以由页面直接调用 12345678910111213141516171819202122232425262728293031323334// app/sql/index.js - 加上 private-sql 校验const fs = require('fs');const path = require('path');const _ = require('lodash');const sqls = {};fs.readdirSync(__dirname).map((filename) =&gt; { if (filename == 'index.js') { return; } const fileIsPrivate = filename.startsWith('_.'); const filepath = path.join(__dirname, filename); const sql = require(filepath); if (!_.isObject(sql)) { throw new Error('Sql file need export an OBJECT of sql map'); } for (const id in sql) { if (sqls[id]) { throw new Error('Duplicate sql id'); } if (id.startsWith('_.') !== fileIsPrivate) { throw new Error(`Private sql error, file: ${filename}, sql: ${id}`); } } Object.assign(sqls, sql);});module.exports = (id) =&gt; { if (sqls[id]) { return sqls[id]; } throw new Error(`Not found sql: ${id}`);}; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// app/service/sql-base.js'use strict';const _ = require('lodash');const Service = require('egg').Service;const getSql = require('./../sql');class SqlBaseService extends Service { getSql(sqlId, params, env, _private = false) { if (_.startsWith(sqlId, '_.') &amp;&amp; !_private) { this.ctx.abort(404, 'Not Found'); } const sql = getSql(sqlId); let result = null; if (_.isString(sql)) { result = sql; } if (_.isFunction(sql)) { result = sql(params, this.ctx); } if (!result) { throw new Error('sql need be string or function'); } return result; } async queryBySql(sql, params) { return await this.app.mysql.query(sql, { ...params, ...this.env }); } async query(sqlId, params, _private) { const sqlSpan = this.ctx.startSpan(sqlId); const result = await this.queryBySql(this.getSql(sqlId, params, this.env, _private), params); if (sqlSpan) { sqlSpan.setTag('status', 200); sqlSpan.finish(); } return result; } // 对外直接提供的接口, 不支持查询私有sql async apiGetData() { const { ctx, ctx: { args }, } = this; const { params, sqlId } = args; return [await this.query(sqlId, params)]; }} 上面两步完成之后, 就完成了主体框架的搭建, 后续的内容就是完善缺少的功能 补充功能条件/参数化查询最常见的需求: 某字段不传则不要作为where的过滤条件 在其他语言中, 这种往往通过模板字符串渲染来解决, 但是在es6中引入的模板字符串, 可以非常完美的解决这个问题 12345678910111213141516171819202122// app/service/sql-base.jsclass SqlParams { constructor(params, env) { this.data = { ...params, ...env }; } exist(key) { return _.has(this.data, key); } setIfExist(key, str, notExistStr) { const flag = _.isBoolean(key) ? key : this.exist(key); return flag ? str : notExistStr || ''; }}class SqlBaseService extends Service { getSql(sqlId, params, env, _private = false) { // ... params = new SqlParams(params, env); result = sql(params, this.ctx); // ... }} 这样在sql文件中的写法会非常优雅 12345678910111213// test.sqlmodule.exports = { 'test_common.query': (params, ctx) =&gt; { return ` SELECT name FROM table WHERE 1 = 1 ${params.setIfExist('name', `AND name LIKE CONCAT('%', :name, '%')`)} `; },}; 环境变量注入也是比较常见的需求, 需要在执行查询时候直接获取当前用户和项目或者其他配置等, 上面的代码中已经带上env变量了, 这里只写一下它的生成过程 这里的no_env是提供给如schedule或测试的时候用的参数 123456789101112131415161718192021222324252627282930// app/service/sql-base.jsclass SqlBaseService extends Service { get env() { const { ctx } = this; return ctx.no_env ? { env_user: '_system', env_project: '_system', } : { env_user: ctx.user.name, env_project: ctx.user.project, }; }}// test.sqlmodule.exports = { 'test_common.query': (params, ctx) =&gt; { return ` SELECT name FROM table WHERE 1 = 1 AND create_user = :env_user ${params.setIfExist('name', `AND name LIKE CONCAT('%', :name, '%')`)} `; },}; 支持事务/切换数据库这个也非常常见和简单, 我们将conn作为参数一路透传, 最终传入sql执行器即可 12345678910111213141516171819202122class SqlBaseService extends Service { async queryBySql(sql, params, conn) { conn = conn || this.app.mysql; return await conn.query(sql, { ...params, ...this.env }); }}// 使用const conn = await this.app.mysql.getConnection();try { await conn.beginTransaction(); await this.query(`_.test`, { name: 'test' }, true, conn); await this.query(`_.test.2`, { name: 'test' }, true, conn); await conn.commit(); return { success: true };} catch (err) { await conn.rollback(); throw err;} finally { await conn.release();} 支持自动分页/排序接口这个接口基本上是提供给前端列表页面使用的, 会稍微复杂点, 而且对于各种db需要一些定制化开发, 核心原理就是根据原始sql自动生成统计的sql 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class SqlBaseService extends Service { async queryListByPage(sqlId, params, page, size, order, direct, _private, conn) { // page start from 0 const realSql = this.getSql(sqlId, params, this.env, _private); const countSql = this.resolveCountSql(realSql); const pageSql = this.resolvePageSql(realSql, _.toSafeInteger(page), _.toSafeInteger(size), order, direct); const [list, count] = await Promise.all([this.queryBySql(pageSql, params, conn), this.queryBySql(countSql, params, conn)]); return { data: list, total: count[0].num, }; } resolveCountSql(sql) { const SELECT = 'select'; const FROM = 'from'; let countSql = sql; if (sql.match(new RegExp(`\\\\s+${FROM}\\\\s+`, 'ig')).length === 1) { countSql = sql.replace(new RegExp(`^(\\\\s*${SELECT}\\\\s+?)(\\\\S[\\\\s\\\\S]+?\\\\S)(\\\\s+?${FROM}\\\\s+?)`, 'ig'), '$1 count(1) as num $3'); } else { const selectMatch = sql.match(new RegExp(`^(\\\\s*${SELECT}\\\\s+?)`, 'ig')); let selectPos = selectMatch[0].length; let fromPos = 0; let level = 0; for (let i = selectPos; i &lt; sql.length; i++) { const char = sql[i]; if (char === '(') { level++; } if (char === ')') { level--; } if (level &lt; 0) { throw new Error('error sql when parse count all: level less 0'); } if (level === 0 &amp;&amp; char.toLowerCase() === FROM[0] &amp;&amp; sql.slice(i, i + 4).toLowerCase() === FROM &amp;&amp; /\\s\\s/gi.test(sql[i - 1] + sql[i + 4])) { fromPos = i; break; } } if (!fromPos) { throw new Error('error sql when parse count all: not found FROM'); } countSql = `${sql.slice(0, selectPos)} count(1) as num ${sql.slice(fromPos)}`; } return countSql; } resolvePageSql(sql, page, size, order, direct) { const start = size * (page - 1); let pageSql = sql.trimRight(); if (pageSql.endsWith(';')) { pageSql = pageSql.substring(0, pageSql.length - 1); } if (/^[a-z0-9_]+$/i.test(order)) { direct = _.toLower(direct) === 'asc' ? 'asc' : 'desc'; } else { order = null; } pageSql = `select * from (${pageSql}) t_auto_page ${order ? `order by ${order} ${direct}` : ``} limit ${start}, ${size};`; return pageSql; } // 提供给前端直接使用的api接口 async apiGetDataByPages() { const { ctx, ctx: { args }, } = this; const { page = 1, size = 10, order = '', direct = '' } = args.page || {}; const { params, sqlId } = args; return await this.queryListByPage(sqlId, params, page, size, order, direct); }} 支持前端批量查询和事务12345678910111213141516171819202122232425262728293031323334class SqlBaseService extends Service { async batchQuery(sqlId, params, _private) { const conn = await this.app.mysql.getConnection(); try { await conn.beginTransaction(); const results = []; for (let i = 0; i &lt; Math.max(_.isArray(sqlId) ? sqlId.length : 0, params.length); i++) { const _params = _.get(params, i); const _sqlId = _.isArray(sqlId) ? sqlId[i] : sqlId; const result = await this.query(_sqlId, _params, _private, conn); if (result.affectedRows &amp;&amp; result.changedRows) { results.push(_.pick(result, ['affectedRows', 'changedRows', 'insertId'])); } else { results.push(result); } } await conn.commit(); return results; } catch (err) { await conn.rollback(); throw err; } finally { await conn.release(); } } async apiExecBatchQuery() { const { ctx, ctx: { args }, } = this; const results = await this.batchQuery(args.sqlId, args.params); return [results]; }} 权限验证直接基于ctx上提供的权限验证方法即可实现 1234567891011121314151617// test.sqlmodule.exports = { 'test_common.insert': (params, ctx) =&gt; { ctx.validPermission('super_admin'); return ` INSERT INTO table ( name, create_user ) VALUES ( :name, :env_user, ); `; },}; 操作日志统一埋点基于框架中之前开发的log中间件添加一下sql相关日志即可 这里有个比较巧妙的方法实现自动获取当前的sql_id, 是通过Error.prepareStackTrace来实现的 12345678910111213141516171819202122232425262728293031323334353637383940// app/extend/context.jsmodule.exports = { callsites() { const _prepareStackTrace = Error.prepareStackTrace; Error.prepareStackTrace = (error, structuredStackTrace) =&gt; structuredStackTrace; const stack = new Error().stack.slice(1); Error.prepareStackTrace = _prepareStackTrace; return stack; }, addSqlLog(action, params) { this.sqlLog = this.sqlLog || {}; const stack = this.callsites(); const sqlId = stack[1].getFunctionName(); if (sqlId) { this.sqlLog[sqlId] = this.sqlLog[sqlId] || { action, params: [], }; this.sqlLog[sqlId].params.push(params); } },};// test.sqlmodule.exports = { 'test_common.insert': (params, ctx) =&gt; { ctx.validPermission('super_admin'); ctx.addSqlLog(`table表新增内容`, `[name: ${params.data.name}]`); return ` INSERT INTO table ( name, create_user ) VALUES ( :name, :env_user, ); `; },}; 小结以上功能开发完之后, 前端开发就可以直接按需自己实现相关查询和操作了, 再也不会出现加一个字段同步修改半天这种困扰. 但是对于比较复杂或者有其他特殊功能的接口, 后端还是提供统一封装更好, 毕竟使用这套框架之后, 后端的查询也是个非常简单的事情了","link":"/2019/01-29-egg-sql-query/"},{"title":"React Hooks常见用法","text":"背景React在v16中推出了一项重大更新: Hooks. 以往在React组件开发中, 往往要区分函数式组件和类组件的定义和使用, 函数式组件纯展示无副作用, 类组件里面可以保存状态 但在Hooks推出后, 函数式组件除了在某些特殊场景下无法使用(ErrorBoundary/getSnapshotBeforeUpdate), 其他情况下都可以完美替代Class组件了, 今天来看看它是如何替换的 生命周期先来看看React 16的最新生命周期, 和之前版本相比有些小的调整, 旧版的可以参考这一份文章, 主要是去掉了部分方法和和并了一些获取props更新的方法 去掉的方法 componentWillMount componentWillUpdate componentWillReceiveProps 这些方法的功能都被统一集中到了getDerivedStateFromProps中, 同时还新增了getSnapshotBeforeUpdate来解决异步渲染时的dom操作问题, 总体大的生命周期还是一致的 Hooks先根据React官方文档简单介绍一下各Hooks函数的作用 Basic Hooks useState: 保存状态, 状态变化时会触发重新渲染 useEffect: 监听值变化 useContext: 跨组件传值, 状态变化时会触发重新渲染 Additional Hooks useReducer: useState的高级版, 更适合管理复杂状态 useCallback: 局部缓存, 往往用于缓存函数 useMemo: 局部缓存, 往往用于缓存值 useRef: 获取一个脱离于生命周期的指针, 可以设置为任何值, 修改不会触发重新渲染 useImperativeHandle: 用于包装函数式组件的父组件获取到的引用值(父组件调用子组件方法), 需要配合forwardRef一起使用 useLayoutEffect: useEffect的升级版, 在React实际渲染之前触发, 会阻塞渲染, 用于特殊情况下减少页面闪烁 useDebugValue: 与React开发者工具配合调试时使用, 可以用来显示状态等 模拟生命周期constructor一般在constructor里都是初始化state或者从props里读取某些值, 在函数式组件里可以直接使用, 不需要特殊处理, 初始化state可以使用setState 1const [nameState, setNameState] = useState(props.name); componentDidMount123useEffect(() =&gt; { // code}, []); componentWillReceiveProps1234567useMemo(() =&gt; { // return new value}, [props.name]);useEffect(() =&gt; { // code}, [props.name]); shouldComponentUpdate1234567useCallback(() =&gt; { // return new value}, [props.name]);useMemo(() =&gt; { // return new value}, [props.name]); componentWillUnmount12345useEffect(() =&gt; { return () =&gt; { // code };}, []); componentDidUpdate这是实现起来比较复杂的一个方法, 需要结合多个Hooks才能满足条件 12345678910111213141516171819202122const mounted = useRef();useEffect(() =&gt; { if (!mounted.current) { // do componentDidMount logic mounted.current = true; } else { // do componentDidUpdate logic }});// 或者实现自定义hooksexport const useComponentDidUpdate = (effect, dependencies) =&gt; { const mounted = useRef(false); useEffect(() =&gt; { if (!mounted.current) { mounted.current = true; return; } effect(); }, dependencies);}; 其他场景和上一次值对比1234567891011121314151617181920import { useEffect, useRef, DependencyList } from 'react';const useUpdate: (effect: (deps?: DependencyList) =&gt; void | ((deps?: DependencyList) =&gt; void | undefined), deps?: DependencyList) =&gt; void = ( effect, deps,) =&gt; { const mountedRef = useRef&lt;{ data: DependencyList; init: boolean }&gt;({ data: null, init: false }); useEffect(() =&gt; { const preDeps = mountedRef.current.data; mountedRef.current.data = deps; if (!mountedRef.current.init) { mountedRef.current.init = true; } else { const returnFn = effect(preDeps); return () =&gt; returnFn &amp;&amp; returnFn(preDeps); } }, deps);};export default useUpdate; 提供方法给父组件调用1234567891011const C = forwardRef((props, ref) =&gt; { useImperativeHandle( ref, () =&gt; ({ func: async () =&gt; { // code }, }), [], );}); 获取内部节点12const divRef = useRef &lt; HTMLDivElement &gt; null;return &lt;div ref={divRef}&gt;&lt;/div&gt;; 错误处理错误处理只有类组件才能实现, 在项目中往往在最外层和各容器层包裹一个通用错误处理组件即可 12345678910111213141516171819202122232425class ErrorBoundary extends Component&lt;{}, { hasError: boolean }&gt; { constructor(props: {}) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error: any) { console.error(error); return { hasError: true }; } componentDidCatch(error: Error, info: ErrorInfo) { // sendErrorToRemote(); console.error(error, info); } render() { if (this.state.hasError) { return &lt;Result status='500' title='500' subTitle='Sorry, something went wrong.' /&gt;; } return this.props.children; }}export default ErrorBoundary;","link":"/2019/02-21-react-hooks/"},{"title":"React Async Hooks","text":"背景上一篇文章已经简单介绍使用了Hooks, 而Hooks带来的好处就是可以封装常用逻辑, 在前端中最常见的就是request请求了, 那么看看如何封装异步请求Hooks比较合适 开发useAsync首先, 需要构建类似useState方法的Hooks, 只是传入值应该是一个Promise(如果非Promise, 直接当做已经完成的值就行), 返回的state也有三个属性: data/loading/error, 就叫它useAsync吧 12345678910111213141516export type UseAsyncArgs&lt;T&gt; = T | (() =&gt; Promise&lt;T&gt;);export type UseAsyncState&lt;T&gt; = { loading: boolean; error: Error; data: T };export type UseAsyncPromise&lt;T&gt; = T | Promise&lt;T&gt;;export type UseAsyncReturn&lt;T&gt; = [UseAsyncState&lt;T&gt;, Dispatch&lt;SetStateAction&lt;UseAsyncPromise&lt;T&gt;&gt;&gt;];const useAsync = &lt;T&gt;(_promise: UseAsyncArgs&lt;T&gt;): UseAsyncReturn&lt;T&gt; =&gt; { const [promise, setPromise] = useState&lt;UseAsyncPromise&lt;T&gt;&gt;(_promise); const [jobState, setJobState] = useState&lt;UseAsyncState&lt;T&gt;&gt;({ loading: true, error: null, data: null, }); return [jobState, setPromise];}; 然后是我们需要在此Hooks里得到promise的执行情况, 并根据执行结果setState 12345678910111213141516171819202122232425262728293031323334353637const useAsync = &lt;T&gt;(_promise: UseAsyncArgs&lt;T&gt;): UseAsyncReturn&lt;T&gt; =&gt; { const [promise, setPromise] = useState&lt;UseAsyncPromise&lt;T&gt;&gt;(_promise); const [jobState, setJobState] = useState&lt;UseAsyncState&lt;T&gt;&gt;({ loading: true, error: null, data: null, }); const doJob = async () =&gt; { const _jobState = { ...jobState }; try { if (promise instanceof Promise || _.isFunction(_.get(promise, 'then'))) { _jobState.loading = true; _jobState.error = null; _jobState.data = null; setJobState({ ..._jobState }); const result = await promise; _jobState.data = result; } else { _jobState.loading = false; _jobState.error = null; _jobState.data = promise; } } catch (error) { console.log('useAsync error', error); _jobState.error = error; } finally { _jobState.loading = false; setJobState({ ..._jobState }); } }; useEffect(() =&gt; { doJob(); }, [promise]); return [jobState, setPromise];}; 初步看起来这样没问题了, 但是试用后会发现, 如果第一次setPromise的返回结果比第二次慢, 那么实际上生效的data会是返回比较慢的值, 但它应该是要被覆盖的值才对. 所以需要加上promise是否最新的判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const useAsync = &lt;T&gt;(_promise: UseAsyncArgs&lt;T&gt;): UseAsyncReturn&lt;T&gt; =&gt; { const [promise, setPromise] = useState&lt;UseAsyncPromise&lt;T&gt;&gt;(_promise); let isPromise = false; if (promise instanceof Promise || _.isFunction(_.get(promise, 'then'))) { isPromise = true; } const [jobState, setJobState] = useState&lt;UseAsyncState&lt;T&gt;&gt;({ loading: isPromise ? true : false, error: null, data: isPromise ? null : (promise as T), }); const currentJobRef = useRef&lt;Promise&lt;T&gt;&gt;(null); const doJob = async () =&gt; { const _jobState = { ...jobState }; try { currentJobRef.current = promise as Promise&lt;T&gt;; if (promise instanceof Promise || _.isFunction(_.get(promise, 'then'))) { _jobState.loading = true; _jobState.error = null; _jobState.data = null; setJobState({ ..._jobState }); const result = await promise; if (currentJobRef.current === promise) { _jobState.data = result; } } else { _jobState.loading = false; _jobState.error = null; _jobState.data = promise; } } catch (error) { console.log('useAsync error', error); if (currentJobRef.current === promise) { _jobState.error = error; } } finally { if (currentJobRef.current &amp;&amp; currentJobRef.current === promise) { _jobState.loading = false; setJobState({ ..._jobState }); } } }; if (isPromise &amp;&amp; currentJobRef.current !== promise) { doJob(); } useEffect(() =&gt; { return () =&gt; { currentJobRef.current = null; }; }, []); return [jobState, setPromise];}; useFetch然后再实现useFetch, 实现接口的自动请求 123456789101112131415161718192021222324252627282930const isAxiosResponse = &lt;T&gt;(result: unknown): result is AxiosResponse&lt;T&gt; =&gt; (result as AxiosResponse)?.request instanceof XMLHttpRequest;export type UseFetchReturn&lt;R, T&gt; = [UseAsyncState&lt;R&gt;, (promise: UseAsyncPromise&lt;T&gt;) =&gt; UseAsyncPromise&lt;T&gt;];const defaultGetData = &lt;T, R&gt;(result: T) =&gt; { if (isAxiosResponse&lt;R&gt;(result)) { return result.data; } return result as unknown as R;};const useFetch = &lt;T, R = T extends AxiosResponse ? T['data'] : T&gt;( promise: UseAsyncArgs&lt;T&gt; = null, getData: (result: T) =&gt; R = defaultGetData,): UseFetchReturn&lt;R, T&gt; =&gt; { const [asyncState, setPromise] = useAsync&lt;T&gt;(promise); const login = useLogin(); if (asyncState.error instanceof UTILS.FetchError.AuthError) { login(); } const resolveAsyncState: { loading: boolean; error: Error; data: R } = { ...asyncState, data: useMemo&lt;R&gt;( () =&gt; (_.isArray(asyncState.data) ? (asyncState.data.map(getData) as any) : getData(asyncState.data)), [asyncState.data, getData], ), }; return [resolveAsyncState, setPromise];}; 完善流程以上两个Hooks完成后, 已经实现了请求的完整流程控制, 使用起来也比较简单 123456789101112131415const [pageData, setPagePromise] = useFetch(null);const clickRefreshData = useCallback( async (id: string) =&gt; { setPagePromise( UTILS.post&lt;{ data: string; }&gt;(api.webApi.api(), { id }), ); }, [setPagePromise],);useEffect(() =&gt; { // handler data}, [pageData]); 但是这样使用起来实际上是会打断流程的, 甚至比以前的回调地狱还难用, 因为闭包之间是没有互相包含的, 如果有个异步串行请求, 那么实现起来会非常痛苦 普通异步请求流程flowchart LR subgraph A[闭包空间Event] direction LR E1[事件触发] --> F1[执行异步Job] F1 -. 完成 .-> F2[异步回调] F2 --> F3[处理结果] end Hooks请求流程flowchart LR subgraph AA[闭包空间Event] direction LR EE1[事件触发]-->FF1[执行异步Job] end subgraph BB[闭包空间 useEffect] direction LR FF1 -. 完成 .-> FF2[异步回调] FF2 --> FF3[处理结果] end 那么有办法解决这个问题吗? 如果能将setPagePromise这个方法也能直接添加异步返回, 就能直接变成普通异步请求的流程. 对于无所不能的js来说, 好像也是可以实现的 useFetchWithErrorHandler按上面所描述的, 我们只需要在useFetch的时候, 将setPromise的返回值修改为与原始promise返回值同步的操作就行, 这里把项目中常用的error-modal弹窗也直接加入进来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const getErrorMessage = (error: Error) =&gt; React.createElement(React.Fragment, null, React.createElement('div', null, _.get(error, 'text')), React.createElement('div', null, error.message));export type UseFetchWithErrorHandlerReturn&lt;T&gt; = [ UseAsyncState&lt;T&gt;, &lt;TT, RR = TT extends AxiosResponse ? TT['data'] : TT&gt;( promise?: Promise&lt;TT&gt; | Promise&lt;any&gt;, _showError?: boolean, _throwError?: boolean, ) =&gt; Promise&lt;RR&gt;,];const useFetchWithErrorHandler = &lt;T&gt;(promise: UseAsyncArgs&lt;T&gt; = null, showError: boolean = true): UseFetchWithErrorHandlerReturn&lt;T&gt; =&gt; { const [resolveAsyncState, setPromise] = useFetch&lt;T | any&gt;(promise); const setPromiseWithErrorHandler = useCallback( &lt;TT, RR = TT extends AxiosResponse ? TT['data'] : TT&gt;( _promise: Promise&lt;TT&gt; | Promise&lt;any&gt; = null, _showError: boolean = showError, _throwError: boolean = false, ): Promise&lt;RR&gt; =&gt; { return new Promise&lt;RR&gt;((resolve, reject) =&gt; { const isPromise = _promise instanceof Promise || _.isFunction(_.get(_promise, 'then')); if (isPromise) { setPromise( (_promise as Promise&lt;RR&gt;).then( (data: any) =&gt; { resolve(defaultGetData(data)); return data; }, (error: Error) =&gt; { if (_showError) { Modal.error({ centered: true, title: error.name, content: getErrorMessage(error), }); } if (_throwError) { reject(error); } return Promise.reject(error); }, ), ); } else { resolve(setPromise(_promise)); } }); }, [setPromise, showError], ); return [resolveAsyncState, setPromiseWithErrorHandler];}; 使用方法12345678910111213141516const [pageData, setPagePromise] = useFetchWithErrorHandler(null);const clickRefreshData = useCallback( async (id: string) =&gt; { try { const result = await setPagePromise( UTILS.post&lt;{ data: string; }&gt;(api.webApi.api(), { id }), ); // handler result } catch (e) { // handler error } }, [setPagePromise],); 全局进度条既然实现了全局统一的useFetch以及error-msg, 那么顺便把请求进度条也一起加上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125type ProgressConfig = { start: number; progress: number; intervalId?: number;};type RequestConfig = FetchRequestConfig &amp; { requestId: string;};const LoadingProgress: React.FC = () =&gt; { const loadingRef = useRef&lt;{ [key: string]: ProgressConfig; }&gt;({}); const [progressState, setProgressState] = useState({ status: 'none', progress: 0, }); const calcProgressState = () =&gt; { let currentProgress = 0; _.map(loadingRef.current, ({ progress }) =&gt; { currentProgress += progress; }); const totalProgress = _.size(loadingRef.current) * 100; if (currentProgress === totalProgress) { _.map(_.keys(loadingRef.current), (key) =&gt; Reflect.deleteProperty(loadingRef.current, key)); setTimeout( () =&gt; setProgressState({ status: 'none', progress: 0, }), 300, ); } setProgressState({ status: currentProgress === totalProgress ? 'done' : 'progress', progress: (currentProgress / totalProgress) * 100, }); }; useEffect(() =&gt; { const reqOff = addFetchEventListener('request', (config: RequestConfig) =&gt; { if (config._hasProgress) { config.requestId = _.uniqueId(`axios_request_`); const progressConfig: ProgressConfig = { start: new Date().getTime(), progress: 20, }; loadingRef.current[config.requestId] = progressConfig; calcProgressState(); progressConfig.intervalId = window.setInterval(() =&gt; { const spendTime = new Date().getTime() - progressConfig.start; // 2s 完成 80% progressConfig.progress = 20 + (spendTime / (spendTime + 500)) * 0.7 * 100; calcProgressState(); }, 100); } return config; }); const resOff = addFetchEventListener( 'response', (response: AxiosResponse) =&gt; { const { config } = response; if ((config as RequestConfig)._hasProgress) { const progressConfig = loadingRef.current[(config as RequestConfig).requestId]; progressConfig.progress = 100; clearInterval(progressConfig.intervalId); calcProgressState(); } return response; }, (error: AxiosError) =&gt; { const { config } = error; if ((config as RequestConfig)._hasProgress) { const progressConfig = loadingRef.current[(config as RequestConfig).requestId]; progressConfig.progress = 100; clearInterval(progressConfig.intervalId); calcProgressState(); } return Promise.reject(error); }, ); return () =&gt; { reqOff(); resOff(); }; }, []); return ( &lt;div className={classNames('loading-progress-wrapper', { hidden: progressState.status === 'none' })}&gt; &lt;Progress className='loading-progress' type='line' showInfo={false} status={progressState.status === 'progress' &amp;&amp; progressState.progress &gt; 80 ? 'active' : 'normal'} percent={progressState.progress} strokeColor={{ '0%': '#108ee9', '100%': '#87d068', }} strokeWidth={5} /&gt; &lt;style jsx global&gt; {` .loading-progress-wrapper { z-index: 2000; height: 3px; width: 100%; position: absolute; .loading-progress { display: block; line-height: 0px; height: 3px; } } `} &lt;/style&gt; &lt;/div&gt; );};export default LoadingProgress;","link":"/2019/02-24-react-async-hooks/"},{"title":"React Form Hooks","text":"背景antd的Form表单是使用高阶组件实现的, 而且默认的校验方式需要写在Form.Item上或者通过getFieldDecorator高阶组件生成, 对于函数式组件来说实现非常不友好, 而且也不是集中管理, 分散在各个jsx组件中, 不便于维护查看等, 而且函数式组件支持方式在不确定发布日期的antdv4版本才有计划升级, 所以需要自己实现一套适合于Hooks的表单验证组件 开发useForm既然是实现Hooks, 参考state的实现, 我们需要定义form的初始值, 以及相关的设置方法, 同时有个特殊点的是form的字段验证方法, 返回值可以分开返回, 但尽量与antd-form需要的字段一致, 如helper/validateStatus, 而且用Hooks有个好处, 我们可以集中验证字段类型, 不需要分散到各组件中验证了 同时, 可以将常用的Input方法也直接由Hooks返回, 如onChange/setForm/getFieldStatus等, 需要注意的是为了支持多种输入组件, onChange需要处理好对Event或Value的泛型支持, 并提供修改的入口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type FormValueType = string | number | boolean | any;const useForm = ( initState: { [key: string]: FormValueType; }, rules: { [key in keyof typeof initState]: () =&gt; RuleResult } = {},) =&gt; { const [form, setForm] = useState(initState); const { formFieldInfoState, getFieldStatus, setInit } = useFormValidator(form, rules); const setInitForm = (_form: typeof initState) =&gt; { setForm(_form); setInit(); }; const changeHandlerBuild = &lt;T = React.SyntheticEvent&gt;( key: keyof typeof initState, getValue = (event: T) =&gt; (event as any).target.value, changeCheckStatus = true, ) =&gt; { return (event: T) =&gt; { setForm({ ..._.set(form, key, getValue(event)), }); if (changeCheckStatus) { getFieldStatus(key); } }; }; const formInputHandler = &lt;T = string, E = React.SyntheticEvent&gt;( key: keyof typeof initState, getEventValue?: (event: E) =&gt; T, defaultValue?: ((value: T) =&gt; T) | T, changeCheckStatus?: boolean, ) =&gt; { return { // eslint-disable-next-line no-nested-ternary value: (defaultValue ? _.isFunction(defaultValue) ? defaultValue(_.get(form, key, '') as any) : defaultValue : (_.toString(_.get(form, key, '')) as any)) as T, onChange: changeHandlerBuild(key, getEventValue, changeCheckStatus), onBlur: () =&gt; getFieldStatus(key), }; }; return [ { form, formFieldInfoState }, { setForm, setInitForm, getFieldStatus, formInputHandler, changeHandlerBuild }, ];};export default useForm; useFormValidator上面的useForm已经把form的value/change等事件处理完了, 那么接下来再实现一个单独验证表单数据的Hooks就能实现与antd的表单同样的效果 同时希望验证的语法不要太复杂, 能直接支持原始函数并且支持返回错误类型即可, 类似parameter的rule, 并且需要支持异步验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241const ValidateStatuses = ['success', 'warning', 'error', 'validating', ''] as const;export type FormValueType = string | number | boolean;export type FormFieldState = { status: typeof ValidateStatuses[number]; help: string; promise?: Promise&lt;RuleResultValue&gt;;};export type RuleResultValue = string | boolean | FormFieldState;export type RuleResult = RuleResultValue | Promise&lt;RuleResultValue&gt;;export type FormFieldsState&lt;T&gt; = { [key in keyof T]: FormFieldState };export type FormFieldInfoState&lt;T&gt; = { status: typeof ValidateStatuses[number]; fields: FormFieldsState&lt;T&gt;;};const isPromise = &lt;T&gt;(value: T | Promise&lt;T&gt;): value is Promise&lt;T&gt; =&gt; { return _.hasIn(value, 'then');};const undefinedToFalse = (value: RuleResultValue) =&gt; { return _.isUndefined(value) ? false : value;};const ruleResultValueToFormFieldState = (value: RuleResultValue): FormFieldState =&gt; { value = undefinedToFalse(value); let result: FormFieldState = { status: '', help: undefined }; if (_.isObject(value) &amp;&amp; _.has(value, ['status', 'success', 'help'])) { result = value; } if (_.isString(value) || _.isBoolean(value)) { result = { status: !value ? 'success' : 'error', help: _.isString(value) ? value : '', }; } return result;};const getAllStatusFromFieldStatus = (allStatus: typeof ValidateStatuses[number][]) =&gt; { if (allStatus.includes('')) { return ''; } if (allStatus.includes('validating')) { return 'validating'; } if (allStatus.includes('error')) { return 'error'; } if (allStatus.includes('warning')) { return 'warning'; } return 'success';};const setAllFieldsStatus = &lt; T extends { [key: string]: FormValueType; },&gt;( formFieldInfoState: FormFieldInfoState&lt;T&gt;, allRuleKeys: string[],): FormFieldInfoState&lt;T&gt; =&gt; { const allStatus = _.map(allRuleKeys, (key) =&gt; formFieldInfoState.fields[key].status); formFieldInfoState.status = getAllStatusFromFieldStatus(allStatus); return formFieldInfoState;};const validateField = async &lt; T extends { [key: string]: FormValueType; },&gt;( field: keyof T, formRules: { [key in keyof T]: () =&gt; RuleResult }, dispatch: React.Dispatch&lt; | { type: 'INIT'; } | { type: 'CHANGE'; payload: { field: keyof T; result: RuleResult; allRuleKeys: string[]; }; } | { type: 'PROMISE_DONE'; payload: { field: keyof T; result: RuleResult; promise: Promise&lt;RuleResultValue&gt;; allRuleKeys: string[]; }; } &gt;,): Promise&lt;FormFieldState&gt; =&gt; { const allRuleKeys = Object.keys(formRules); const validateResult = formRules[field](); dispatch({ type: 'CHANGE', payload: { allRuleKeys: allRuleKeys, field: field, result: validateResult, }, }); let result: RuleResultValue = null; if (isPromise(validateResult)) { try { result = await validateResult; dispatch({ type: 'PROMISE_DONE', payload: { allRuleKeys: allRuleKeys, field: field, result: result, promise: validateResult, }, }); } catch (error) { console.log(`validate field error: ${field}`, error); } } else { result = validateResult; } return ruleResultValueToFormFieldState(result);};const useFormValidator = ( form: { [key: string]: FormValueType; }, formRules: { [key in keyof typeof form]: () =&gt; RuleResult },) =&gt; { type FormType = typeof form; type FormKeys = keyof FormType; const allRuleKeys = Object.keys(formRules); const [formFieldInfoState, dispatchFormFieldInfoState] = useReducer&lt; React.Reducer&lt; FormFieldInfoState&lt;FormType&gt;, | { type: 'INIT'; } | { type: 'CHANGE'; payload: { field: FormKeys; result: RuleResult; allRuleKeys: string[]; }; } | { type: 'PROMISE_DONE'; payload: { field: FormKeys; result: RuleResult; promise: Promise&lt;RuleResultValue&gt;; allRuleKeys: string[]; }; } &gt; &gt;( (state, action) =&gt; { const { type } = action; switch (action.type) { case 'INIT': return { fields: _.transform&lt;string, FormFieldsState&lt;FormType&gt;&gt;( allRuleKeys, (result, key) =&gt; { _.set(result, key, { status: '', help: undefined, }); }, {}, ), status: '', }; case 'CHANGE': if (isPromise(action.payload.result)) { _.set(state.fields, action.payload.field, { status: 'validating', help: undefined, promise: action.payload.result, }); } else { _.set(state.fields, action.payload.field, ruleResultValueToFormFieldState(action.payload.result)); } return { ...setAllFieldsStatus(state, action.payload.allRuleKeys) }; case 'PROMISE_DONE': if (!isPromise(action.payload.result)) { if (action.payload.promise === _.get(state.fields, action.payload.field)?.promise) { _.set(state.fields, action.payload.field, ruleResultValueToFormFieldState(action.payload.result)); return { ...setAllFieldsStatus(state, action.payload.allRuleKeys) }; } } return state; default: throw new Error(`action: ${type} is error`); } }, { fields: _.transform&lt;string, FormFieldsState&lt;FormType&gt;&gt;( allRuleKeys, (result, key) =&gt; { _.set(result, key, { status: '', help: undefined, }); }, {}, ), status: '', }, ); function getFieldStatus(): Promise&lt;FormFieldInfoState&lt;FormType&gt;&gt;; function getFieldStatus(key: FormKeys): Promise&lt;FormFieldState&gt;; async function getFieldStatus(key?: FormKeys): Promise&lt;FormFieldState | FormFieldInfoState&lt;FormType&gt;&gt; { if (key &amp;&amp; _.has(formRules, key)) { return await validateField(key, formRules, dispatchFormFieldInfoState); } if (!key) { const ruleKeys = Object.keys(formRules); return await Promise.all(ruleKeys.map(async (x) =&gt; ({ [x]: await validateField(x, formRules, dispatchFormFieldInfoState) }))).then( (_formFieldInfoState: { [x: string]: FormFieldState }[]) =&gt; setAllFieldsStatus({ status: '', fields: Object.assign({}, ..._formFieldInfoState) }, ruleKeys), ); } } const setInit = () =&gt; dispatchFormFieldInfoState({ type: 'INIT' }); return { formFieldInfoState, getFieldStatus, setInit };};export default useFormValidator; 使用上面Hooks开发完后在函数式组件里使用表单就非常简单了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const FormComponent: React.FC = () =&gt; { const [{ form, formFieldInfoState }, { formInputHandler, changeHandlerBuild, getFieldStatus }] = useForm( { type: '', name: '', sub: { prop: false, }, }, { type() { if (!form.type) { return 'type is required'; } }, async name() { if (!form.name) { return 'name is required'; } }, ['sub.prop']() { if (!form.sub.prop) { return 'sub.prop is required'; } }, }, ); const clickSaveForm = async () =&gt; { if ((await getFieldStatus()).status !== 'success') { return; } await setSavePromise( UTILS.post(api(), { ...form, }), ); message.success(t('COMMON_SUCCESS')); }; return ( &lt;form className='ant-form ant-form-horizontal'&gt; &lt;Form.Item label='type' labelAlign='left' required validateStatus={formFieldInfoState.fields.type.status} help={formFieldInfoState.fields.type.help} labelCol={{ span: 6 }} wrapperCol={{ span: 16 }} hasFeedback &gt; &lt;Input {...formInputHandler('type')} /&gt; &lt;/Form.Item&gt; &lt;Form.Item label={'sub.prop'} help={_.get(formFieldInfoState.fields, 'sub.prop').help} validateStatus={_.get(formFieldInfoState.fields, 'sub.prop').status} labelCol={{ span: 8 }} wrapperCol={{ span: 6 }} &gt; &lt;MultiSelect&lt;number&gt; placeholder='sub.prop' mode='tags' value={form.sub.prop} options={_.map(CONSTANT.OPTIONS, (x) =&gt; ({ label: t(x.label), value: x.value }))} onChange={changeHandlerBuild('sub.prop', (value) =&gt; value)} /&gt; &lt;/Form.Item&gt; &lt;/form&gt; );};","link":"/2019/03-21-react-form-hooks/"},{"title":"React QueryString Hooks","text":"背景在react-router里如果需要获取和修改query-string在class组件里都是通过route组件的props传入的方法实现的, 但是在函数式组件里缺少比较好的方法, 再加上项目中有些复杂的格式需要转成query-string, 于是需要封装一个全局Hooks提供优雅的读写方式 开发这个相比起form-hooks来说就简单很多, 原理就是通过react-router提供的__RouterContext结合useContext来提供全局读写router的能力 useRouter12345678910111213141516171819202122232425262728293031323334import { useContext } from 'react';import { __RouterContext as RouterContext } from 'react-router';import { LocationDescriptorObject, LocationState } from 'history';export default function useRouter() { return useContext(RouterContext);}export function useMatch() { const { match } = useRouter(); return match;}export function useParams() { const { params } = useMatch(); return params;}export function useLocation() { const { location, history } = useRouter(); function navigate(to: string | LocationDescriptorObject&lt;LocationState&gt;, { replace = false }: { replace?: boolean } = {}) { if (replace) { history.replace(to as LocationDescriptorObject&lt;LocationState&gt;); } else { history.push(to as LocationDescriptorObject&lt;LocationState&gt;); } } return { location, navigate, };} useQueryString可以在组件中直接获取router后, 再封装一个方便读写使用router组件的hooks即可 这里有个重要的点是setQueryStringState会返回一个设置是否成功的选项, 用于某些同步设置的地方做下一步操作, 如果url本来就没有变化, 可以不进行下一步操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import _ from 'lodash';import { useMemo, useRef, useCallback } from 'react';import queryString from 'query-string';type QueryResultData&lt;K extends keyof { [key: string]: any }&gt; = { [P in K]: string | string[] | null | undefined;};const useQueryString = &lt;T extends readonly string[], U extends T[number]&gt;( search: string, keys: T,): [QueryResultData&lt;U&gt;, (param: QueryResultData&lt;U&gt;, replace?: boolean) =&gt; boolean] =&gt; { const { history } = useRouter(); const searchQuery = queryString.parse(search, { arrayFormat: 'index' }); const currentSearch = queryString.stringify(searchQuery, { arrayFormat: 'index' }); const searchQueryValidateValueRef = useRef&lt;QueryResultData&lt;string&gt;&gt;(_.pick(searchQuery, keys)); const searchQueryValidateValue = _.pick(searchQuery, keys); const ref = useRef&lt;{ [key: string]: string | string[] }&gt;({}); _.map(keys, (key) =&gt; { if (_.isArray(searchQueryValidateValue[key])) { if (!_.isEqual(searchQueryValidateValue[key], ref.current[key])) { ref.current[key] = searchQueryValidateValue[key]; } else { searchQueryValidateValue[key] = ref.current[key]; } } }); if (!_.isEqual(searchQueryValidateValueRef.current, searchQueryValidateValue)) { searchQueryValidateValueRef.current = searchQueryValidateValue; } const notEmptySearch = queryString.stringify(searchQueryValidateValueRef.current, { arrayFormat: 'index' }); useMemo(() =&gt; { if (notEmptySearch !== currentSearch) { history.replace({ search: notEmptySearch, }); } }, [notEmptySearch, currentSearch, history]); const setQueryStringState = useCallback( (param: QueryResultData&lt;U&gt;, _replace: boolean = false) =&gt; { const validateParam = queryString.stringify(_.pick(param, keys), { arrayFormat: 'index' }); if (!_.isEqual(searchQueryValidateValueRef.current, queryString.parse(validateParam, { arrayFormat: 'index' }))) { history[_replace ? 'replace' : 'push']({ search: validateParam, }); return true; } return false; }, [history, keys], ); return [searchQueryValidateValueRef.current, setQueryStringState];};export default useQueryString; query-string在开发了比较多的系统功能后, 对怎么合理的使用query-string有一个比较固定的流程, 这里记录下来以供参考 sequenceDiagram participant U as URL-Search participant QSS as QueryStringState participant LS as LocalState participant I as Input participant D as Data alt 组件加载 U ->> QSS: 1. 从URL-Search中获取需要的数据, 存到QueryStringState中 opt 数据验证 QSS -->> U: 2. 验证非法值, 将非法值修复后同步回URL U ->> QSS: 3. 从URL-Search中获取最新合法数据 end QSS ->> LS: 4. 从QueryStringState转化为LocalState, 添加默认值 QSS ->> D: 5. 将转化后的值用于数据请求 LS ->> I: 6. 并将这些数据初始化到页面输入组件(input/select)中 end alt 更新参数 I -->> I: 7. 用户输入数据 I -->> LS: 8. 数据同步到LocalState LS -->> LS: 9. debounce/enter等事件触发数据实际生效(如确认按钮) LS -->> U: 10. 格式化为合法的search后写入URL U ->> QSS: 11. URL-Search更新, 同步到QueryStringState QSS -->> LS: 12. QueryStringState更新, 同步到LocalState(因为第10步应该不会实际写入数据) QSS ->> D: 13. 将最新数据用于数据请求 LS -->> I: 14. LocalState数据更新到页面输入组件(同样不会造成实际变化) end","link":"/2019/04-03-react-query-string-hooks/"},{"title":"React Event Hooks","text":"背景在开发中, 往往会需要跨组件传递数据或事件, 而且有时候需要按顺序依次调用, redux不是很好实现, 而react里实现这种跨组件的数据传递的就是使用context, 可以使用context来实现一个事件处理组件, 同时, 为了这个事件处理组件能够在redux里使用, 可以将这个组件绑定到store上 开发ReduxEventContext提供默认的context内容 1234567891011121314151617import { createContext } from 'react';import events from './../events';const warningObject = { get on() { throw new Error('Please use &lt;reduxEventProvider store={store}&gt;'); }, get emit() { throw new Error('Please use &lt;reduxEventProvider store={store}&gt;'); }, get events() { return events; },};const ReduxEventContext = createContext(warningObject);export default ReduxEventContext; ReduxEventProvider提供封装好的Provider节点, 将事件处理方法绑定到组件上 12345678910111213141516import React, { useMemo } from 'react';import _ from 'lodash';import PropTypes from 'prop-types';import ReduxEventContext from './reduxEventContext';const ReduxEventProvider = ({ children, store, events }) =&gt; { const patchedStore = useMemo(() =&gt; _.pick(store, ['on', 'emit', 'events']), [store, events]); return &lt;ReduxEventContext.Provider value={patchedStore}&gt;{children}&lt;/ReduxEventContext.Provider&gt;;};ReduxEventProvider.propTypes = { children: PropTypes.node.isRequired, store: PropTypes.object.isRequired,};export default ReduxEventProvider; storeEnhancer封装createStore的增强方法, 给store注入事件处理代码 123456789101112131415161718192021222324252627282930import _ from 'lodash';const applyEventBus = (events) =&gt; (createStore) =&gt; (...args) =&gt; { const store = createStore(...args); const eventList = []; const on = (type, fn) =&gt; { const obj = { type, fn, }; eventList.push(obj); return () =&gt; _.remove(eventList, (x) =&gt; x === obj); }; const emit = (type, ...args) =&gt; { return eventList.filter((x) =&gt; x.type === type).map((x) =&gt; x.fn(...args)); }; const enhanceStore = { ...store, on, emit, events, }; enhanceStore.getState.getStore = () =&gt; enhanceStore; return enhanceStore; };export { applyEventBus }; createStore使用上面的storeEnhancer创建store 1234567891011const store = createStore(rootReducer, compose(applyMiddleware(thunk), applyEventBus(events)));const App = () =&gt; { return ( &lt;ReduxEventProvider store={store}&gt; &lt;Provider store={store}&gt; &lt;Root /&gt; &lt;/Provider&gt; &lt;/ReduxEventProvider&gt; );}; useEventBus使用ReduxEventContext来传递事件处理方法 12345678import { useContext } from 'react';import { ReduxEventContext } from '../redux';const useEventBus = () =&gt; { return useContext(ReduxEventContext);};export default useEventBus; 使用添加事件监听在需要加上事件监听的组件里, 注册对应的事件监听函数即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, { useEffect, useRef } from 'react';import _ from 'lodash';import Snackbar from './snackbar';import { useEventBus, useForceUpdate } from '../../use';const SnackbarList = () =&gt; { const { on, emit, events } = useEventBus(); const snackbarListRef = useRef([]); const update = useForceUpdate(); useEffect(() =&gt; { const add = (props, ref) =&gt; { const key = _.uniqueId('snackbar-wrapper-'); const component = ( &lt;Snackbar key={key} {...props} ref={ref} onExited={() =&gt; { const onExited = _.get(props, 'snackbarProps.onExited'); onExited &amp;&amp; onExited(); emit(events.EVENT_GLOBAL_REMOVE_SNACKBAR, key); }} /&gt; ); snackbarListRef.current.push({ key, component }); update(); return key; }; const remove = (key) =&gt; _.remove(snackbarListRef.current, (x) =&gt; x.key === key) &amp;&amp; update(); const off = [ on(events.EVENT_GLOBAL_ADD_SNACKBAR, add), on(events.EVENT_GLOBAL_SUCCESS_SNACKBAR, (message, props, ref) =&gt; add({ message: message, variant: 'success', ...props }, ref)), on(events.EVENT_GLOBAL_INFO_SNACKBAR, (message, props, ref) =&gt; add({ message: message, variant: 'info', ...props }, ref)), on(events.EVENT_GLOBAL_WARN_SNACKBAR, (message, props, ref) =&gt; add({ message: message, variant: 'warn', ...props }, ref)), on(events.EVENT_GLOBAL_ERROR_SNACKBAR, (message, props, ref) =&gt; add({ message: message, variant: 'error', ...props }, ref)), on(events.EVENT_GLOBAL_REMOVE_SNACKBAR, remove), ]; return () =&gt; off.map((x) =&gt; x()); }, []); return snackbarListRef.current.map(({ component }, index) =&gt; React.cloneElement(component, { num: index }));};export default SnackbarList;export { Snackbar }; 在组件中使用1234567const { emit, events } = useEventBus();const clickEvent = async (form) =&gt; { await setSavePromise(UTILS.post(api, form)); emit(events.EVENT_GLOBAL_SUCCESS_SNACKBAR, `success`); refreshPage();}; 在reducer中使用12345678const loadData = () =&gt; async (dispatch, getState) =&gt; { const { emit, events } = getState.getStore(); try { const result = await UTILS.post(api, data); } catch (error) { emit(events.EVENT_GLOBAL_SHOW_MESSAGE_BOX, `error: ${error.message}`, { title: error.name }); }};","link":"/2019/04-19-react-event-hooks/"},{"title":"React Virtual Select","text":"背景antd提供的select在数据量大于2000的时候, 就能感觉稍有卡顿, 大于20000的时候会有明显卡顿, 而且如果页面上出现多个数据量较大的选择组件会由于页面元素过多导致更卡, 所以需要开发一个使用虚拟滚动实现的选择组件来优化页面性能 虚拟滚动实现原理虚拟滚动的原理描述起来非常的简单, 获取列表里所有元素各自的高度, 然后相加得到总高度, 用这个总高度渲染一个div作为内容的填充, 再计算滚动的位置和列表的实际高度, 根据滚动位置计算出要渲染的数据是哪一部分, 然后根据这些数据将组件渲染到页面上, 所以可以实现超大数据量的渲染而不会导致卡顿, 实测20w数据的搜索选择无卡顿. 组件选择react-select由于antd的select组件没有提供自定义元素渲染接口, 自己开发一个select组件成本也比较高, 找了一下发现react-select这个库支持自定义组件, 提供的自定义内容很丰富, 样式修改也比较简单, 所以选用此组件作为基础组件, 只需要将menu-list组件渲染部分改为使用虚拟渲染组件即可 react-window虚拟渲染组件使用由react-virtualized升级的react-window实现, react-window里已经封装好了虚拟渲染逻辑, 并提供一系列的辅助操作函数, 使用起来非常简单, 只需要指定最简单的几个参数就行, 就是实现原理上提到的相关参数: height, itemCount, itemSize 开发MenuList 高度计算需要使用_.min([props.selectProps.menuList.height, props.selectProps.menuList.itemSize * props.children.length]), 在数据量较少时候避免出现空白选择地方 键盘上下选择支持需要使用react-window提供的内置api操作上下移动: virtualListRef.current.scrollToItem(index) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const MenuListWithRef = forwardRef((props: any, ref: any) =&gt; { const Row: ComponentType&lt;ListChildComponentProps&gt; = ({ index, style }) =&gt; { let Options = props.children[index]; _.set(Options, 'props.innerProps.style', { ...Options.props.innerProps.style, ...style }); return Options; }; const virtualListRef = useRef(null); const virtualListInnerRef = useRef(null); const currentIndexRef = useRef(null); const height = _.min([props.selectProps.menuList.height, props.selectProps.menuList.itemSize * props.children.length]); const scrollToKeyDownSelected = (changeIndex: number) =&gt; { let index = currentIndexRef.current + changeIndex; if (index &lt; 0) { index += props.children.length; } else if (index &gt;= props.children.length) { index -= props.children.length; } const startY = index * props.selectProps.menuList.itemSize; const endY = startY + props.selectProps.menuList.itemSize; const currentStartY = virtualListRef.current.state.scrollOffset; const currentEndY = currentStartY + height; if (endY &lt;= currentStartY || startY &gt;= currentEndY) { virtualListRef.current.scrollToItem(index); } }; useImperativeHandle(ref, () =&gt; ({ virtualListRef: () =&gt; virtualListRef, virtualListInnerRef: () =&gt; virtualListInnerRef, setCurrentIndex: (index: number) =&gt; { currentIndexRef.current = index; }, onKeyDown: (event: React.KeyboardEvent&lt;HTMLElement&gt;, selectRef: React.LegacyRef&lt;ReactSelect&lt;OptionType, Select&lt;OptionType&gt;&gt;&gt;) =&gt; { if (event.key === 'ArrowDown') { scrollToKeyDownSelected(1); } else if (event.key === 'ArrowUp') { scrollToKeyDownSelected(-1); } }, })); return props.children.length ? ( &lt;FixedSizeList height={height} itemCount={props.children.length} itemSize={props.selectProps.menuList.itemSize} width={props.selectProps.menuList.width} ref={virtualListRef} innerRef={virtualListInnerRef} &gt; {Row} &lt;/FixedSizeList&gt; ) : ( props.children );});const MenuList: ComponentType&lt;MenuListComponentProps&lt;OptionType&gt;&gt; = (props) =&gt; { return &lt;MenuListWithRef {...props} ref={props.selectProps.menuList.ref} /&gt;;}; Option在点开菜单的时候, 需要将已经选中的项直接显示出来, 所以也需要调用menuList提供的方法显示选中内容 12345678910111213141516const Option: ComponentType&lt;OptionProps&lt;OptionType&gt;&gt; = (props) =&gt; { if (props.isFocused &amp;&amp; _.get(props, 'selectProps.menuList.ref.current')) { props.selectProps.menuList.ref.current.setCurrentIndex( _.indexOf( props.options.filter((x: any) =&gt; _.includes(x.label, props.selectProps.inputValue)), props.data, ), ); } return ( &lt;ReactSelectComponents.Option {...props}&gt; {props.label} &lt;CheckOutlined className={`${props.selectProps.classNamePrefix}__option-icon`} /&gt; &lt;/ReactSelectComponents.Option&gt; );}; SelectWindow将上面的组件和事件封装到react-select组件中, 提供选项和对外接口就完成了 123456789101112131415161718192021222324252627const SelectWindow: React.FC&lt; SelectProps&lt;OptionType&gt; &amp; { creatable?: boolean; }&gt; = (props) =&gt; { const menuListRef = useRef(null); const innerSelectRef = useRef&lt;ReactSelect&lt;OptionType, Select&lt;OptionType&gt;&gt;&gt;(null); const selectRef: React.LegacyRef&lt;ReactSelect&lt;OptionType, Select&lt;OptionType&gt;&gt; | CreatableSelect&lt;OptionType&gt;&gt; = props.selectRef || innerSelectRef; const keyDownChangeSelectedItem = (event: React.KeyboardEvent&lt;HTMLElement&gt;) =&gt; { menuListRef.current &amp;&amp; menuListRef.current.onKeyDown(event, selectRef); }; const RealSelect: any = props.creatable ? CreatableSelect : ReactSelect; return ( &lt;RealSelect components={{ MenuList, Option, }} ref={selectRef as any} {...props} menuList={{ ...props.menuList, ref: menuListRef }} onKeyDown={keyDownChangeSelectedItem} className={classNames(props.className, 'react-select-antd')} classNamePrefix='react-select-antd' /&gt; );}; 使用12345678910111213141516const UserSelect: React.FC = () =&gt; { return ( &lt;SelectWindow creatable isMulti virtual menuList={{ height: 250, itemSize: 32, width: width }} style={{ width: width }} value={realValue} options={options} onChange={(val: any) =&gt; { onChange(_.map(val, (x) =&gt; x.value)); }} /&gt; );};","link":"/2019/05-06-react-virtual-select/"},{"title":"MySql JSON数据结构和搜索","text":"背景在mysql-v5.7.8中原生支持了json数据结构, 也提供了一系列json操作函数, 在mysql-v8.0中又新增了一系列的辅助函数, 尝试了一下以后发现已经达到了比较好用的程度, 可以开始在正式环境中使用了, 具体帮助可以参考官方文档 性能 mysql提供基于json-key创建虚拟列索引的方式, 查询性能极高 json大小是需要考虑的问题, 太大的字段不建议使用json存储 json使用json-partial-updates特性来提高更新效率, 只更新指定字段, 但是对比普通字段来说更新性能仍然较低, 如果是经常更新的字段还是建议抽离出来单独作为一列 常用方法数组中存在一项(in)@json可以是表中的列, 也可以是传入的参数, @val同样如此 123SET @json = '[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]';SET @val = 'a';SELECT 1 AS result WHERE JSON_SEARCH(@json, 'one', @val) IS NOT NULL; 数组相等12SET @json = '[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]';SELECT 1 AS result WHERE @json = '[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]'; 从数组中提取值(map)1234SELECT JSON_EXTRACT('[{&quot;a&quot;:0},{&quot;a&quot;:1},{&quot;a&quot;:2}]', '$[*].a') AS r;-- r-- ------------- [0, 1, 2] 两个数组中有相同值(val in field_a &amp;&amp; val in field_b)12345678910111213141516171819202122232425262728293031-- 使用`JSON_SEARCH`SELECT t.*FROM (SELECT NOW() AS now_time, '[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]' AS json_data ) AS t, JSON_TABLE ( t.json_data, &quot;$&quot; COLUMNS ( NESTED PATH '$[*]' COLUMNS (tag VARCHAR (50) PATH '$') ) ) AS t_tagWHERE JSON_SEARCH( '[&quot;a&quot;, &quot;bb&quot;, &quot;cc&quot;]', 'one', t_tag.tag ) IS NOT NULL;-- 使用`in`SELECT t.*FROM (SELECT NOW() AS now_time, '[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]' AS json_data) AS t, JSON_TABLE ( t.json_data, &quot;$&quot; COLUMNS ( NESTED PATH '$[*]' COLUMNS (tag VARCHAR (50) PATH '$') ) ) AS t_tagWHERE t_tag.tag IN ('a', 'bb', 'cc') 在mysql-8.0.17之后, 可以直接使用JSON_OVERLAPS来实现 12SELECT JSON_OVERLAPS(&quot;[1,3,5,7]&quot;, &quot;[2,5,7]&quot;);SELECT JSON_OVERLAPS('[4,5,6,7]', '6'); 对某个字段创建索引123456789CREATE TABLE temp ( c JSON, g INT GENERATED ALWAYS AS (c-&gt;&quot;$.id&quot;), INDEX i (g));-- 查询SELECT c-&gt;&gt;&quot;$.name&quot; AS name FROM temp WHERE g &gt; 2;","link":"/2019/07-10-mysql-json-search/"},{"title":"JS sourcemap 原理与解析","text":"背景JavaScript作为一种运行在客户端的脚本语言, 安全性和代码文件体积是需要重点关注的事情, 而这两项都已经有了比较成熟的解决方案, 就是混淆与压缩, 其中比较出名的就是UglifyJS工具, 常见的webpack打包就是使用由uglify-es迭代而来的terser作为JavaScript代码的压缩工具. 使用压缩工具后, 代码的安全性和体积都得到了优化, 但是随之而来的也会出现一个问题: 线上报错时候无法定位具体原因, 所有的报错都会变成形如1.0a1b2c3d.js:3:4567这种无法直接看懂的调用栈, 原因是因为压缩后的代码会都集中在几行, 而且变量名和语法也会压缩. 有什么解决办法吗? 有的, 在压缩的时候我们可以将原始行/列/变量名/文件和压缩后的代码位置记录下来, 提供一份映射表, 这样在查看报错的时候就能根据这份记录定位到具体报错的源码了, 这也就是sourcemap的原理. sourcemap历史 sourcemap 1.0 出现在2009年, 由google推出的Closure Inspector配合Cloure Compiler压缩工具, 支持调试编译后的代码 sourcemap 2.0 在2010年推出, 确定了统一的json格式和其余规范, 同时也使用了base64编码, 与现代版本的最大区别是使用的算法不同, 生成的.map体积会大很多 sourcemap 3.0 在2011年完善, 成为一项独立的工具, 并使用VLQ编码生成base64前的mapping, 减少了.map文件的体积, 后续逐渐被各浏览器实现, 成为我们现在使用的开发工具. .map文件来看一段简单的代码和编译内容 源码如下 1const square = (x) =&gt; x * x; babel编译后的结果和.map文件 12345678910111213141516'use strict';var square = function square(x) { return x * x;};//# sourceMappingURL=test.js.map{ &quot;version&quot;: 3, &quot;sources&quot;: [&quot;test.es6.js&quot;], &quot;names&quot;: [], &quot;mappings&quot;: &quot;;;AAAA,IAAM,MAAM,GAAG,SAAT,MAAM,CAAI,CAAC;SAAK,CAAC,GAAG,CAAC;CAAA,CAAC&quot;, &quot;file&quot;: &quot;test.js&quot;, &quot;sourcesContent&quot;: [&quot;const square = (x) =&gt; x * x;&quot;]} .map文件里字段的简介 version: 版本号, 目前固定都是v3 sources: 编译前代码的源文件 sourcesContent: 源文件内容, 可以没有可以有, 一般生产环境不会记录, 可能会泄露源码 names: 原文件中的变量名与属性名, 浏览器断点能看见变量内容, 控制台却不能调用的原因就是这里 mapping: 映射的json, map文件的核心内容 file: 编译后的文件名 Mappings格式1';;AAAA,IAAM,MAAM,GAAG,SAAT,MAAM,CAAI,CAAC;SAAK,CAAC,GAAG,CAAC;CAAA,CAAC'; mapping由固定格式组成 分号: 代表分隔行 逗号: 代表分隔列 其他字母: VLQ编码, 有可能是1/4/5位 第一位，表示这个位置在（转换后的代码的）的第几列。 第二位，表示这个位置属于sources属性中的哪一个文件。 第三位，表示这个位置属于转换前代码的第几行。 第四位，表示这个位置属于转换前代码的第几列。 第五位，表示这个位置属于names属性中的哪一个变量。 VLQ(Variable Length Quantities)编码这种编码最早用于MIDI文件，后来被多种格式采用。它的特点就是可以非常精简地表示很大的数值。理解VLQ两个要解决的问题, 就很好理解VLQ的设计原理了 如何解决数字连续: 12如何表示为十二, 又如何表示为一和一 如何解决正负 VLQ编码是变长的。如果（整）数值在-15 到+15 之间（含两个端点），用一个字符表示；超出这个范围，就需要用多个字符表示。它规定，每个字符使用6个二进制位，正好可以借用Base64编码的字符表。 VLQ每一小节由6位组成, 将每节的第一位用于标识是否连续, 最后一位代表正负, 同时, 连续的情况下, 不需要最后一位来代表真正负, 有五位可以用于计数 VLQ编码实例下面看一个例子，如何对数值16进行VLQ编码。 1234567第一步，将16改写成二进制形式10000。第二步，在最右边补充符号位。因为16大于0，所以符号位为0，整个数变成100000。第三步，从右边的最低位开始，将整个数每隔5位，进行分段，即变成1和00000两段。如果最高位所在的段不足5位，则前面补0，因此两段变成00001和00000。第四步，将两段的顺序倒过来，即00000和00001。第五步，在每一段的最前面添加一个&quot;连续位&quot;，除了最后一段为0，其他都为1，即变成100000和000001。第六步，将每一段转成Base 64编码。第七步，查表可知，100000为g，000001为B。因此，数值16的VLQ编码为gB。 解析sourcemap看完原理之后, 就需要实现sourcemap的解析了. 好在有source-map这个库, 已经将上面的这些内容完全封装好, 直接使用即可, 不过还是有些实际项目中会碰到的问题需要解决 从堆栈中获取错误源信息如需要从http://localhost/static/js/1.0a1b2c3d.js:3:4567这个信息中获取文件/行号/列号 好在现在浏览器的错误堆栈格式都没有太大差异, 使用一个正则就能获取到这些信息 123456789101112131415161718192021222324let splitChar = '\\r\\n';splitChar = trace.split(splitChar).length &gt; 1 ? splitChar : '\\n';const lines = trace.split(splitChar);const reg = new RegExp(`(^|[@( ])https?://(?&lt;host&gt;[a-z0-9-_.:]+/)(?&lt;file&gt;.+?):(?&lt;line&gt;\\\\d+):(?&lt;column&gt;\\\\d+)\\\\)?$`, 'i');const linesMatch = lines.map((x) =&gt; { const match = x.match(reg); if (!match) { return { resolve: true, msg: 'not match file regex', result: x, }; } const { file, line, column } = match.groups; return { resolve: false, file: file, fileLower: _.toLower(file), line: parseInt(line), column: parseInt(column), source: x, error: null, };}); 根据错误文件获取.map文件.map文件是在系统上线前上传到后端统一存储到s3中, 并且带上额外的路径信息, 在上一步解析到文件名后可以根据版本号加文件名加路径信息从本地缓存和s3下载到原始的.map文件 额外的路径信息用于解决前置代理或者部署路径与打包路径不一致的问题 比如打包文件位于/static/js/1.0a1b2c3d.js 但是线上访问路径是/web/static/js/1.0a1b2c3d.js 文件的缓存和s3读取1234567891011121314151617181920212223242526272829303132333435363738394041424344class FileService extends Service { async getFile(project, client_v, file) { const symbolInfo = {}; // 根据文件获取到sourcemap文件信息 const filepath = symbolInfo.s3path; const filemd5 = crypto.createHash('md5').update(filepath).digest('hex'); const cacheFileName = `${this.config.tmpCache.path}${filemd5}.gz`; let fileData = null; try { const fileReadStream = fs.createReadStream(cacheFileName); fileData = await this.streamToBuffer(fileReadStream); } catch (e) { try { if (symbolInfo.s3path.startsWith('weed://')) { const filepathMatch = symbolInfo.s3path.match(/weed:\\/\\/([^/]+)\\//); const response = await this.ctx.curl(`${this.config.dumpx.weed_url}/${filepathMatch[1]}`, { followRedirect: true }); fileData = response.data; } else { const fileReadStream = await this.service.s3.getS3FileReadStream(this.config.s3.symbolsBucket, filepath); fileData = await this.streamToBuffer(fileReadStream); } try { // 即使缓存写入失败不影响解析 await writeFileAtomic(cacheFileName, fileData); } catch (err) { this.ctx.logger.error(err); } } catch (e) { throw new Error(`Get S3 file error: ${filepath}, ${e}`); } } return (await ungzip(fileData)).toString('utf-8'); } streamToBuffer(stream) { return new Promise((resolve, reject) =&gt; { const buffers = []; stream.on('error', reject); stream.on('data', (data) =&gt; buffers.push(data)); stream.on('end', () =&gt; resolve(Buffer.concat(buffers))); }); }} 使用.map文件解析123456789101112131415161718192021222324252627282930313233343536373839404142434445const fileGroup = _.groupBy( linesMatch.filter((x) =&gt; !x.resolve), 'fileLower',);const linesResolve = _.map(fileGroup, async (lines, filepath) =&gt; { let map = null; try { const mapData = await this.service.file.getFile(project, client_v, filepath); map = await new sourceMap.SourceMapConsumer(mapData); lines.map((x) =&gt; { const result = map.originalPositionFor({ line: x.line, column: x.column, }); if (_.isNull(result.source)) { throw new Error(`resolve code with sourcemap error`); } x.resolve = true; x.result = x.source.replace( `${x.file}:${x.line}:${x.column}`, `${result.source.indexOf('.') !== -1 ? result.source : x.file}:${result.line}:${result.column}`, ); }); } catch (e) { lines .filter((x) =&gt; !x.resolve) .map((x) =&gt; { x.resolve = true; x.result = x.source; x.error = _.toString(e); }); } finally { // 一定要销毁, 否则会持久占用内存 map &amp;&amp; map.destroy &amp;&amp; map.destroy(); } return lines;});await Promise.all(linesResolve);const source = linesMatch.map((x) =&gt; x.result).join(splitChar);const errors = _.compact(linesMatch.slice(0, 5).map((x, i) =&gt; (x.error ? { line: i, error: x.error } : null)));return { source: source, errors: errors,}; 附录: 上传.map文件在webpack打包完成后, 自动检测目录下的.map文件, 上传到服务端保存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const AdmZip = require('adm-zip');const fs = require('fs');const path = require('path');const _ = require('lodash');const request = require('request');const pkg = require('../package.json');const buildPath = path.join(__dirname, '../build');const zipFile = path.join(__dirname, '../source-map.zip');var sourcemapFileList = [];const getAllSourcemap = (dir) =&gt; { var arr = fs.readdirSync(dir); arr.forEach(function (item) { var fullpath = path.join(dir, item); var stats = fs.statSync(fullpath); if (stats.isDirectory()) { getAllSourcemap(fullpath); } else if (fullpath.endsWith('.map')) { sourcemapFileList.push(fullpath.replace(/\\\\/gi, '/')); } }); return sourcemapFileList;};getAllSourcemap(buildPath);const zip = new AdmZip();_.map(sourcemapFileList, (file) =&gt; { const relativePath = path.relative(buildPath, file); console.log(`Get sourcemap: ${relativePath}`); zip.addLocalFile(file, path.dirname(relativePath));});zip.writeZip(zipFile);request.post( { url: 'https://......', headers: { 'Content-Type': 'multipart/form-data', 'x-token': process.env.X_TOKEN, }, formData: { project_code: '', os_type: '', client_v: `${pkg.version}(${appSmallVersion})`, js_sourcemap: fs.createReadStream(zipFile), }, }, function optionalCallback(err, httpResponse, body) { if (err) { throw new Error('upload failed:', err); } console.log('Upload successful! Server responded with:', body); },);","link":"/2019/08-18-js-sourcemap-resolve/"},{"title":"React App Framework - 1. Base","text":"背景在一些大型前端项目内, 需要把多个应用组合起来, 避免多次跳转和减少系统的交互成本, 以前常见的方式是按同一个模板开发, 然后用iframe组合起来, 能实现较高的隔离性, 但是开发/维护/体验都不算舒适, 最近开发了一个基于react+ts实现的框架, 实现了开发/体验/运维都比较好的效果, 会逐渐将一些重点内容记录下来 框架开发基础组件应用容器最先要实现的就是底层的应用容器app-container了, 有几个基本要素: 根据不同url路由到不同的子应用 每个子应用隔离开发并支持动态加载 子应用统一风格, 可以选择是否支持切换项目 子应用的状态管理隔离 用户基础信息由外层统一提供 这几个中难度比较大的是子应用的切换项目和状态管理, 按难度排序给出主要实现 子应用路由主要原理是通过react-router结合React.Suspense实现, 首先实现root的切换组件, 然后实现动态加载app的组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// root 切换组件// root.root-app-container.tsxconst RootAppContainer: React.FC = () =&gt; { return ( &lt;main className='container flex-auto overflow-hidden flex-column'&gt; &lt;Switch&gt; &lt;Route exact path='/' render={(props) =&gt; { return ( &lt;RouteLazyComponent app='home' isApp project={null} title={CONSTANT.ALL_APPS.home.title} import={import(/* webpackChunkName: &quot;home&quot; */ `./../../home`)} routeProps={props} /&gt; ); }} /&gt; {_.map(CONSTANT.APPS, ({ name, title, hasProject }, app: AppOptions) =&gt; ( &lt;Route key={app} path={`/${app}`} render={(props) =&gt; { currentApp !== app &amp;&amp; dispatch(globalConfigDucks.changeApp(app)); return hasProject ? ( &lt;RootAppProjectContainer app={app} title={title} routeProps={props} /&gt; ) : ( &lt;RouteLazyComponent app={app} isApp project={null} title={title} import={import(/* webpackChunkName: &quot;[request]&quot; */ `./../../../containers/${app}`)} routeProps={props} /&gt; ); }} /&gt; ))} &lt;Route render={() =&gt; &lt;Redirect to='/' /&gt;} /&gt; &lt;/Switch&gt; &lt;/main&gt; );}; 12345678910111213141516171819202122232425262728293031323334353637383940// 动态加载app组件// RouteLazyComponentconst RouteLazyComponent: React.FC&lt;{ app: AllAppOptions; isApp: boolean; path?: string; project?: Project; title: string; import: Promise&lt;{ default: React.ComponentType&lt;any&gt; }&gt;; routeProps: RouteComponentProps&lt;any, StaticContext, any&gt;;}&gt; = ({ app, path, isApp, title, project, import: _import, routeProps }) =&gt; { const { t } = useTranslation(); const componentCache = useRef&lt;{ [key: string]: React.LazyExoticComponent&lt;any&gt; }&gt;({}); const key = isApp ? app : path; const LazyComponent = (componentCache.current[key] = componentCache.current[key] || lazy(() =&gt; _import)); const App = CONSTANT.ALL_APPS[app]; useMemoCondition( () =&gt; { if (isApp) { document.title = title; return; } if (App.hasProject &amp;&amp; project) { document.title = `${app}:${title} - ${project.code} - ${App.title}`; return; } document.title = `${app}:${title} - ${App.title}`; return; }, [title, project], ([title, project]) =&gt; !!title || !!project, ); const _project = useMemo(() =&gt; project, [project &amp;&amp; project.code, project &amp;&amp; project.name]); return ( &lt;Suspense fallback={&lt;Loading loading appendToBody /&gt;}&gt; &lt;LazyComponent {...routeProps} app={app} {...(_project ? { project: _project } : {})} /&gt; &lt;/Suspense&gt; );}; 子应用统一菜单由于侧边菜单和页面header部分需要保持统一风格, 实现通用的子应用加载组件, 并且支持组件内页面的动态加载 1234567891011121314151617181920212223// 子应用容器组件// sub-app.tsxconst SubApp: React.FC&lt;{ app: AllAppOptions, menu: SubAppMenu, translation: Translation, AppIcon: React.FC, reducers?: ReducersMapObject, preloadedState?: any, store?: Store&lt;{}, Action&gt;,}&gt; = ({ app, menu, children, reducers, preloadedState, store, translation, AppIcon }) =&gt; { const [menuFoldState, setMenuFoldState] = useState(false); const match = useMatch(); return ( &lt;div className={classNames('sub-app flex-auto overflow-hidden flex-row position-relative', app)}&gt; &lt;AppLeftMenu fold={menuFoldState} setFold={setMenuFoldState} menu={menu} app={app} match={match} AppIcon={AppIcon} /&gt; &lt;AppMain fold={menuFoldState} menu={menu} app={app} match={match}&gt; {children} &lt;/AppMain&gt; &lt;/div&gt; );}; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 子应用页面加载组件// sub-app-main.tsxconst AppMain: React.FC&lt;{ app: AllAppOptions; fold: boolean; menu: SubAppMenu; match: match;}&gt; = ({ app, fold, menu, match }) =&gt; { return ( &lt;&gt; &lt;div className={classNames('app-main flex-column', { 'menu-fold': fold })}&gt; &lt;Switch&gt; {menu.map((p) =&gt; { const pc = p as SubAppMenuParentHasChildren; const pi = p as SubAppMenuParentItem; return _.size(pc.children) &gt; 0 ? ( pc.children.map((c) =&gt; ( &lt;Route exact key={c.name} path={`${match.url}${c.path}`} render={(props) =&gt; ( &lt;RouteLazyComponent app={app} isApp={false} path={c.component_name} title={c.title} import={import(/* webpackChunkName: &quot;[request]&quot; */ `./../../containers/${app}/containers/${c.component_name}`)} routeProps={props} /&gt; )} /&gt; )) ) : ( &lt;Route exact key={p.name} path={`${match.url}${pi.path}`} render={(props) =&gt; ( &lt;RouteLazyComponent app={app} isApp={false} path={pi.component_name} title={p.title} import={import(/* webpackChunkName: &quot;[request]&quot; */ `./../../containers/${app}/containers/${pi.component_name}`)} routeProps={props} /&gt; )} /&gt; ); })} {_.size(menu) &amp;&amp; &lt;Route render={() =&gt; &lt;Redirect to={`${match.url}`} /&gt;} /&gt;} &lt;/Switch&gt; &lt;/div&gt; &lt;/&gt; );}; git-submodule子应用需要隔离开发互不影响, 最好的方式就是各自一个独立的repo, 但是完全独立后又没有一个很好的办法统一管理和开发, 于是使用submodule来实现开发和版本隔离, 基础框架不需要考虑各子应用的分支版本细节, 只有在发布的时候子应用在基础框架repo中加上对应ref的提交即可, 在gitlab-ci中加上GIT_SUBMODULE_STRATEGY: recursive, 就可以实现基础框架打包完整系统部署了 同时在子模块的ci中加上获取全局框架并打包的支持, 就可以实现子模块分离打包和部署各自的测试环境了 12# 添加子模块git submodule add --name 'src/containers/${app}' ../${app}-front.git src/containers/${app} 12345# gitlab-ci.yml- git clone -b ${PARENT_BRANCH} --recurse-submodules https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/web-group/front-base- ln -s /home/web/node_modules /home/web/front-base/node_modules- rm -r /home/web/front-base/src/containers/${APPNAME}- cp -r ${CI_PROJECT_DIR}/ /home/web/front-base/src/containers/${APPNAME} 小结到此为止实现了基础框架的加载, 统一头部和侧边菜单, 动态加载子应用和子应用页面, 以及各子应用的独立开发环境与统一打包部署的功能, 子应用的状态分离管理下期继续","link":"/2019/08-29-react-app-framework-base/"},{"title":"React App Framework - 2. Lint","text":"背景在多人合作项目中, 代码风格统一是一个重要的问题. 否则合作开发时提交信息会非常混乱. 而create-react-app自带的ESLint规则又比较弱, 而且缺少代码格式的检查, 所以我们需要加上prettier来检查代码风格, 同时再使用husky,commitlint和lint-staged来实现提交前的代码检查hook 配置prettierprettier的ESLint配置比较简单, 在package.json里加上对应的配置即可 12345678910111213141516171819{ &quot;eslintConfig&quot;: { &quot;extends&quot;: [ // ... &quot;prettier&quot; ], &quot;rules&quot;: { &quot;prettier/prettier&quot;: &quot;error&quot; } }, &quot;prettier&quot;: { &quot;printWidth&quot;: 150, &quot;singleQuote&quot;: true, &quot;trailingComma&quot;: &quot;all&quot;, &quot;arrowParens&quot;: &quot;always&quot;, &quot;jsxSingleQuote&quot;: true, &quot;endOfLine&quot;: &quot;lf&quot; }} husky这个只需要注意在script里加上&quot;postinstall&quot;: &quot;husky install&quot;, 实现自动安装就行 commitlint同样在package.json里添加配置 12345{ &quot;commitlint&quot;: { &quot;extends&quot;: [&quot;@commitlint/config-conventional&quot;] }} lint-staged还是在package.json里添加配置 1234567{ &quot;lint-staged&quot;: { &quot;{src,test}/**/*.(tsx?|js)&quot;: [&quot;eslint --fix&quot;], &quot;*.{css,md,yml}&quot;: [&quot;prettier --write&quot;], &quot;*.md&quot;: [&quot;prettier --write&quot;] }} 其他引入其他比较流行的ESLint插件和规则集合后, 会出现一些常见的写法出现warning的提示, 如果综合考虑后决定不修复, 在ci编译的时候, 由于CI=true, 会导致打包报错, 有两个方法解决 通过package.json里的eslintConfig.rules配置将该规则禁止 在gitlab-ci文件中覆盖该环境变量(不推荐) 123variables: GIT_SUBMODULE_STRATEGY: recursive CI: '' 小结这篇内容比较短, 以为网上资料都比较全面, 复杂的部分是全部结合起来并且在项目中探索适合各自项目组的配置, 并且处理好落地过程中的一系列小坑","link":"/2019/09-03-react-app-framework-lint/"},{"title":"React App Framework - 3. Redux","text":"背景接上篇, 我们来看看如何使用Redux来管理多个子应用的状态. 子应用状态管理最初想过直接通过redux-compose通过key区分不同的app应用内容, 但是这样的隔离性较弱, 在全局或者其他子应用中都会存在无用的内容, 而且切换app的时候数据会存留在store中, 占用过多内存, 研究后发现可以自己开发各子应用隔离的store, 来实现各子系统的状态隔离, 同时加上全局store的事件订阅, 实现外层到内存的数据统一, 并且将外层的dispatch也附加到子应用的store中, 允许子应用调用全局的事件来修改状态, 实现子应用的状态隔离和全局的数据统一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 子应用容器组件 - 加上redux// sub-app.tsxconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const SubApp: React.FC&lt;{ app: AllAppOptions; menu: SubAppMenu; translation: Translation; AppIcon: React.FC; reducers?: ReducersMapObject; preloadedState?: any; store?: Store&lt;{}, Action&gt;;}&gt; = ({ app, menu, children, reducers, preloadedState, store, translation, AppIcon }) =&gt; { const globalStore = useStore&lt;AppState, Action&gt;(); const appStore = useMemo( () =&gt; store || createStore( createReducer( combineReducers({ ...reducers, ..._.mapValues( globalStore.getState(), (v) =&gt; (state: typeof v = v) =&gt; state, ), }), ), preloadedState, composeEnhancers( applyMiddleware(routerMiddleware(history), thunk.withExtraArgument(globalStore.dispatch)), (createStore: any) =&gt; (...args: any[]) =&gt; { const store = createStore(...args); return { ...store, globalDispatch: globalStore.dispatch, }; }, ), ), [], ); const unsubscribe = useMemo( () =&gt; globalStore.subscribe(() =&gt; { const globalState = globalStore.getState(); const state = appStore.getState(); _.find(globalState, (value, key) =&gt; state[key] !== value) &amp;&amp; appStore.dispatch(changeGlobalState(globalState)); }), [globalStore, appStore], ); useEffect(() =&gt; unsubscribe, [unsubscribe]); const [menuFoldState, setMenuFoldState] = useState(false); const match = useMatch(); return ( &lt;Provider store={appStore}&gt; &lt;div className={classNames('sub-app flex-auto overflow-hidden flex-row position-relative', app)}&gt; &lt;AppLeftMenu fold={menuFoldState} setFold={setMenuFoldState} menu={menu} app={app} match={match} AppIcon={AppIcon} /&gt; &lt;AppMain fold={menuFoldState} menu={menu} app={app} match={match}&gt; {children} &lt;/AppMain&gt; &lt;/div&gt; &lt;/Provider&gt; );}; useGlobalDispatch同时开发一个useGlobalDispatch来简化全局dispatch的使用 123456789import { AnyAction, Dispatch, Store } from 'redux';import { useStore } from 'react-redux';const useGlobalDispatch = (): Dispatch&lt;AnyAction&gt; =&gt; { const store: Store&lt;any, AnyAction&gt; = useStore(); return (store as Store&lt;any, AnyAction&gt; &amp; { globalDispatch: Dispatch&lt;AnyAction&gt; }).globalDispatch || store.dispatch;};export default useGlobalDispatch; App12345678910const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(rootReducer, composeEnhancers(applyMiddleware(routerMiddleware(history), thunk)));const App = () =&gt; { return ( &lt;Provider store={store}&gt; &lt;Root history={history} /&gt; &lt;/Provider&gt; );}; 小结到此为止, 子应用的开发框架已经基本成型, 有独立的生命周期/动态加载和独立store, 不会互相影响也不会影响到基础框架, 后续的开发流程就与开发正常的react-app基本无异了","link":"/2019/09-15-react-app-framework-redux/"},{"title":"React App Framework - 4. css&#x2F;theme","text":"css语言和插件在React技术栈中有各种各样的样式使用方案, 常见的如CSS-in-JS、styled-components、emotion、styled-system等, 但是这些方案有的不够直观, 有的不方便复用, 看了一下还是使用styled-jsx比较全面, 支持常见的所有功能, 同时也是直接使用css语法 同时在项目中常用的css扩展语言是sass, styled-jsx也同时支持这种用法, 而我们引入的antd需要修改主题配色的话, 还需要引入less. 所以项目最终支持的css种类为: styled-jsx + sass(组件内用法) sass(独立文件) less(仅限antd) 插件安装styled-jsx配置起来非常简单, 只需要在项目中引入styled-jsx插件即可, 如下: 12345678910111213{ &quot;babel&quot;: { &quot;presets&quot;: [&quot;react-app&quot;], &quot;plugins&quot;: [ [ &quot;styled-jsx/babel&quot;, { &quot;plugins&quot;: [&quot;styled-jsx-plugin-sass&quot;] } ] ] }} sasscreate-react-app里面已经默认安装了sass-loader插件, 安装下sass模块就可以使用了 1npm install -D node-sass lessless是比较复杂的一个模块, 在create-react-app中默认不安装, 需要手动安装, 由于我们项目已经eject过, 所以直接给出配置方法 123456789101112131415161718192021const lessRegex = /\\.less$/;const use = [ // ... { test: lessRegex, use: getStyleLoaders({ importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, }).concat([ { loader: require.resolve('less-loader'), options: { lessOptions: { javascriptEnabled: true, }, }, }, ]), }, // ...]; 主题配置由于我们需要修改antd的主题色, 同时这个颜色也需要在各处使用, 所以定义一份颜色配置, 在less-loader里加入即可 这一步问题就来了, 由于我们代码是typescript, webpack.config.js只支持js格式, 所以需要在js中引入ts的代码和变量, 这里我们使用typescript-require来实现, 它的原理是通过修改require.extensions的方式来实现, 给require.extensions[.ts]加上一个ts的处理函数, 这样就可以在js中使用ts的代码了 theme-config123456789101112// src/config/theme.tsconst THEME = { primary_color: '#1890ff',};const ANTD_THEME = { '@primary-color': THEME.primary_color,};export default THEME;export { ANTD_THEME }; 123456789101112// config/theme/get-theme.jsrequire('./typescript-require');const theme = require('./../../src/config/theme');module.exports = function getTheme(refresh = true) { if (refresh) { delete require.cache[require.resolve('./../../src/config/theme')]; } const theme = require('./../../src/config/theme'); return theme.default;};module.exports.ANTD_THEME = theme.ANTD_THEME; lessless在解决了ts引用的变量问题后, 可以直接使用了 12345// config/webpack.config.jslessOptions = { javascriptEnabled: true, modifyVars: require('./theme/get-theme').ANTD_THEME,}; sasssass会稍微麻烦一点, 因为sass的编译不是使用变量配置, 而是使用prependData的方式注入外部变量, 那就需要把变量对象转化为sass字符串 123456789101112// config/theme/flatten-obj-sass.jsmodule.exports = function flattenObjSass(obj, prefix = '$', transform = (key, val) =&gt; val) { return Object.entries(obj).reduce((r, el) =&gt; { const key = `${prefix}${el[0]}`; const val = el[1]; if (typeof val === 'object' &amp;&amp; !Array.isArray(val) &amp;&amp; val) { return r + `${flattenObjSass(val, `${key}-`, transform)}`; } else { return r + `${key}: ${Array.isArray(val) ? `(${transform(key, val)})` : transform(key, val)}; `; } }, '');}; 12345678// config/webpack.config.jsconst flattenObjSass = require('./theme/flatten-obj-sass');sassOptions = { sourceMap: true, prependData: flattenObjSass(require('./theme/get-theme')()),}; styled-jsxstyled-jsx的配置会更麻烦点, 需要在styled-jsx的babel-loader中注入option, 所以不能使用package.json里面的babel.plugins来注入插件了, 而是需要在webpack.config.js中自己注入 1234567891011121314151617181920// config/webpack.config.jsplugins = [ // ... [ 'styled-jsx/babel', { plugins: [ [ 'styled-jsx-plugin-sass', { sassOptions: { data: require('./theme/flatten-obj-sass')(require('./theme/get-theme')()), }, }, ], ], }, ],]; 使用和问题上面的配置完成后, 看起来就比较完美了, 在代码中可以使用三种方式来设置主题配置 使用js直接引入, 如color: ${THEME.primary_color}; 使用sass变量, 如color: $primary_color; 使用class注入, 这是在App.scss中使用sass脚本语法自动生成的相关变量的class, 如className='theme-color-primary_color' 但是在实际开发使用中却碰见了一个大问题: 修改primary_color的值之后, 使用第二种方式引入的组件颜色不会改变 因为sass和less的变量注入都是在编译前注入的, 所以需要重启才能生效, 也是正常流程, 但是styled-jsx里的sass变量属性重启后都没效果, 所以猜想是缓存的原因 styled-jsx-sass缓存问题仔细排查一番以后发现了原因: styled-jsx的编译是通过babel-loader注入的, 而babel-loader在编译完成一份文件后, 会将所有编译参数和文件内容作为一个module放入cache中, 如果没有任何参数改变, 下次就不会走完整的编译流程, 而是直接使用现成的编译结果. 问题就出现在这里, 我们修改完theme文件中的primary_color变量后, 对于babel-loader编译的组件来说实际上没有任何改变, 所以不会重新编译, 而sass-options却是在编译时动态注入的, 不重新编译就不会注入新的变量, 所以导致了旧的组件代码修改sass变量不会生效 排查到具体原因后解决起来就比较简单了, babel-loader提供了customize设置, 我们可以将theme加入对应文件的编译参数即可 这里注意一下, 我们只需要将包含styled-jsx的组件加上theme注入即可, 其他没有使用过的不需要, 可以减少编译次数 12// config/webpack.config.jsbabelLoader.options.customize = path.resolve('./config/theme/theme-cache-babel-custom-loader.js'); 12345678910111213141516171819202122// config/theme/theme-cache-babel-custom-loader.jsconst getTheme = require('./get-theme');const build = (custom) =&gt; { return (babel) =&gt; { const preCustom = custom ? custom(babel) : {}; return { ...preCustom, config(config, { source, map: inputSourceMap, customOptions }) { const result = preCustom.config ? preCustom.config(config, { source, map: inputSourceMap, customOptions }) : config.options; const plugins = result.plugins; const styledJsxPlugin = _.find(plugins, (x) =&gt; _.isMatch(x, { file: { request: 'styled-jsx/babel' } })); if (styledJsxPlugin &amp;&amp; /&lt;style\\s+jsx(\\s|&gt;)/.test(source)) { styledJsxPlugin.options.theme = getTheme(false); } return result; }, }; };};module.exports = build(require('babel-preset-react-app/webpack-overrides')); 小结这里通过sass编译时动态注入变量的方式实现了全局统一主题配置, 但仍然存在的问题是不方便做主题切换, 看了一下antd自己实现的动态主题切换发现是引入了less页面编译, 这样不太友好而且会导致页面卡顿. 而且看了下sass貌似没有动态主题切换的功能, 所以目前项目的多主题色只能通过预先设置好的主题配置文件来实现, 如果需要新增一套主题, 则需要新增一份配置以及切换选项, 无法实现自定义主题色的功能 但除开动态自定义主题的问题以外, 其他功能都比较完善了, 比较好用的点有 统一变量样式定义文件 jsx动态注入js或sass变量 sass全局变量文件 通过className实现快速样式设置 通过全局className实现主题切换 CSS variablescss变量动态切换主题是最新的一种方案, 没有使用它的原因是: 即使使用了它, 也只能优化我们sass变量的写法, 无法对antd的less变量生效 某些语法写起来比较别扭, 也不支持如sass提供的一系列函数方法, 自定义程度暂时还不够高 兼容性不够好 但是感觉这个方法才是未来的方向, 可以实现在全局范围内实时替换所有主题变量, 再也不需要静态编译和修改配置文件了","link":"/2019/10-10-react-app-framework-css/"},{"title":"React App Framework - 5. i18n","text":"前言已有的react-i18n方案和框架也有一些了, 基本都是使用react-i18next和i18next来实现多语言支持的, 唯一稍有不足的几点是: 语言状态保存在i18n库中, 需要手动和全局绑定 通过t('str')的方式来调用, 如果手误写错了key不容易发现, 而且后期在维护key的使用的情况的时候不够友好, 需要修改为ts更友好的方案 切换语言的时候还需要同时切换moment和antd的语言 子应用语言需要隔离使用, 不能互相干扰 开发全局绑定首先是需要将language状态保存到全局store中, 初始值根据本地存储-&gt;浏览器语言的优先级来确认 这里注意在获取默认语言和切换语言之后, 记得将html标签的lang属性设置为当前语言, 否则浏览器会提示语言翻译提示弹窗 1234567891011121314151617181920212223242526272829// globalConfigDucks.tslet storeLanguage: StoreTranslationLanguage = store.get(CONSTANT.STORE_KEYS.STORE_TRANSLATION_LANGUAGE, '') as StoreTranslationLanguage;if (!CONSTANT.LANGUAGE_OPTIONS.map((x) =&gt; x.value).includes(storeLanguage)) { if (_.startsWith(navigator.language, 'zh')) { storeLanguage = 'zh'; } else { storeLanguage = 'en'; }}window.document.querySelector('html').setAttribute('lang', CONSTANT.LANGUAGE_OPTIONS.find((item) =&gt; item.value === storeLanguage).htmlLang);const initGlobalConfig: GlobalConfig = { language: storeLanguage, app: null, project: null, permission: null, permissionLoading: false,};const reducer = (state: GlobalConfig = initGlobalConfig, action: Action): GlobalConfig =&gt; { switch (action.type) { case 'GLOBAL_CHANGE_LANGUAGE': window.document.querySelector('html').setAttribute('lang', CONSTANT.LANGUAGE_OPTIONS.find((item) =&gt; item.value === action.payload).htmlLang); store.set(CONSTANT.STORE_KEYS.STORE_TRANSLATION_LANGUAGE, action.payload); return { ...state, language: action.payload }; default: return state; }}; 应用多语言还是在Root组件中, 第一次加载的时候初始化moment和antd的语言, 然后通过useEffect监听language的变化 123456789101112131415161718192021222324252627const Root = () =&gt; { const { i18n } = useTranslation(); const language = useSelector((state: AppState) =&gt; state.globalConfig.language); const [languageState, setLanguageState] = useState &lt; typeof CONSTANT.LANGUAGE_OPTIONS[number] &gt; (() =&gt; { const selectLanguage = CONSTANT.LANGUAGE_OPTIONS.find((x) =&gt; x.value === language); moment.locale(selectLanguage.moment); i18n.changeLanguage(selectLanguage.i18n); return selectLanguage; }); useUpdate(() =&gt; { const selectLanguage = CONSTANT.LANGUAGE_OPTIONS.find((x) =&gt; x.value === language); moment.locale(selectLanguage.moment); i18n.changeLanguage(selectLanguage.i18n); setLanguageState(selectLanguage); }, [language]); return ( &lt;ErrorBoundary&gt; &lt;ConfigProvider locale={languageState.antd}&gt;&lt;/ConfigProvider&gt; &lt;/ErrorBoundary&gt; );}; ts友好为了使应用多语言的时候出现ts的代码检测和提示, 需要修改下语言文件的声明结构和t的调用方式, 保证如果t('str')里面的str如果填写错误, ts编译时就能检查出来, 而且在使用的时候也会出现智能提示 使用下面方式声明的好处是能保证每个key一定存在所有语言的翻译, 不会出现人工疏忽漏掉某个语言的情况 123456789101112131415161718192021222324252627// translation.tsimport CONSTANT from './constant';export type Translation = { [x: string]: { [x in typeof CONSTANT.LANGUAGE_OPTIONS[number]['value']]: string };};const TRANSLATION = { ERROR: { zh: '错误', en: 'Error', }, LOGIN_IN: { zh: '登录', en: 'Login', }, LOGIN_OUT: { zh: '登出', en: 'Login Out', }, LOADING: { zh: 'Loading...', en: 'Loading...', },} as const;export default TRANSLATION; 12345678910// use-translation.tsimport { useTranslation } from 'react-i18next';import TRANSLATION from '../config/translation';const _useTranslation = (): ((key: keyof typeof TRANSLATION) =&gt; string) =&gt; { const { t } = useTranslation(); return (key: keyof typeof TRANSLATION) =&gt; t(key);};export default _useTranslation; i18n加载这里全局的语言比较简单, 直接初始化的时候将translation文件里的数据结构变为i18n需要的数据传入即可 123456789101112131415161718192021222324252627282930313233import i18n from 'i18next';import { initReactI18next } from 'react-i18next';import CONSTANT from './constant';import TRANSLATION from './translation';export type Resources = { [x in typeof CONSTANT.LANGUAGE_OPTIONS[number]['value']]: { [x: string]: { [key: string]: string; }; };};const resources: Resources = _.extend({}, ..._.map(CONSTANT.LANGUAGE_OPTIONS, (x) =&gt; ({ [x.i18n]: { translation: {} } })));_.map(TRANSLATION, (translation, key) =&gt; { _.map(CONSTANT.LANGUAGE_OPTIONS, (x) =&gt; { resources[x.i18n]['translation'][key] = translation[x.i18n]; });});i18n.use(initReactI18next).init({ fallbackLng: CONSTANT.LANGUAGE_OPTIONS[0].value, debug: false, interpolation: { escapeValue: false, }, resources: resources,});i18n.changeLanguage(CONSTANT.LANGUAGE_OPTIONS[0].value);export default i18n; 子应用语言加载这里就会比较麻烦一点, 类似子应用store的方案, 需要在切换子应用的时候自动注入子应用的翻译到全局 函数式组件没有construct方法, 想要在第一时间注入翻译的话, 这里使用了useMemo模拟初次加载, useEffect不合适是因为调用时组件已经渲染过一次了 12345678910111213141516171819202122232425262728293031323334353637const SubApp: React.FC&lt;{ app: AllAppOptions, menu: SubAppMenu, showMenu: boolean, translation: Translation, reducers?: ReducersMapObject&lt;any, any&gt;, preloadedState?: any, store?: Store&lt;{}, Action&gt;,}&gt; = ({ app, menu, showMenu, children, reducers, preloadedState, store, translation }) =&gt; { const { i18n } = useTranslation(); useMemo(() =&gt; { const resources: Resources = _.extend({}, ..._.map(CONSTANT.LANGUAGE_OPTIONS, (x) =&gt; ({ [x.value]: { [app]: {} } }))); _.map(translation, (translation, key) =&gt; { _.map(CONSTANT.LANGUAGE_OPTIONS, (x) =&gt; { resources[x.i18n][app][key] = translation[x.i18n]; }); }); _.map( CONSTANT.LANGUAGE_OPTIONS.map((x) =&gt; x.i18n), (x) =&gt; { i18n.addResourceBundle(x, app, resources[x][app], true, true); }, ); }, [i18n]); useEffect( () =&gt; () =&gt; { _.map( CONSTANT.LANGUAGE_OPTIONS.map((x) =&gt; x.i18n), (x) =&gt; { i18n.removeResourceBundle(x, app); }, ); }, [i18n], );}; 子应用的i18n子应用的useTranslation会稍有区别, 因为我们是将不同的子应用注入到了不同的namespace下, 所以需要特殊指定一下即可, 并且它们各自的翻译key都是独立的, 所以需要从自己的translation中获取 12345678910// use-app-translation.tsimport { useTranslation } from 'react-i18next';import TRANSLATION from '../config/translation';const useAppTranslation = (): ((key: keyof typeof TRANSLATION) =&gt; string) =&gt; { const { t } = useTranslation('app'); return (key: keyof typeof TRANSLATION) =&gt; t(key);};export default useAppTranslation;","link":"/2019/11-14-react-app-framework-i18n/"},{"title":"React App Framework - 6. Permission","text":"前言在大型项目内, 权限控制也是个老生常谈的问题了, 目前已有的权限系统没有继承的功能, 在多维度管理的时候非常难用而且无法统一管理, 所以我独立设计了一套基于RBAC的带继承的权限系统, 我的设计理念也非常简单, 权限只需要提供一个最简单的查询接口: 根据子应用(app)/项目(project)/用户(user)返回他所有的权限点集合就行. 具体的权限设计这里不展开详细讲解, 重点核心内容是基础组与继承, 子应用和项目实际用到的角色都是由基础组派生出来的, 所以在新增权限点和修改角色权限的时候都非常简单. 而且能生成一份完整的角色树缓存, 在修改时修改db后更新缓存树, 在查询的时候的性能也非常高. 这里主要说说前端如何最简单的使用这套权限系统 应用用户信息一般的流程是进入系统后发现没有登录, 自动跳转到登录页, 只需要在Root组件里加上登录状态的检查即可 这里需要注意的是为了减少渲染和防止信息泄露, 需要在登录之后再去加载子应用和菜单组件 登录状态检查不依赖任何数据检查, 直接尝试请求用户信息接口, 如果请求成功则认为用户有效, 并写入全局store 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const dispatch = useDispatch();const userInfo = useSelector((state: AppState) =&gt; state.globalConfig.userInfo);const [loginState, setLoginState] = useState&lt;{ loading: boolean; data: AuthUserInfo; error: Error;}&gt;({ loading: false, data: null, error: null,});useEffect(() =&gt; { if (userInfo) { return; } (async () =&gt; { setLoginState({ loading: true, data: null, error: null, }); try { const result = await UTILS.get&lt;{ code: number; msg: string; data: AuthUserInfo }&gt;( `${api.uauth.getUserInfo()}?${queryString.stringify( { apps: _.uniq(_.map(CONSTANT.ALL_APPS, (app) =&gt; app.authApp)) }, { arrayFormat: 'index' }, )}`, ); if (result.status === 200) { setLoginState({ loading: false, data: result.data.data, error: null, }); dispatch(userInfoDucks.refreshUserInfo(result.data.data)); } else if (result.status !== 200) { throw new Error(result.data.msg); } } catch (e) { console.warn(`Login error:`, e); setLoginState({ loading: false, data: null, error: e, }); goLogin(); } })();}, [userInfo]); 项目列表在上面的userInfo接口中, 已经返回了该用户拥有的各子应用有权限的项目, 这里只需要在项目列表渲染时取出对应的项目信息即可 1234567891011121314151617181920// app-header-nav.tsxconst RootAppHeaderNav = () =&gt; { const projects = globalConfig.appConfig[globalConfig.app]?.allProjects || []; return ( &lt;div&gt; {projectSearchShowState &amp;&amp; ( &lt;HeaderProjectSelect projects={projects} project={globalConfig.project} onSelect={(project: Project) =&gt; { dispatchProjectSearchShowState({ type: 'HIDE' }); changeProjectWithRouter(project); }} onCancel={() =&gt; dispatchProjectSearchShowState({ type: 'HIDE' })} /&gt; )} &lt;/div&gt; );}; 在main组件渲染时候需要检查是否选择过项目以及项目是否有权限, 否则默认跳转到上次打开的项目或者第一个有权限的项目 1234567891011121314151617181920212223242526272829303132333435363738394041// app-main.tsxconst RootAppProjectContainer: React.FC&lt;{ routeProps: RouteComponentProps,}&gt; = ({ routeProps }) =&gt; { const { globalConfig, userInfo } = useSelector((state: AppState) =&gt; ({ globalConfig: state.globalConfig, userInfo: state.userInfo }), _.isEqual); const projects = globalConfig.appConfig[globalConfig.app].allProjects; return !userInfo ? null : projects.length === 0 ? ( &lt;Redirect to='/user/project-list' /&gt; ) : ( &lt;Switch&gt; &lt;Route exact path={`${routeProps.match.url}`} render={(props) =&gt; { const project = getProject(app, projects); return &lt;TransformDefaultProject project={project} url={routeProps.match.url} /&gt;; }} /&gt; &lt;Route path={`${routeProps.match.url.replace(/\\/$/, '')}/:project`} render={(props) =&gt; { const project = getProject(app, projects, props.match.params.project); return globalConfig.project?.code !== project.code ? ( &lt;TransformProject project={project} changeRouter={project.code !== props.match.params.project} /&gt; ) : ( &lt;RouteLazyComponent app={app} isApp project={project} title={title} import={import(/* webpackChunkName: &quot;[request]&quot; */ `./../../../containers/${app}/index.tsx`)} routeProps={props} /&gt; ); }} /&gt; &lt;Route render={() =&gt; &lt;Redirect to={routeProps.match.url} /&gt;} /&gt; &lt;/Switch&gt; );}; 项目权限在切换项目或者切换app的时候, 都会触发changeProjectApp的action, 这时候通过redux-thunk去获取用户在项目中的权限点, 并且更新到全局store中. 这里注意在reduce的时候, 需要判断传入的信息和当前系统状态是否一致, 否则可能发生快速多次切换项目后权限出错的情况 123456789101112131415161718192021222324dispatch({ type: 'GLOBAL_CHANGE_USER_PROJECT_PERMISSION_LOADING_STATUS', payload: { project: project, app: app, loading: true },});try { const permission = await UTILS.restful.fetch&lt;{ code: number; data: { codes: string[] }; msg: string }&gt;( api.uauth.getUserPermission(CONSTANT.ALL_APPS[app].authApp, project.code), ); if (permission.data?.code !== 200) { throw new Error(permission.data?.msg); } permissionSet = new Set(permission.data?.data?.codes || []);} catch (e) { console.warn(`get [${app}] [${project.code}] user permission error`, e);} finally { dispatch({ type: 'GLOBAL_CHANGE_USER_PROJECT_PERMISSION', payload: { project: project, app: app, permission: permissionSet }, }); dispatch({ type: 'GLOBAL_CHANGE_USER_PROJECT_PERMISSION_LOADING_STATUS', payload: { project: project, app: app, loading: false }, });} 菜单权限这一步就比较简单了, 直接从全局store里获取到用户当前权限, 判断菜单配置的权限点, 如果没有配置或者拥有对应权限, 就进行直接渲染 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const AppLeftMenu = () =&gt; { const permission = useSelector((state: AppState) =&gt; state.globalConfig.permission); const noEmptyPermission = useMemo(() =&gt; permission || new Set(), [permission]); return ( &lt;div&gt; {menu.children .filter((c) =&gt; !c.hide &amp;&amp; (!c.permission || noEmptyPermission.has(c.permission))) .map((c) =&gt; ( &lt;NavLink exact={!!c.exact || c.path === ''} activeClassName='active' className='menu-item-children-item' to={c.to ? c.to : `${!c.path ? match.url : match.url.replace(/\\/$/, '')}${c.path}`} key={c.name} &gt; &lt;span className='menu-item-children-item-icon' /&gt; &lt;span className='menu-item-children-item-text'&gt;{t(c.name)}&lt;/span&gt; &lt;/NavLink&gt; ))} &lt;/div&gt; );};const AppMain = () =&gt; { const permission = useSelector((state: AppState) =&gt; state.globalConfig.permission); return ( &lt;&gt; {!permission ? null : ( &lt;Switch&gt; {menu .filter((c) =&gt; !c.permission || permission.has(c.permission)) .map((p) =&gt; { const pc = p as SubAppMenuParentHasChildren; const pi = p as SubAppMenuParentItem; return _.size(pc.children) &gt; 0 ? ( pc.children .filter((c) =&gt; !c.permission || permission.has(c.permission)) .map((c) =&gt; ( &lt;Route exact={!c.path ? true : !!c.exact} key={c.name} path={!c.path ? match.url : `${match.url.replace(/\\/$/, '')}${c.path}`} render={(props) =&gt; ( &lt;RouteLazyComponent app={app} subApp={subApp} isApp={false} path={c.component_name} title={c.title} project={project} import={import(/* webpackChunkName: &quot;[request]&quot; */ `./../../containers/${app}/containers/${c.component_name}/index.tsx`)} routeProps={props} /&gt; )} /&gt; )) ) : ( &lt;Route exact={!pi.path ? true : !!pi.exact} key={p.name} path={!pi.path ? match.url : `${match.url.replace(/\\/$/, '')}${pi.path}`} render={(props) =&gt; ( &lt;RouteLazyComponent app={app} subApp={subApp} isApp={false} path={pi.component_name} title={p.title} project={project} import={import(/* webpackChunkName: &quot;[request]&quot; */ `./../../containers/${app}/containers/${pi.component_name}/index.tsx`)} routeProps={props} /&gt; )} /&gt; ); })} {_.size(menu) &amp;&amp; &lt;Route render={() =&gt; &lt;Redirect to={`${match.url}`} /&gt;} /&gt;} &lt;/Switch&gt; )} &lt;/&gt; );}; 权限组件为了减少需要使用权限的组件的开发量, 提供一个通用的权限控制组件, 可以减少代码中的store的引用 12345678const PermissionComponent: React.FC&lt;{ code: string, children: ReactElement, empty?: ReactElement,}&gt; = ({ code, children, empty = null }) =&gt; { const permission = useSelector((state: AppState) =&gt; state.globalConfig.permission); return permission.has(code) ? children : empty;}; 小结外层将权限封装完成后, 对于各子应用来说, 各自的权限使用和限制就非常简单了, 也不用担心出bug, 不过后端接口的权限限制还是必须得有的, 同样是通过上面的用户项目权限接口验证即可, 对于egg来说, 使用一个通用的权限中间件就能简单的搞定","link":"/2019/12-05-react-app-framework-permission/"},{"title":"React App Framework - 7. App title &amp; icon","text":"前言在切换页面时, 需要动态显示当前页面的标题, 而且需要支持多语言切换, 以及每个子应用会有自己的icon, 也需要统一显示 实现iconicon替换其实挺简单的, 在SubApp组件加载时设置即可, 注意一下在卸载app的时候将icon还原就行 123456789101112const SubApp = () =&gt; { useEffect(() =&gt; { if (AppIconSrc) { const icon = document.querySelector&lt;HTMLLinkElement&gt;('link[rel=&quot;shortcut icon&quot;]'); const preIcon = icon.href; icon.href = AppIconSrc; return () =&gt; { icon.href = preIcon; }; } }, []);}; titletitle的级别是每个页面不同, 所以需要在之前实现的RouteLazyComponent组件上实现, 这里注意下使用翻译后的key作为deps的依赖就能实现语言变化后自动刷新标题栏 这里使用useMemo的原因是, useEffect是从子组件调用到父组件的, 会导致最外层的app.title被最后设置, 覆盖实际页面设置的标题, 所以只能使用useMemo来保证最终的标题是正确的 123456789101112131415161718const RouteLazyComponent = () =&gt; { const { t } = useTranslation(); useMemo(() =&gt; { const appTitle = t(App.title); if (isApp) { document.title = appTitle; return; } const pageTitle = t(`${app}:${title}`); if (App.hasProject &amp;&amp; project) { document.title = `${pageTitle ? `${pageTitle} - ` : ''}${project.code} - ${appTitle}`; return; } document.title = `${pageTitle ? `${pageTitle} - ` : ''}${appTitle}`; return; }, [title, project, t(`${app}:${title}`), t(App.title)]);}; 小结本次实现的内容还是挺简单的, 但是对于用户体验来说是很重要的, 开发过程中稍微注意下翻译值和useEffect的调用顺序的问题就可以了","link":"/2019/12-12-react-app-framework-app-title/"},{"title":"React App Framework - 8. Others-IconFont","text":"主要框架内容其实已经基本完善了, 也已经上线了几个子应用了, 以后就逐渐记录相关优化和杂项内容了, 今天记录一个基础的IconFont和一个简单的HashColor实现 IconFont其实这个组件antd官网已经给出标准实现了, 就不赘述了, 唯一有点特殊的是, 我们项目有两套风格的图标, 可以实现在打包时指定使用哪套IconFont, 实际上就是通过webpack.DefinePlugin注入到环境变量中然后打包时读取的 12345678import { createFromIconfontCN } from '@ant-design/icons';import CONSTANT from '../../config/constant';const IconFont = createFromIconfontCN({ scriptUrl: CONSTANT.ICON_FONT_URL,});export default IconFont; HashColor这是一个比较常见的需求: 需要对不同的Tag标记不同的颜色, 但是相同的Tag的颜色需要一样, 所以不能简单的用index取模或者排序实现, 需要实现一个简单的Hash函数 12345678910111213141516const DJBHash = (str: string): number =&gt; { let hash = 5381; _.map(str, (char) =&gt; { hash = (hash &lt;&lt; 5) + hash + char.charCodeAt(0); }); return hash;};const hash = { DJBHash: DJBHash,};export default hash;// 使用const color = GLOBAL_CONSTANT.ANTD_TAG_COLORS[Math.abs(UTILS.hash.DJBHash(tag) % GLOBAL_CONSTANT.ANTD_TAG_COLORS.length)];","link":"/2020/01-06-react-app-framework-others-iconfont/"},{"title":"React App Framework - 9. Single Build","text":"背景在框架开发完成后, 已经有好几个子应用开发嵌入了, 不过突然来了个新需求, 需要单独部署某个子应用到一个独立的环境提供服务, 而且由于是测试性质的, 还需要禁用掉登录鉴权 独立打包方案一: 修改配置这个实现起来很简单也很自然, 由于我们的子应用都是根据配置去container文件夹动态import的, 在需要单独部署的情况下, 通过环境变量注入将其他子应用的配置去掉就行, 但是这样存在一个问题, 由于我们的import()实现的是动态引入, 所以webpack还是会将container路径下的所有子系统打包, 包括他们的依赖项等等, 会增加最终页面大小和打包时长. 方案二: 修改打包脚本这个是我实现的最终方案, 通过修改webpack的打包脚本, 实现只对指定子应用内容打包, 可以极大的缩短打包时长, 和页面大小 实现原理就是通过webpack.IgnorePlugin插件, 在打包时候忽略掉其他所有子应用文件夹, 同时通过环境变量注入当前运行是单应用场景, home页面做一下兼容适配即可 123456789101112131415161718// webpack.single.config.jsconst plugins = [];const singleApp = process.env.SINGLE_APP || '';const defaultDefineVariables = { 'process.env.single-app': `null`,};if (singleApp) { plugins.push( new webpack.IgnorePlugin({ resourceRegExp: new RegExp(`^\\\\.[/\\\\\\\\](${apps.filter((app) =&gt; app !== singleApp).join('|')})`), }), ); defaultDefineVariables['process.env.single-app'] = `'${singleApp}'`; plugins.push(new webpack.DefinePlugin(defaultDefineVariables));} 12// config/constants.tsconst SINGLE_APP: AppOptions = process.env['single-app'] as AppOptions; 开发完成后带上analyze打包一次, 可以发现所有其他子应用的引用和模块都不存在了, 包括它们内部引入的其他模块, 只剩下当前子应用的部分, 页面体积和文件数量都减少了非常多 禁用鉴权这个实现起来流程比较简单, 但是内容比较繁琐, 首先在各子应用的config中添加needAuth字段, 然后在app-main和left-menu中添加对应的判断逻辑, 最后通过环境变量实现打包时修改app的needAuth值 123456789// webpack.single.config.jsconst needAuth = !process.env.NO_AUTH || true;const defaultDefineVariables = { 'process.env.need-auth': JSON.stringify(needAuth),};plugins.push(new webpack.DefinePlugin(defaultDefineVariables)); 1234567// config/constants.tsconst NEED_AUTH: boolean = process.env['need-auth'];if (!NEED_AUTH) { _.map(APPS, (app) =&gt; _.set(app, `needAuth`, false));} 全局组件的各处鉴权控制代码的逻辑由于比较零碎, 这里就不再赘述了, 实际使用的时候也可以发现问题了再修改, 总体框架是已经完成了","link":"/2020/01-19-react-app-framework-single-build/"},{"title":"React App Framework - 10. Include App","text":"背景上次开发完单应用部署后, 又出现了一个类似的需求: 由于公司内部网络环境的问题, 部分子应用需要部署在另一个不互通的内网中 实现方式有上次单应用的开发经验后, 这次就比较简单了, 直接通过一个传参来筛选需要的子应用即可, 这次同时实现白名单和黑名单功能, 方便使用 webpack配置123456789101112131415161718192021222324252627282930313233343536// webpack.build-app.config.jsconst plugins = [];const includeApp = process.env.INCLUDE_APP || '';const excludeApp = process.env.EXCLUDE_APP || '';const defaultDefineVariables = { 'process.env.include-app': `null`,};if (includeApp &amp;&amp; excludeApp) { throw new Error('includeApp and excludeApp can not be set at the same time');}let includeAppList = [];if (includeApp || excludeApp) { if (includeApp) { includeAppList = includeApp.split(','); } else if (excludeApp) { includeAppList = _.difference(apps, excludeApp.split(',')); }}if (includeAppList.length) { const errorApps = _.difference(includeAppList, apps); if (errorApps.length) { throw new Error(`Select error app: [${errorApps.join(',')}], app should in ${apps.join(', ')}`); } console.info(`Build app: ${includeAppList.join(',')}`); defaultDefineVariables['process.env.include-app'] = `[${includeAppList.map((app) =&gt; `'${app}'`).join(',')}]`; plugins.push( new webpack.IgnorePlugin({ resourceRegExp: new RegExp(`^\\\\.[/\\\\\\\\](${apps.filter((app) =&gt; !includeAppList.includes(app)).join('|')})[/\\\\\\\\]`), }), );} constants配置12345678// config/constants.tsconst INCLUDE_APPS: string[] = process.env['include-app'];if (INCLUDE_APPS.length) { _.map(_.difference(_.keys(APPS), INCLUDE_APPS), (app) =&gt; { Reflect.deleteProperty(APPS, app); });} 使用12INCLUDE_APP=app1,app2 npm run buildnpm run build -- --include-app=app1,app2","link":"/2020/02-11-react-app-framework-include-app/"},{"title":"Iframe RPC 调用","text":"背景有个比较老的项目, 需要跨iframe通讯. 主要原因是后端不想对所有接口开跨域, 而有部分通用信息需要保存在后端接口的统一域名下的localStorage或cookie中, 在无法去掉iframe的情况下, 只能优化iframe的调用过程了. 旧的基本都是直接使用document.createElement('iframe')注入, 然后postMessage返回结果, 对于ts来说开发十分不友好, 基本全是any类型 开发page这里实现接受iframe传回的调用请求, 并将本地方法执行完成之后通过postMessage发送回iframe, 并提供一个调用iframe里方法的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Page { private init() { window.addEventListener('message', this.handleMessageEvent, false); } private async handleMessageEvent(event) { const handler = { callPageFn: async (data) =&gt; { const iframeId = data.iframeId; if (!iframeId) return; const iframe = this.iframeData[iframeId]; if (!iframe) return; if (data.fnId &amp;&amp; localPageFunction.includes(data.fn) &amp;&amp; iframe.$iframe &amp;&amp; iframe.$iframe.contentWindow) { const result = await this.localFn[data.fn](data.params); iframe.$iframe.contentWindow.postMessage( JSON.stringify({ type: 'callPageFnCallback', fnId: data.fnId, result: result }), iframe.$iframe.getAttribute('src'), ); } }, }; try { const data: { type: typeof MessageType[number]; iframeId: string; [key: string]: any } = JSON.parse(event.data); handler[data.type](data); } catch (error) { return; } } private async transformCorsData&lt;T = { [key: string]: string }&gt;(fn: TransformCorsDataPageOptions['fn'], options: any = {}) { const $iframe = document.createElement('iframe'); const iframeId = this.generateIframeId(); $iframe.src = ``; $iframe.onload = () =&gt; { this.iframeData[iframeId].loaded = true; }; const $page = this.addIframe($iframe, '', 0, 0, false, iframeId, null, true); return await new Promise&lt;T&gt;((resolve) =&gt; { this.iframeData[iframeId] = { $dom: $page, type: 'transformCorsData', $iframe, options: { ...options, closeCb: (data: T) =&gt; resolve(data) }, loaded: false, }; }); }} iframe这里实现一次iframe调用的接口, 调用完后去掉这个iframe并将结果通过postMessage传回页面, 同时可以通过Page提供的callPageFn调用页面提供的方法 12345678910111213141516171819202122232425262728class TransformCorsDataPage { options: TransformCorsDataPageOptions; private callPageFn: callPageFn; async init(options: TransformCorsDataPageOptions) { this.options = { ...options }; this.callPageFn = options.callPageFn; const result: { [key: string]: any } = await this[options.fn]?.(JSON.parse(decodeURIComponent(options.options))); postMessageToParent('close', this.options.referrer, result); } private async getIframeData(): Promise&lt;IframeData&gt; { return localStorage.getItem('iframeData'); } private async getPageData(): Promise&lt;PageData&gt; { const result = await this.callPageFn&lt;PageData&gt;({ method: 'get-page-data', data: {} }); return result; }}const callPageFn: callPageFn = async &lt;T&gt;(fn, params) =&gt; { const currentFnId = (fnId++).toString(); const fnPromise = new Promise&lt;T&gt;((resolve) =&gt; { fnHandlerMap[currentFnId] = { resolve }; }); postMessageToParent('callPageFn', referrer, { fn, params, fnId: currentFnId }); return await fnPromise;};export default new TransformCorsDataPage(); 小结这里只列出了核心的实现, 完成这部分通用逻辑后再想互相调用就可以使用比较简单的async/await调用方法了, 省去了很多开发时间, 而且对ts的支持比较好, 可以根据类型检测避免比较多的低级错误","link":"/2020/03-24-iframe-rpc/"},{"title":"React App - Multi Select","text":"背景antd和react-select其实都有多选和添加新元素功能, 但是不太好用的是如果选择了多项以后的展示会堆叠, 删除操作也比较复杂, 所以我们这边需要开发一个更友好的多选组件 开发过程最终效果这里先把最终结果放上来与antd的对比一下, 证明用三天时间开发这个组件还是非常有意义的 antd的多选组件 自己开发的多选组件 而且支持虚拟滚动/创建选项/全选/清空/模糊搜索等功能, 可以说是全方位超过antd的多选组件了 组件设计组件设计本来是分为两个部分: 选择器和下拉弹出框, 但是后来开发的时候发现还需要一个比较通用的checkbox组件, 所以单独实现了一个span-checkbox组件 选择器用于展示选择项和触发下拉弹窗的控件, 实现起来也比较简单, 基本就是纯粹的div元素和样式设置, 不过这里参考了antd-select, 使用RcTrigger作为触发器, 可以省去实现下拉框弹出收起的动画的代码, 实现和antd相同的动画 组件的传参也基本完全参照antd-select的传参, 只是为了偷懒, 没有额外实现下拉项的Options子组件解析, 只支持options传参 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226import React, { useState, useMemo, useRef, useLayoutEffect } from 'react';import RcTrigger from 'rc-trigger';import classNames from 'classnames';import { SelectProps } from 'antd/lib/select';import { DownOutlined, CloseOutlined, LoadingOutlined } from '@ant-design/icons';import { useUpdate, useTranslation } from '../../use';import MultiSelectPopup from './popup';const placements = { // Enable horizontal overflow auto-adjustment when a custom dropdown width is provided bottomLeft: { points: ['tl', 'bl'], offset: [0, 4], overflow: { adjustX: 1, adjustY: 1, }, }, topLeft: { points: ['bl', 'tl'], offset: [0, -4], overflow: { adjustX: 1, adjustY: 1, }, },};const MIN_POPUP_WIDTH = 200;export type MultiOptionType&lt;T extends string | number&gt; = { value: T; label: React.ReactNode; data?: any };export type MultiSelectProps&lt;T extends string | number&gt; = Pick&lt; SelectProps&lt;T[]&gt;, | 'className' | 'disabled' | 'dropdownClassName' | 'dropdownRender' | 'getPopupContainer' | 'mode' | 'placeholder' | 'showArrow' | 'showSearch' | 'value' | 'onDropdownVisibleChange' | 'open'&gt; &amp; { /** * 如果 mode === tag, 且value是number类型, 此值需要设置为true */ valueIsNumber?: boolean; searchPlaceholder?: string; loading?: boolean; onChange: (value: T[]) =&gt; void; options: MultiOptionType&lt;T&gt;[]; filterOption?: (inputValue: string, option: MultiOptionType&lt;T&gt;) =&gt; boolean;};export type MultiSelectComponent&lt;T extends string | number&gt; = React.FC&lt;MultiSelectProps&lt;T&gt;&gt;;const MultiSelect: { &lt;T extends string | number = string&gt;(...args: Parameters&lt;MultiSelectComponent&lt;T&gt;&gt;): ReturnType&lt;MultiSelectComponent&lt;T&gt;&gt;;} = &lt;T extends string | number = string&gt;({ className, disabled = false, dropdownClassName, dropdownRender, filterOption, getPopupContainer, mode = 'multiple', placeholder, showArrow = true, showSearch = true, valueIsNumber = false, searchPlaceholder = 'Search...', loading = false, value, onDropdownVisibleChange, onChange, open = false, options = [],}: Parameters&lt;MultiSelectComponent&lt;T&gt;&gt;[0]) =&gt; { const t = useTranslation(); const [focusState, setFocusState] = useState(open); const [openState, setOpenState] = useState(open); useUpdate(() =&gt; { if (open !== openState) { setOpenState(open); } }, [open]); const changeVisiable = (visiable: boolean) =&gt; { setOpenState(visiable); onDropdownVisibleChange &amp;&amp; onDropdownVisibleChange(visiable); }; const selectedOptions = useMemo(() =&gt; { const optionsMap = _.mapKeys(options, 'value'); return _.map(value, (x) =&gt; optionsMap[x] || { label: x, value: x }); }, [options, value]); const triggerDivRef = useRef&lt;HTMLDivElement&gt;(null); const [popupWidthState, setPopupWidthState] = useState(MIN_POPUP_WIDTH); useLayoutEffect(() =&gt; { if (openState) { setPopupWidthState(_.max([triggerDivRef.current.clientWidth, MIN_POPUP_WIDTH])); } }, [openState]); return ( &lt;RcTrigger builtinPlacements={placements} popupPlacement='bottomLeft' popupTransitionName='slide-up' action={disabled || loading ? [] : ['click']} popupClassName={classNames('padding-0', dropdownClassName)} prefixCls='ant-select-dropdown' getPopupContainer={getPopupContainer} popupVisible={openState} onPopupVisibleChange={changeVisiable} popup={ &lt;MultiSelectPopup&lt;T&gt; value={value} open={openState} onChange={onChange} create={mode === 'tags'} searchPlaceholder={searchPlaceholder} options={options} width={popupWidthState} valueIsNumber={valueIsNumber} showSearch={showSearch} filterOption={filterOption} /&gt; } &gt; &lt;div className={classNames(`ant-select ant-select-multiple multi-select`, className, { 'ant-select-focused': focusState || openState, 'ant-select-open': openState, 'ant-select-disabled': disabled, 'ant-select-show-arrow': showArrow, 'ant-select-show-search': showSearch, })} ref={triggerDivRef} tabIndex={0} onFocus={() =&gt; setFocusState(true)} onBlur={() =&gt; setFocusState(false)} &gt; &lt;div className='ant-select-selector'&gt; {placeholder &amp;&amp; selectedOptions.length === 0 &amp;&amp; &lt;span className='ant-select-selection-placeholder'&gt;{placeholder}&lt;/span&gt;} {selectedOptions.length &gt; 0 &amp;&amp; selectedOptions.length &lt;= 2 &amp;&amp; selectedOptions.map((option) =&gt; ( &lt;span className='ant-select-selection-item' key={option.value}&gt; &lt;span className='ant-select-selection-item-content'&gt;{option.label}&lt;/span&gt; &lt;span className='ant-select-selection-item-remove' onClick={(event) =&gt; { event.stopPropagation(); onChange(value.filter((x) =&gt; x !== option.value)); }} &gt; &lt;CloseOutlined /&gt; &lt;/span&gt; &lt;/span&gt; ))} {selectedOptions.length &gt; 2 &amp;&amp; ( &lt;span className='ant-select-selection-item'&gt; &lt;span className='ant-select-selection-item-content'&gt; {t('MULTI_SELECT_LABEL_SELECTED_ITEM_PREFIX')} &lt;span className='multi-select-popup-options-selected-tips-num'&gt;{selectedOptions.length}&lt;/span&gt; {t('MULTI_SELECT_LABEL_SELECTED_ITEM_SUFFIX')} &lt;/span&gt; &lt;/span&gt; )} {loading ? ( &lt;span className='ant-select-arrow ant-select-arrow-loading'&gt; &lt;LoadingOutlined /&gt; &lt;/span&gt; ) : null} {!loading &amp;&amp; showArrow ? ( &lt;span className='ant-select-arrow'&gt; &lt;DownOutlined /&gt; &lt;/span&gt; ) : null} &lt;/div&gt; &lt;style jsx global&gt;{` .multi-select { outline: 0; &amp;.ant-select-show-search { &amp;.ant-select-multiple { .ant-select-selector { cursor: pointer; flex-wrap: nowrap; overflow: hidden; .ant-select-selection-item { flex-shrink: 1; flex-grow: 0; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; cursor: pointer; } } } &amp;.ant-select-allow-clear, &amp;.ant-select-show-arrow { .ant-select-selector { padding-right: 24px; .ant-select-selection-placeholder { margin-right: 13px; } } } } min-width: 30px; } `}&lt;/style&gt; &lt;/div&gt; &lt;/RcTrigger&gt; );};export default MultiSelect; 下拉弹出框因为使用了RcTrigger的popup作为展示容器, 所以弹出框里面只需要实现自己的样式就行 左右两边的下拉列表都需要使用虚拟滚动实现, 否则在数据量较大的情况下会有卡顿感 用虚拟滚动实现后, 实测10万下拉数据的全选和过滤都不会有卡顿感 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216import React, { useRef, useState, useMemo, useLayoutEffect } from 'react';import { Checkbox, Button } from 'antd';import { FixedSizeList, areEqual, ListChildComponentProps } from 'react-window';import classNames from 'classnames';import { SearchOutlined, DeleteOutlined, CloseOutlined } from '@ant-design/icons';import { MultiOptionType } from './multi-select';import { useTranslation } from '../../use';export type MultiSelectPopupProps&lt;T extends string | number&gt; = { showSearch?: boolean; searchPlaceholder?: string; create?: boolean; value: T[]; open: boolean; onChange: (value: T[]) =&gt; void; options: MultiOptionType&lt;T&gt;[]; filterOption?: (inputValue: string, option: MultiOptionType&lt;T&gt;) =&gt; boolean; width: number; onClick?: (event: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) =&gt; void; listItemHeight?: number; listHeight?: number; /** * 如果 mode === tag, 且value是number类型, 此值需要设置为true */ valueIsNumber?: boolean;};export type MultiSelectPopupComponent&lt;T extends string | number&gt; = React.FC&lt;MultiSelectPopupProps&lt;T&gt;&gt;;const MultiSelectPopup: { &lt;T extends string | number&gt;(...args: Parameters&lt;MultiSelectPopupComponent&lt;T&gt;&gt;): ReturnType&lt;MultiSelectPopupComponent&lt;T&gt;&gt;;} = &lt;T extends string | number&gt;({ showSearch = true, searchPlaceholder = '', create = false, value, open, onChange, options, filterOption, width, onClick, listItemHeight = 32, listHeight = 320, valueIsNumber = false,}: Parameters&lt;MultiSelectPopupComponent&lt;T&gt;&gt;[0]) =&gt; { const t = useTranslation(); const [showSelectedOptionsState, setShowSelectedOptionsState] = useState(true); const [searchValueState, setSearchValueState] = useState(''); const _changeItemFnRef = useRef((item: T, operate: 'add' | 'remove') =&gt; { onChange(operate === 'add' ? value.concat(item) : value.filter((x) =&gt; x !== item)); }); _changeItemFnRef.current = (item: T, operate: 'add' | 'remove') =&gt; { onChange(operate === 'add' ? value.concat(item) : value.filter((x) =&gt; x !== item)); }; const filterOptions = useMemo(() =&gt; { const _filterFn = filterOption || ((inputValue: string, option: MultiOptionType&lt;T&gt;) =&gt; !inputValue || _.toLower(_.toString(option.label)).includes(_.toLower(inputValue)) || _.toLower(_.toString(option.value)).includes(_.toLower(inputValue))); const _searchInputValue = _.trim(searchValueState); const filterOptions = _.filter(options, (option) =&gt; _filterFn(_searchInputValue, option)); if (_searchInputValue &amp;&amp; !_.find(filterOptions, (option) =&gt; option.value === _searchInputValue) &amp;&amp; create) { filterOptions.push({ label: _searchInputValue, value: (valueIsNumber ? _.toNumber(_searchInputValue) : _searchInputValue) as T }); } return filterOptions; }, [options, searchValueState, filterOption]); const { checkStateFilterOptions, checkedAllOptions } = useMemo(() =&gt; { const checkStateFilterOptions = _.map(filterOptions, (x) =&gt; ({ ...x, checked: _.includes(value, x.value) })); return { checkStateFilterOptions, checkedAllOptions: _.every(checkStateFilterOptions, (item) =&gt; item.checked) }; }, [filterOptions, value]); const selectedOptions = useMemo(() =&gt; { const optionsMap = _.mapKeys(options, 'value'); return _.map(value, (x) =&gt; optionsMap[x] || { label: x, value: x }); }, [options, value]); // fix: need calc input item height const minListHeight = _.min([listHeight, _.max([filterOptions.length * listItemHeight, selectedOptions.length * listItemHeight])]); const OptionRow = useMemo( () =&gt; React.memo((props: ListChildComponentProps) =&gt; { const { index, style, data } = props; return ( &lt;div className='ant-select-item ant-select-item-option' style={style} title={data[index].label}&gt; &lt;Checkbox className='ant-select-item-option-content' checked={data[index].checked} onChange={(event) =&gt; _changeItemFnRef.current(data[index].value, event.target.checked ? 'add' : 'remove')} &gt; {data[index].label} &lt;/Checkbox&gt; &lt;/div&gt; ); }, areEqual), [], ); const SelectedOptionRow = useMemo( () =&gt; React.memo((props: ListChildComponentProps) =&gt; { const { index, style, data } = props; return ( &lt;div className='ant-select-item ant-select-item-option' style={style}&gt; &lt;Button className='ant-select-item-option-selected-remove-btn' size='small' onClick={() =&gt; _changeItemFnRef.current(data[index].value, 'remove')} title={data[index].label} &gt; &lt;span className='ant-select-item-option-selected-remove-btn-label'&gt;{data[index].label}&lt;/span&gt; &lt;CloseOutlined className='ant-select-item-option-selected-remove-btn-icon' /&gt; &lt;/Button&gt; &lt;/div&gt; ); }, areEqual), [], ); const inputRef = useRef&lt;HTMLInputElement&gt;(null); useLayoutEffect(() =&gt; { if (open &amp;&amp; inputRef.current) { inputRef.current.focus(); } }, [open]); return ( &lt;div className='multi-select-popup' style={{ width: showSelectedOptionsState ? width * 2 : width }} onClick={onClick}&gt; {showSearch &amp;&amp; ( &lt;div className='multi-select-popup-search-bar'&gt; &lt;SearchOutlined className='multi-select-popup-search-icon' /&gt; &lt;input ref={inputRef} className='multi-select-popup-search-input ant-input' value={searchValueState} onChange={(event) =&gt; setSearchValueState(event.target.value)} placeholder={searchPlaceholder} /&gt; &lt;/div&gt; )} &lt;div className='multi-select-popup-body'&gt; &lt;div className='multi-select-popup-left-content' style={{ width: width }}&gt; &lt;div className='multi-select-popup-options-control-bar'&gt; &lt;Checkbox disabled={checkStateFilterOptions.length === 0} checked={checkStateFilterOptions.length &gt; 0 &amp;&amp; checkedAllOptions} onChange={(event) =&gt; onChange( event.target.checked ? _.union( value, checkStateFilterOptions.map((x) =&gt; x.value), ) : _.difference( value, checkStateFilterOptions.map((x) =&gt; x.value), ), ) } &gt; {t('MULTI_SELECT_LABEL_SELECT_ALL')} &lt;/Checkbox&gt; &lt;Checkbox checked={showSelectedOptionsState} onChange={(event) =&gt; setShowSelectedOptionsState(event.target.checked)}&gt; {t('MULTI_SELECT_LABEL_VIEW_SELECTED_ITEM')} &lt;/Checkbox&gt; &lt;/div&gt; &lt;div className='multi-select-popup-options-list'&gt; &lt;FixedSizeList height={minListHeight} itemCount={checkStateFilterOptions.length} itemSize={listItemHeight} width={width} itemData={checkStateFilterOptions} &gt; {OptionRow} &lt;/FixedSizeList&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className={classNames('multi-select-popup-right-content', { hide: !showSelectedOptionsState })} style={{ width: width }}&gt; &lt;div className='multi-select-popup-options-control-bar'&gt; &lt;span className='multi-select-popup-options-selected-tips'&gt; {t('MULTI_SELECT_LABEL_SELECTED_ITEM_PREFIX')} &lt;span className='multi-select-popup-options-selected-tips-num'&gt;{value.length}&lt;/span&gt; {t('MULTI_SELECT_LABEL_SELECTED_ITEM_SUFFIX')} &lt;/span&gt; &lt;Button className='multi-select-popup-options-remove-all-btn' size='small' type='link' danger onClick={() =&gt; onChange([])}&gt; &lt;DeleteOutlined /&gt; &lt;/Button&gt; &lt;/div&gt; &lt;div className='multi-select-popup-selected-options-list'&gt; &lt;FixedSizeList height={minListHeight} itemCount={selectedOptions.length} itemSize={listItemHeight} width={width} itemData={selectedOptions} &gt; {SelectedOptionRow} &lt;/FixedSizeList&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;style jsx global&gt;{` // 样式比较长, 此处省略 `}&lt;/style&gt; &lt;/div&gt; );};export default MultiSelectPopup; checkbox这里就是简单的封装了一个带label的checkbox, 并且样式直接复用了antd的class, 开发成本较低 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React from 'react';import classNames from 'classnames';import { CheckboxProps } from 'antd/lib/checkbox';const SpanCheckbox: React.FC&lt;CheckboxProps&gt; = ({ prefixCls = 'ant', className, children, indeterminate = false, style, onMouseEnter, onMouseLeave, checked, disabled, id, onChange,}) =&gt; { const clickChangeChecked = (event: React.MouseEvent&lt;HTMLLabelElement, MouseEvent&gt;) =&gt; { if (disabled) { return; } onChange({ target: { checked: !checked, }, stopPropagation() { event.stopPropagation(); }, preventDefault() { event.preventDefault(); }, nativeEvent: event.nativeEvent, }); }; return ( &lt;label className={classNames(className, { [`${prefixCls}-checkbox-wrapper`]: true, [`${prefixCls}-checkbox-wrapper-checked`]: checked, [`${prefixCls}-checkbox-wrapper-disabled`]: disabled, })} style={style} onMouseEnter={onMouseEnter} onMouseLeave={onMouseLeave} onClick={clickChangeChecked} &gt; &lt;span className={classNames(`${prefixCls}-checkbox`, { [`${prefixCls}-checkbox-indeterminate`]: indeterminate, [`${prefixCls}-checkbox-checked`]: checked, [`${prefixCls}-checkbox-disabled`]: disabled, })} &gt; &lt;span id={id} className={`${prefixCls}-checkbox-input`} /&gt; &lt;span className={`${prefixCls}-checkbox-inner`} /&gt; &lt;/span&gt; {children !== undefined &amp;&amp; &lt;span&gt;{children}&lt;/span&gt;} &lt;/label&gt; );};export default SpanCheckbox; 小结此基础组件开发完成后是提供全局使用的, 从antd-select切换过来的成本也极低, 开发完成后项目内的所有多选组件都已经替换为此组件了, 性价比还是比较高的","link":"/2020/04-10-react-app-multi-select/"},{"title":"React App - Map Chart","text":"背景之前系统中有关地理信息的图表是直接使用国家/省市名称, 通过柱状图来展示地区数据的区别. 在重构的时候想优化一下这块的展示, 直接使用中国地图/世界地图来展示数据的分布, 我们使用的图表组件是highcharts, 看了一下虽然自带map组件, 但是有个比较严重的问题, 中国地图不标准, 所以我们需要自己生成底图数据, 然后自己渲染. 又研究了一下其他的组件, 发现antv也支持地图绘制, 而且对于自定义地图支持得比较完善, 功能和性能也都比highcharts好. 在支付宝看疫情分布时候发现了和这里demo一模一样效果的地图(感觉就是直接使用这个组件生成的), 支持的地图数据是geojson也比较常见, 所以最终使用antv实现地图渲染. 地图渲染首先按官方文档, 实现地图组件渲染, 然后获取数据后将数据按图层加载到组件中 1234567891011121314151617181920212223if (!antvL7Scene.current) { antvL7Scene.current = new Scene( currentShowItem.type === 'china-map' ? { id: chartRef.current, map: new Mapbox({ pitch: 0, style: 'blank', center: [107.042225, 37.66565], zoom: 2.5, }), } : { id: chartRef.current, map: new Mapbox({ pitch: 0, style: 'blank', center: [0, 40], zoom: 0.5, }), }, );} 生成图层数据, 颜色是根据数据量大小由浅入深的, 这里注意下需要对Sea就是海的部分的事件不要处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const genAntvL7Options = ( result: ESResponse, indicators: DashboardItemChart['indicators'], dimensions: DashboardItemChart['dimensions'], type: typeof CONSTANT.DASHBOARD_CHART_TYPE_CONFIG[number]['type'], antvL7MapData: any, colorOptions: string[],): { baseLayer: ILayer; lineLayer: ILayer; tipsPopup: IPopup; dataSource: Record&lt;string, number | string&gt;[] } =&gt; { const firstDimension = dimensions[0]; const indicator = indicators[0]; const aggsMapData: Record&lt;string, number&gt; = {}; const dataSource: Record&lt;string, number | string&gt;[] = []; // 数据处理部分省略 let maxNum = 0; let minNum = 0; _.map(antvL7MapData.features, (feature) =&gt; { const areaValue = aggsMapData[feature.properties.name]; if (areaValue) { _.set(feature.properties, 'value', areaValue); maxNum = maxNum &gt; areaValue ? maxNum : areaValue; minNum = minNum &lt; areaValue ? minNum : areaValue; } else if (feature.properties.name) { _.set(feature.properties, 'value', 0); } }); maxNum = maxNum + 1; const stepNum = (maxNum - minNum) / (colorOptions.length - 1); const tipsPopup = new Popup({ offsets: [0, 0], closeButton: false, closeOnClick: false, }); const baseLayer = new PolygonLayer({}) .scale('value', { type: 'quantile', }) .source(antvL7MapData) .color('value', (value) =&gt; { if (value === 0) { return colorOptions[0]; } for (let i = 0; i &lt; colorOptions.length - 1; i++) { if (value &gt;= minNum + stepNum * i &amp;&amp; value &lt; minNum + stepNum * (i + 1)) { return colorOptions[i + 1]; } } }) .shape('fill') .style({ opacity: 1, }); baseLayer.on('mousemove', (e) =&gt; { if (e.feature.properties.name === 'Sea') { return; } tipsPopup.setLnglat(e.lngLat).setHTML(`&lt;span&gt;${e.feature.properties.name}: ${e.feature.properties.value} (${indicator})&lt;/span&gt;`); tipsPopup.open(); }); baseLayer.on('mouseout', (e) =&gt; { tipsPopup.close(); }); const lineLayer = new LineLayer({ zIndex: 2, }) .source(antvL7MapData) .color('#000') .size(0.3) .style({ opacity: 1, }); return { baseLayer, lineLayer, tipsPopup, dataSource };}; 将生成的图层添加到地图中 12345678if (antvL7Scene.current.getLayers().length &gt; 0) { antvL7Scene.current.removeAllLayer();}const layerResult = await parseAntvL7Layer(item.dataCache.chartOptions);antvL7Scene.current.addLayer(layerResult.baseLayer);antvL7Scene.current.addLayer(layerResult.lineLayer);antvL7Scene.current.addPopup(layerResult.tipsPopup);item.dataCache.dataSource = layerResult.dataSource; 数据处理其实这里才是最重要的, 上面代码中的antvL7MapData就是这一步得到的. antv支持的底图数据是geojson格式, 也提供了获取方式, 可以在http://datav.aliyun.com/tools/atlas/index.html获取到高德地图开放的地图数据. 这里下载到的数据细致到了市, 目前的需求是只需要省的数据, 所以将数据处理一下即可, 然后在highcharts能下载到完整的全球地图数据, 再将里面的china部分替换成我们的数据即可. 将这两份数据存为两份本地json, 在代码加载的时候动态引入, 可以减少代码体积(虽然写完之后看起来简单, 但是寻找资料和构造这份数据的过程才是最耗时的). 123456const parse = { parseAntvL7Layer: async (result) =&gt; { const antvL7MapData = _.cloneDeep((await import('../../../../static/map/china.geo.json')).default); return genAntvL7Options(result, indicators, dimensions, 'china-map', antvL7MapData, ANTV_MAP_COLORS_CHINA); },};","link":"/2020/04-22-react-app-antv-map/"},{"title":"使用Rollup打包TypeScript","text":"背景提到前端打包工具, 最熟悉和常用的就是webpack了, 但是对于开发纯js库来说, 其实有更好的打包工具可以使用: rollup 与webpack的区别简单对比一下两个打包工具 webpackwebpack的核心概念是一切皆模块, 然后基于模块可以实现代码缓存, 代码分割, 按需加载等特性 但这样在开发简单的js库时候, 打包出来的未压缩包里反而会出现__webpack_require__这样的代码, 压缩过后的min.js代码中也有一些遗留的模块加载的代码, 导致体积会稍大 rolluprollup是一款ES Modules打包工具, 我们经常使用的vue和react都是使用它打包的. 对比起 webpack, rollup的核心特点是: 代码更简洁, 不会存在模块引入的问题. 但不足的是如果需要引入其他资源类型的文件需要其他插件, 而这些插件质量是没有webpack质量高的. 所以作为纯js库开发来说, rollup更轻量快速, 但整体web-app开发还是需要选择大而全的webpack或者其他如vite和parcel等打包工具 开发环境搭建rollup.config纯js的rollup开发环境比较简单, 直接按照官方文档搭建都可以. 但是我们需要使用ts, 所以有些配置需要定制 同时可以看到, 我们这里输出了两种文件: umd类型和es类型, 其中umd类型是用于浏览器的, es类型是用于webpack等打包工具的, webpack会优先引入package.json里的module文件, 实现Tree-shaking 123456789101112131415161718192021222324252627282930313233343536373839// rollup.config.tsimport resolve from 'rollup-plugin-node-resolve';import commonjs from 'rollup-plugin-commonjs';import sourceMaps from 'rollup-plugin-sourcemaps';import camelCase from 'lodash.camelcase';import typescript from 'rollup-plugin-typescript2';import json from 'rollup-plugin-json';import pkg from './package.json';const libraryName = 'my-library';export default { input: `src/${libraryName}.ts`, output: [ { file: pkg.main, name: camelCase(libraryName), format: 'umd', sourcemap: true }, { file: pkg.module, format: 'es', sourcemap: true }, ], // Indicate here external modules you don't wanna include in your bundle (i.e.: 'lodash') external: [], watch: { include: 'src/**', }, plugins: [ // Allow json resolution json(), // Compile TypeScript files typescript({ useTsconfigDeclarationDir: true }), // Allow bundling cjs modules (unlike webpack, rollup doesn't understand cjs) commonjs(), // Allow node_modules resolution, so you can use 'external' to control // which external modules to include in the bundle // https://github.com/rollup/rollup-plugin-node-resolve#usage resolve({ browser: true, preferBuiltins: true, mainFields: ['browser'] }), // Resolve source maps to the original source sourceMaps(), ],}; package.json在script里加上build和start两个命令, 这里参考了其他库的用法, 在build的时候会直接使用typedoc生成一份docs文档 123456{ &quot;scripts&quot;: { &quot;build&quot;: &quot;tsc --module commonjs &amp;&amp; rollup -c rollup.config.ts &amp;&amp; typedoc --out docs --target es6 --theme minimal --mode file src&quot;, &quot;start&quot;: &quot;rollup -c rollup.config.ts -w&quot; }} 使用在配置完成后, 使用npm run build就能打出生成环境包, 使用npm run start就能启动rollup监听自动编译, 性能上比webpack启动和打包会快很多, 而且打包代码的可读性也比webpack更强, 没有冗余部分, 可以更好的调试代码 优化压缩打包之后, 发现umd格式的代码没有压缩. es模块代码不压缩比较正常, 因为如果是由webpack引入的, 往往会再次压缩打包, 不压缩更易于调试和修改. 但umd版本是可以提供浏览器直接使用的, 如果不压缩会造成体积过大, 所以需要修改rollup配置来实现不同的压缩策略, 而查了一遍文档后, 发现rollup的插件只能基于整体来配置, 而不能基于不同的output文件配置, 所以需要稍微修改一下配置结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// rollup.config.tsimport resolve from 'rollup-plugin-node-resolve';import commonjs from 'rollup-plugin-commonjs';import sourceMaps from 'rollup-plugin-sourcemaps';import camelCase from 'lodash.camelcase';import typescript from 'rollup-plugin-typescript2';import json from 'rollup-plugin-json';import pkg from './package.json';const libraryName = 'my-library';const config = [ { input: `src/index.ts`, output: { file: pkg.main, name: camelCase(libraryName), format: 'umd', sourcemap: true, }, // Indicate here external modules you don't wanna include in your bundle (i.e.: 'lodash') external: [], watch: { include: ['src/**'], }, plugins: [ // Allow json resolution json(), // Compile TypeScript files typescript({ useTsconfigDeclarationDir: true }), // Allow bundling cjs modules (unlike webpack, rollup doesn't understand cjs) commonjs(), // Allow node_modules resolution, so you can use 'external' to control // which external modules to include in the bundle // https://github.com/rollup/rollup-plugin-node-resolve#usage resolve({ browser: true, preferBuiltins: true, mainFields: ['browser'] }), // Resolve source maps to the original source sourceMaps(), uglify(), ], }, { input: `src/index.ts`, output: { file: pkg.module, format: 'es', sourcemap: true, }, // Indicate here external modules you don't wanna include in your bundle (i.e.: 'lodash') external: [], watch: { include: ['src/**'], }, plugins: [ // Allow json resolution json(), // Compile TypeScript files typescript({ useTsconfigDeclarationDir: true }), // Allow bundling cjs modules (unlike webpack, rollup doesn't understand cjs) commonjs(), // Allow node_modules resolution, so you can use 'external' to control // which external modules to include in the bundle // https://github.com/rollup/rollup-plugin-node-resolve#usage resolve({ browser: true, preferBuiltins: true, mainFields: ['browser'] }), // Resolve source maps to the original source sourceMaps(), ], },];export default config; 单元测试开发一个库自然需要单元测试, 使用最常见jest就可以了, 对ts的支持程度也非常好, 不需要编译和打包就能直接测试, 也能生成覆盖率报告 123456789101112131415161718192021222324{ &quot;scripts&quot;: { &quot;test&quot;: &quot;jest --coverage&quot;, &quot;test:watch&quot;: &quot;jest --coverage --watch&quot; }, &quot;jest&quot;: { &quot;transform&quot;: { &quot;.(ts|tsx)&quot;: &quot;ts-jest&quot; }, &quot;testEnvironment&quot;: &quot;node&quot;, &quot;testRegex&quot;: &quot;(/__tests__/.*|\\\\.(test|spec))\\\\.(ts|tsx|js)$&quot;, &quot;moduleFileExtensions&quot;: [&quot;ts&quot;, &quot;tsx&quot;, &quot;js&quot;], &quot;coveragePathIgnorePatterns&quot;: [&quot;/node_modules/&quot;, &quot;/test/&quot;], &quot;coverageThreshold&quot;: { &quot;global&quot;: { &quot;branches&quot;: 90, &quot;functions&quot;: 95, &quot;lines&quot;: 95, &quot;statements&quot;: 95 } }, &quot;collectCoverageFrom&quot;: [&quot;src/*.{js,ts}&quot;] }} 12345678910111213141516171819// test/lib.test.tsimport Lib from '../src/index';/** * Lib test */describe('Lib test', () =&gt; { it('works if true is truthy', () =&gt; { expect(true).toBeTruthy(); }); it('Lib is instantiable', () =&gt; { expect(new Lib()).toBeInstanceOf(Lib); }); it('Lib test is 1', () =&gt; { expect(new Lib().test()).toEqual(1); });}); Demo单元测试跑完没有问题之后, 有些库的效果还需要在页面实际使用中才能看到效果, 我们也可以基于rollup打包一个简单的react-demo应用, 实现在页面上实时调试, 同时也加上自动更新和调试服务器等配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// rollup.config.tsconst isNpmStart = process.env.npm_lifecycle_event === 'start';const isDev = isNpmStart;if (isDev) { fs.rmdirSync(path.resolve('./node_modules/.cache'), { recursive: true });}const createDemoConfig = () =&gt; { const getIPAddress = () =&gt; { const interfaces = os.networkInterfaces(); let result = '0.0.0.0'; for (const devName in interfaces) { const alias = _.find(interfaces[devName], (alias) =&gt; alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal); if (alias) { result = alias.address; break; } } return result; }; return { input: `demo/index.tsx`, output: { file: `dist/lib-demo.js`, name: camelCase('lib-demo'), format: 'iife', sourcemap: true, sourcemapExcludeSources: false, exports: 'named', globals: { react: 'React', 'react-dom': 'ReactDOM', antd: 'antd', store: 'store', '@ant-design/icons': 'icons', }, }, external: ['react', 'react-dom', 'antd', '@ant-design/icons', 'store'], watch: { include: ['demo/**'], }, plugins: [ postcss({ extensions: ['.sass', '.css'], }), replace({ 'process.env.NODE_ENV': JSON.stringify('development'), 'process.env.BASE_PATH': JSON.stringify(basePath), }), // Allow json resolution json(), // Compile TypeScript files typescript({ include: ['demo/**/*.ts', 'demo/**/*.tsx'], rollupCommonJSResolveHack: true, useTsconfigDeclarationDir: true, tsconfigOverride: { include: ['src', 'demo'] }, // check: false, }), babel({ babelrc: false, extensions: ['.js', '.jsx', '.ts', '.tsx'], presets: ['@babel/preset-env'], // presets: ['@babel/preset-env', '@babel/preset-react'], exclude: ['node_modules/**'], }), // Allow node_modules resolution, so you can use 'external' to control // which external modules to include in the bundle // https://github.com/rollup/rollup-plugin-node-resolve#usage resolve({ browser: true, preferBuiltins: true, mainFields: ['browser'] }), // Allow bundling cjs modules (unlike webpack, rollup doesn't understand cjs) commonjs({ // namedExports: { // react: Object.keys(react), // }, // include: ['node_modules/**'], }), // Resolve source maps to the original source sourceMaps(), ...(isNpmStart ? [ livereload({ watch: ['dist/'] }), serve({ contentBase: '../', host: getIPAddress(), port: 10001, open: true, openPage: '/lib/demo/index.html', }), ] : []), ], };};const config = libConfig.concat(isDev ? [createDemoConfig()] : []); Demo的html配置, 为了减少打包速度和打包问题, 其他依赖库直接使用script引入页面 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1,initial-scale=1&quot; /&gt; &lt;script src=&quot;../node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../node_modules/moment/min/moment.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../node_modules/antd/dist/antd.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../node_modules/@ant-design/icons/dist/index.umd.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../node_modules/store/dist/store.legacy.min.js&quot;&gt;&lt;/script&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../node_modules/antd/dist/antd.css&quot; /&gt; &lt;title&gt;demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- This is the bundle generated by rollup.js --&gt; &lt;script src=&quot;../dist/lib.umd.js&quot;&gt;&lt;/script&gt; &lt;!-- This is the bundle generated by rollup.js --&gt; &lt;script src=&quot;../dist/lib-demo.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Demo的index.tsx 12345678910111213141516171819202122232425262728293031import _ from 'lodash';import React, { useReducer, useEffect } from 'react';import ReactDOM from 'react-dom';import Root from './containers/root';import { ErrorBoundary, LoadingProgress } from './components';import { defaultState, reducer, Context } from './context-store/userList';import Lib from '../src/index';import './App.scss';import './main.scss';declare global { const lib: typeof Lib;}const App: React.FC = () =&gt; { const [store, dispatch] = useReducer(reducer, defaultState); useEffect(() =&gt; { const sdk = Lib.getInstance(); }, []); return ( &lt;ErrorBoundary&gt; &lt;LoadingProgress /&gt; &lt;Context.Provider value={{ state: store, dispatch }}&gt; &lt;Root /&gt; &lt;/Context.Provider&gt; &lt;/ErrorBoundary&gt; );};ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 小结整套配置完成后, 就基本实现了一个简单的rollup+typescript的js库开发环境, 后续如果有其他需求继续在此基础上迭代即可, 也考虑使用最常用的配置开发一个create-rollup-ts-lib这样的工具, 减少重复工作量和踩坑的过程","link":"/2020/05-20-rollup-typescript/"},{"title":"使用Rollup实现生成TypeScript类型","text":"背景已有项目的.d.ts文件是手动维护的, 虽然比较多老旧的js库的类型定义也是手动维护, 但是我们是直接使用ts来开发我们的库的, 所以需要一种自动化和现代的方案来生成我们库的定义文件 tsc --declaration能生成.d.ts文件, 但是这些文件是分散的, 使用起来并不友好 使用dts-generator或dts-bundle将所有的.d.ts文件打包成一个, 但是都不是官方方案, 而且比较老旧, 处于不活跃状态 研究过很多项目后, 发现了一个神器: api-extractor, 微软官方出品维护, 可以合并.d.ts文件, 还能做到lint的效果, 检查代码中的错误 使用使用api-extractor的相关资料并不多, 所以最后决定直接参考官方文档来实现, 按文档说明流程非常简单 flowchart TD A(ts源码) --> |tsc|B(多文件.d.ts) B --> |api-extractor|C(单文件.d.ts) 配置api-extractor其中messages字段是一些错误提示忽略的配置, 类似于eslint的rule, 有些想忽略的warning就可以在这里配置以后保证lint检查是成功的 123456789101112131415161718192021222324// api-extractor.json{ &quot;$schema&quot;: &quot;https://developer.microsoft.com/json-schemas/api-extractor/v7/api-extractor.schema.json&quot;, &quot;mainEntryPointFilePath&quot;: &quot;dist/types/index.d.ts&quot;, &quot;bundledPackages&quot;: [], &quot;apiReport&quot;: { &quot;enabled&quot;: false, &quot;reportFolder&quot;: &quot;dist/lib/&quot; }, &quot;docModel&quot;: { &quot;enabled&quot;: true }, &quot;dtsRollup&quot;: { &quot;enabled&quot;: true, &quot;untrimmedFilePath&quot;: &quot;dist/lib.es5.d.ts&quot; }, &quot;messages&quot;: { &quot;extractorMessageReporting&quot;: { &quot;ae-missing-release-tag&quot;: { &quot;logLevel&quot;: &quot;none&quot; } } }} 编译脚本在package.json里加上相关命令, 就可以直接生成.d.ts文件了 1234567{ &quot;typings&quot;: &quot;dist/types/index.d.ts&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;tsc --module commonjs &amp;&amp; api-extractor run &amp;&amp; rollup -c rollup.config.ts &amp;&amp; typedoc --out docs --theme minimal src&quot;, &quot;api&quot;: &quot;tsc --module commonjs &amp;&amp; api-extractor run&quot; }} 使用生成完成后, 可以看到dist目录下的结构就非常清晰了, 只剩下五份文件: lib.es5.js lib.es5.js.map lib.umd.js lib.umd.js.map lib.es5.d.ts 然后就可以在demo的react里很舒服的直接使用ts类型了, 和使用其他库的效果一样. 1import LibSDK, { SDKOptions } from '../dist/lib.es5';","link":"/2020/06-01-rollup-typescript-api-extractor/"},{"title":"React App - Worker &amp; Markdown Render","text":"背景最近需要开发一个内部的文档编辑器, 解决旧编辑器的卡顿/支持功能较少的问题, 经过一段时间的调研和开发, 解决了各种问题, 这里记录一下几个重要的方案 需求 markdown实时渲染, 所见即所得 大文件编辑/渲染不卡顿 支持mermaid 其实还有部分后台的需求如多人编辑的锁/多语言切换和某些自定义渲染页面等, 但是这些需求实现起来也不复杂, 所以这里不再记录 调研markdown实时渲染常见的库有两个: marked 和 remark 研究之后发现从可控性和易用性来说, 都是marked较好一点, 但是它的渲染速度比remark稍慢, 而在大文件渲染时它们都比较慢, 所以我们选择marked后只需要解决渲染较慢的问题 而且由于会有比较多的自定义功能, 也没有使用常见的react封装过的marked组件, 而是选择使用div来自己实现渲染数据的填充 编辑组件也有比较多的现成markdown编辑组件, 但是仔细研究一遍过后, 发现居然还是回到了原始的codemirror和新兴的monaco-editor(vscode内置使用的编辑器), 他们都支持虚拟滚动和定位, 在超过2w行以上的数据量的时候也不会卡顿, 由于我们不绑定编辑器, 所以选择都支持, 并且提供根据喜好切换编辑器的功能 渲染这块是需要最重点解决的问题, 旧的编辑器就是渲染卡顿导致页面切换时假死, 这里使用web-worker进行后台渲染解决页面卡顿的问题 mermaid尝试了一下mermaid的相关api, 发现它的渲染需要依赖document, 不能放在web-worker中渲染, 所以最后选择了使用通过class标注, 然后在页面内实时渲染 实现rpc-workerts对worker的支持如类型提示和定义等其实比较少的, 都是直接使用原始的postMessage和onmessage来接受和传输数据, 所以封装了一个通用的rpc-worker来对worker-server和worker-client实现类型支持 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140export type RpcWorkerOptions = { rpcTimeout?: number;};export type RpcWorkerAllOptions = { version: string; rpcTimeout?: number;};const defaultOptions: RpcWorkerAllOptions = { version: '0.0.1', rpcTimeout: 30 * 1000,};export type RpcWorkerServerHandler = Record&lt;string, (value: any) =&gt; any&gt;;export type RpcWorkerRequest = { rpcId: string; method: string; data: any;};export type RpcWorkerResponse = { rpcId: string; data: any; error: any;};class RpcWorkerServer&lt;T extends RpcWorkerServerHandler&gt; { private ctx: Worker; private _rpcHandler: T; constructor(ctx: Worker) { this.ctx = ctx; this._rpcHandler = {} as T; this.ctx.onmessage = async (event) =&gt; { const data: RpcWorkerRequest = event.data; try { const result = await this._rpcHandler[data.method](data.data); this.sendMessage(data, result); } catch (e) { this.sendMessage(data, null, e); } }; } addHandler&lt;K extends keyof T&gt;(key: K, fn: T[K]) { this._rpcHandler[key] = fn; } private postMessage(response: RpcWorkerResponse) { this.ctx.postMessage(response); } private sendMessage(request: RpcWorkerRequest, result: any, error: any = null) { this.postMessage({ rpcId: request.rpcId, data: result, error: error }); }}class RpcWorkerClient&lt;T extends RpcWorkerServerHandler&gt; { private worker: Worker; private options: RpcWorkerAllOptions; private _rpcId: number; private _rpcHandler: { [key: string]: { resolve: (value: any) =&gt; void; reject: (error: any) =&gt; void }; }; public addEventListener: Worker['addEventListener']; constructor(worker: Worker, options?: RpcWorkerOptions) { this.worker = worker; this.options = { ...defaultOptions, ...options }; this._rpcId = 1; this._rpcHandler = {}; this.addEventListener = this.worker.addEventListener.bind(this.worker); this.worker.onmessage = (event) =&gt; { const response: RpcWorkerResponse = event.data; const _rpcId = response.rpcId; if (!this._rpcHandler[_rpcId]) { return; } if (response.error) { this._rpcHandler[_rpcId].reject(response.error); } else { this._rpcHandler[_rpcId].resolve(response.data); } }; } terminate() { this.worker.terminate(); } private getRpcId(): string { return (this._rpcId++).toString(); } call&lt;K extends keyof T&gt;(method: K, data: Parameters&lt;T[K]&gt;[0], options?: RpcWorkerOptions): Promise&lt;ReturnType&lt;T[K]&gt;&gt; { return new Promise&lt;ReturnType&lt;T[K]&gt;&gt;((resolve, reject) =&gt; { const rpcId = this.getRpcId(); let isTimeout = false; const timeout = options?.rpcTimeout || this.options.rpcTimeout; let timer: null | number = null; if (timeout) { timer = window.setTimeout(() =&gt; { isTimeout = true; reject(new Error(`Request Timeout: ${method}`)); }, timeout); } this._rpcHandler[rpcId] = { resolve: (value: any) =&gt; { if (timer !== null &amp;&amp; !isTimeout) { clearTimeout(timer); } if (!timer || !isTimeout) { resolve(value); } }, reject: (error: any) =&gt; { if (timer !== null &amp;&amp; !isTimeout) { clearTimeout(timer); } if (!timer || !isTimeout) { reject(error); } }, }; this.postMessage({ rpcId: rpcId, method: method as string, data: data, }); }); } private postMessage(request: RpcWorkerRequest) { this.worker.postMessage(request); }}export { RpcWorkerServer, RpcWorkerClient }; webpack配置这一块其实比较简单, 直接参考已有配置和worker-loader说明即可 123456789101112131415161718192021222324252627282930313233343536373839404142const rules = [ // for web worker { test: /\\.worker\\.ts$/, // ts结尾,这也很重要 include: paths.appSrc, use: [ { loader: 'worker-loader', options: { name: 'static/js/[name].[hash:8].js', // 打包后chunk的名称 // inline: true, // 开启内联模式,免得爆缺少标签或者跨域的错误 }, }, { loader: require.resolve('babel-loader'), options: { customize: require.resolve('babel-preset-react-app/webpack-overrides'), plugins: [ [ require.resolve('babel-plugin-named-asset-import'), { loaderMap: { svg: { ReactComponent: '@svgr/webpack?-svgo,+titleProp,+ref![path]', }, }, }, ], ], // This is a feature of `babel-loader` for webpack (not Babel itself). // It enables caching results in ./node_modules/.cache/babel-loader/ // directory for faster rebuilds. cacheDirectory: true, // See #6846 for context on why cacheCompression is disabled cacheCompression: false, compact: isEnvProduction, }, }, ], },]; render-worker这里实现了RpcWorkerServer, 支持toc, sanitize防注入, prettier代码格式化以及大数据量时的优化, 图片鉴权, tab-code等功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import { RpcWorkerServer } from './rpc-worker';import marked, { Tokens } from 'marked';import { TAB_CONTENT } from '../multi-tab';import prettier from 'prettier/standalone';import prettierParserMarkdown from 'prettier/parser-markdown';import highlight from 'highlight.js';import sanitizeHtml from 'sanitize-html';import md5 from 'md5';export type MarkdownWorkerToc = { id: string; anchor: string; level: number; text: string };export type MarkdownWorkerMethod = { markdownRender: ({ text }: { text: string }) =&gt; { content: string; toc: MarkdownWorkerToc[] }; prettierFormat: ({ text, bigTextLength, formatMd5List }: { text: string; bigTextLength: number; formatMd5List: string[] }) =&gt; { text: string; formatMd5List: string[]; };};const longPrettierHeaderCount = 200;// eslint-disable-next-line no-restricted-globalsconst ctx: Worker = self as any;const server = new RpcWorkerServer&lt;MarkdownWorkerMethod&gt;(ctx);marked.setOptions({ highlight: function (code, lang) { return highlight.highlight(highlight.getLanguage(lang) ? lang : 'plaintext', code, true).value; },});const UNIT_KEY = `//tab=unit_key_for_tab`;server.addHandler('markdownRender', ({ text }) =&gt; { const renderer = new marked.Renderer(); const _oldCode = renderer.code.bind(renderer); renderer.code = (code, language, ...args) =&gt; { if (code.indexOf(UNIT_KEY) &gt; -1) { const tabStr = _.nth(_.split(code, '-'), 1); const finalCode = _.replace(code, `${UNIT_KEY}-${tabStr}-`, ''); return `&lt;div class=&quot;${TAB_CONTENT}&quot; data-language=&quot;${tabStr}&quot;&gt;&lt;div class='code-container'&gt;&lt;div class='copy-code-btn'&gt;&lt;/div&gt;${_oldCode( finalCode, language, ...args, )}&lt;/div&gt;&lt;/div&gt;`; } if (language === 'mermaid') { return '&lt;div class=&quot;mermaid&quot;&gt;' + code + '&lt;/div&gt;'; } return `&lt;div class='code-container'&gt;&lt;div class='copy-code-btn'&gt;&lt;/div&gt;${_oldCode(code, language, ...args)}&lt;/div&gt;`; }; const toc: MarkdownWorkerToc[] = []; const levelNIndex: Record&lt;number, number&gt; = {}; renderer.heading = function (text, level, raw, slugger) { if (!levelNIndex[level]) { levelNIndex[level] = 1; } else { levelNIndex[level] = levelNIndex[level] + 1; } const headerIdMatch = /\\s+\\{#([a-zA-Z0-9_-]+)\\}$/gi.exec(text); const anchor = encodeURIComponent(headerIdMatch ? headerIdMatch[1] : slugger.slug(raw)); text = text.replace(/\\s+\\{#([a-zA-Z0-9_-]+)\\}$/gi, ''); toc.push({ id: anchor, anchor: `#${anchor}`, level: level, text: text, }); if (level &gt; 3) { return `&lt;h${level} id='${anchor}' class='toc-id'&gt;${text}&lt;/h${level}&gt;\\n`; } else { return `&lt;h${level} id='${anchor}' class='toc-id'&gt;&lt;a id='user-content-${anchor}' class='anchor' href='#${anchor}'&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewBox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; width=&quot;16&quot; height=&quot;16&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;${text}&lt;/h${level}&gt;\\n`; } }; const _oldImage = renderer.image.bind(renderer); renderer.image = function (href: string, title: string, text: string) { if (href.indexOf('.....') &gt; -1) { href = `${'...'}?target=${encodeURIComponent(href)}`; } return _oldImage(href, title, text); }; const _oldLink = renderer.link.bind(renderer); renderer.link = function (href: string, title: string, text: string) { if (href.indexOf('.....') &gt; -1) { href = `${'...'}?target=${encodeURIComponent(href)}`; } return _oldLink(href, title, text); }; let preLineTab = ''; const html = marked(text, { renderer: renderer, walkTokens: (tokens) =&gt; { const token = _.first(_.castArray(tokens)) as Tokens.HTML | Tokens.Code; if (token.type === 'html') { const tabMatch = token.raw.match(/&lt;!-- tab=(\\S+) --&gt;/); if (tabMatch) { preLineTab = tabMatch[1]; } } else if (preLineTab &amp;&amp; token.type === 'code') { token.text = `${UNIT_KEY}-${preLineTab}-${token.text}`; preLineTab = ''; } else if (preLineTab &amp;&amp; token.type !== 'code') { preLineTab = ''; } }, }); const endHtml = `\\n&lt;div class='markdown-preview-padding-bottom'&gt;&lt;/div&gt;\\n`; return { content: sanitizeHtml(html + endHtml, { allowedTags: sanitizeHtml.defaults.allowedTags.concat(['input', 'img', 'svg', 'path', 'details', 'summary', 'del']), allowedAttributes: { '*': ['class', 'id', 'href', 'style', 'width', 'height', 'data-*'], input: ['checked', 'type', 'disabled'], img: ['src', 'alt'], svg: ['xmlns', 'viewBox', 'version', 'aria-hidden'], path: ['d', 'fill-rule'], }, parser: { lowerCaseAttributeNames: false, }, }), toc: toc, };});const longTextPritter = (text: string, formatMd5List: Set&lt;string&gt;): { text: string; formatMd5List: string[] } =&gt; { console.info(`in long text pritter`); const textLines = text.split('\\n'); let inCodeBlock = false; const headerBlocks: string[] = []; let currentHeaderLines: string[] = []; const newMd5List = Array.from(formatMd5List); for (let i = textLines.length - 1; i &gt;= 0; i--) { const line = textLines[i]; currentHeaderLines.unshift(line); if (!inCodeBlock &amp;&amp; currentHeaderLines.length &gt; longPrettierHeaderCount &amp;&amp; /^#{1,6} /.test(line)) { headerBlocks.push(currentHeaderLines.join('\\n')); currentHeaderLines = []; } if (line.startsWith('```')) { inCodeBlock = !inCodeBlock; } } if (currentHeaderLines.length) { headerBlocks.push(currentHeaderLines.join('\\n')); } headerBlocks.reverse(); _.map(headerBlocks, (headerText, index) =&gt; { const headerMd5 = md5(headerText); if (formatMd5List.has(headerMd5)) { return; } else { headerBlocks[index] = prettier.format(headerText, { parser: 'markdown', plugins: [prettierParserMarkdown], tabWidth: 2 }); newMd5List.push(md5(headerBlocks[index])); } }); return { text: headerBlocks.join('\\n'), formatMd5List: newMd5List };};server.addHandler('prettierFormat', ({ text, bigTextLength, formatMd5List }) =&gt; { console.time('prettier'); text = text.replace(/\\t/gi, ' '); const result: { text: string; formatMd5List: string[] } = text.length &gt; bigTextLength ? longTextPritter(text, new Set(formatMd5List)) : { text: prettier.format(text, { parser: 'markdown', plugins: [prettierParserMarkdown], tabWidth: 2 }), formatMd5List: Array.from(formatMd5List), }; console.timeEnd('prettier'); return result;});export default null as any; 使用worker这里还是可以加上一层本地缓存, 如果有缓存就不用再次渲染 123456789101112131415161718192021222324252627282930313233import { MarkdownWorkerMethod } from './markdown.worker';// @ts-ignoreimport MarkdownWorker from './markdown.worker.ts';const markdownWorkerClient = new RpcWorkerClient&lt;MarkdownWorkerMethod&gt;(new MarkdownWorker());export const callMarkdownRender = async (allPath: string, content: string): Promise&lt;ReturnType&lt;MarkdownWorkerMethod['markdownRender']&gt;&gt; =&gt; { if (allPath &amp;&amp; content &amp;&amp; content.length &gt; CONSTANT.BIG_CONTENT_LENGTH) { try { const renderCache = store.get('...') || {}; const cache: { md5: string; renderResult: { content: string; toc: MarkdownWorkerToc[] } } = renderCache[allPath]; const contentMd5 = md5(content); if (cache &amp;&amp; cache.md5 === contentMd5) { return cache.renderResult; } else { const result = await markdownWorkerClient.call('markdownRender', { text: content, }); renderCache[allPath] = { md5: contentMd5, renderResult: result, }; store.set('...', renderCache); return result; } } catch (e) { console.warn(e); } } return await markdownWorkerClient.call('markdownRender', { text: content, });}; mermaid加载1234567useLayoutEffect(() =&gt; { if (document.querySelector('.mermaid')) { mermaid.init('.mermaid'); } initMultiTab('.markdown-body'); initCopyCodeBtn();}, [contentData]); dangerouslyHTML1const DangerouslyHTMLDiv: React.FC&lt;{ content: string }&gt; = React.memo(({ content }) =&gt; &lt;div dangerouslySetInnerHTML={{ __html: content }}&gt;&lt;/div&gt;); 小结这次的页面开发周期比较长, 中间也踩了很多坑, 最后这里也只记录了一小部分可复用的核心内容, 其他更多的问题往往是遇见后再去解决就可以了","link":"/2020/06-18-react-app-markdown-render-worker/"},{"title":"React App - Markdown Editor Sync Scroll","text":"背景编辑器的主要性能和要解决的问题上一篇已经大概记录完了, 最近又碰见一个比较有意思的问题, 这里也记录一下 主要问题就是在编辑器写完一部分代码之后, 滚动到下一部分的时候, 右边的渲染内容也需要同步滚动. 常见的流行编辑器都实现了这个功能, 但是很少有描述如何实现的, 看了一个编辑器实现的源码, 它是基于解析的时候记录行号和渲染行号来实现的同步滚动, 这个对于我们使用开源的marked来说非常不友好. 于是自己研究实现了一个基于header渲染的滚动同步算法, 运行后效果也与外界基本一致, 也不存在性能问题 实现原理既然我们无法在渲染时获取当前哪行和渲染后是哪一行, 那么退一步, 获取当前在第几个header下, 以及在此header下的偏移位置(用百分比来控制), 编辑框内容就直接用正则/^\\s*(#{1,6})\\s/.exec(line.text)来获取header的位置 计算编辑器左边坐标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const layoutRef = useRef&lt;{ left: { from: number; to: number; tocId: string }[]; right: { from: number; to: number; tocId: string }[];}&gt;({ left: [], right: [] });const calcLeftLayout = () =&gt; { try { // get left position const levelNIndex: Record&lt;number, number&gt; = {}; let codeStart = false; layoutRef.current.left = []; let leftProTocContentLineHeight = 0; let leftCurrentTocContentLineHeight = 0; let leftPreTocId: string = null; codeMirrorRef.current.editor.eachLine((line) =&gt; { if (line.text.indexOf('```') &gt; -1) { codeStart = !codeStart; } if (codeStart) { leftCurrentTocContentLineHeight += (line as any).height; return; } const matches = /^\\s*(#{1,6})\\s/.exec(line.text); if (matches) { const level = matches[1].length; if (!levelNIndex[level]) { levelNIndex[level] = 1; } else { levelNIndex[level] = levelNIndex[level] + 1; } layoutRef.current.left.push({ from: leftProTocContentLineHeight + 1, to: leftCurrentTocContentLineHeight, tocId: leftPreTocId, }); leftPreTocId = `t-${level}-${levelNIndex[level]}`; leftProTocContentLineHeight = leftCurrentTocContentLineHeight; } leftCurrentTocContentLineHeight += (line as any).height; }); layoutRef.current.left.push({ from: leftProTocContentLineHeight, to: leftCurrentTocContentLineHeight, tocId: leftPreTocId, }); } catch (e) { console.log(e); }};const throttleCalcLeftLayout = useCallback(_.throttle(calcLeftLayout, 200), []); 计算右侧渲染坐标12345678910111213141516171819202122232425262728const calcRightLayout = () =&gt; { try { // get right position const tocs = previewDivRef.current.querySelectorAll&lt;HTMLDivElement&gt;('.toc-id'); layoutRef.current.right = []; let rightPreLine = 0; let rightPreTocId = null; for (let i = 0; i &lt; tocs.length; i++) { layoutRef.current.right.push({ from: rightPreLine, to: tocs[i].offsetTop, tocId: rightPreTocId, }); rightPreLine = tocs[i].offsetTop + 1; rightPreTocId = tocs[i].id; } layoutRef.current.right.push({ from: rightPreLine, to: previewDivRef.current.scrollHeight, tocId: rightPreTocId, }); const imgs = previewDivRef.current.querySelectorAll&lt;HTMLImageElement&gt;('img'); _.map(imgs, (img) =&gt; img.addEventListener('load', calcRightLayout)); } catch (e) { console.log(e); }}; 同步滚动实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const throttleScroll = useMemo( () =&gt; ({ onLeftScroll: _.throttle((editor: CodeMirror.Editor) =&gt; { // left scrollTop const leftScrollTop: number = (editor.getDoc() as any).scrollTop; if (scrollInfoValueRef.current.rightScrollEvent) { scrollInfoValueRef.current.rightScrollEvent = false; return false; } scrollInfoValueRef.current.leftScrollEvent = true; if (leftScrollTop === 0) { previewDivRef.current.scrollTop = 0; return; } // calc left view [top] percent const leftItemIndex = _.findIndex(layoutRef.current.left, (item) =&gt; leftScrollTop &gt;= item.from &amp;&amp; leftScrollTop &lt;= item.to); if (leftItemIndex === -1) { return; } const leftItem = layoutRef.current.left[leftItemIndex]; const percent = (leftScrollTop - leftItem.from) / (leftItem.to - leftItem.from); // calc right view [top] px const rightItem = layoutRef.current.right[leftItemIndex]; if (!rightItem) { console.warn(`rightItem undefined, leftItemIndex:${leftItemIndex}`); return; } previewDivRef.current.scrollTop = rightItem.from + (rightItem.to - rightItem.from) * percent; }, 0), onRightScroll: _.throttle((event: React.UIEvent&lt;HTMLDivElement, UIEvent&gt;) =&gt; { // right scrollTop const rightScrollTop = previewDivRef.current.scrollTop; const rightScrollHeight = previewDivRef.current.scrollHeight; const rightClientHeight = previewDivRef.current.clientHeight; if (scrollInfoValueRef.current.leftScrollEvent) { scrollInfoValueRef.current.leftScrollEvent = false; return false; } scrollInfoValueRef.current.rightScrollEvent = true; if (rightScrollTop === 0) { codeMirrorRef.current.editor.scrollTo(undefined, 0); return; } // calc right view [top] percent const rightItemIndex = _.findIndex(layoutRef.current.right, (item) =&gt; rightScrollTop &gt;= item.from &amp;&amp; rightScrollTop &lt;= item.to); if (rightItemIndex === -1) { return; } const rightItem = layoutRef.current.right[rightItemIndex]; const percent = (rightScrollTop - rightItem.from) / (rightItem.to - rightItem.from); // calc left view [top] px const leftItem = layoutRef.current.left[rightItemIndex]; if (!leftItem) { console.warn(`leftItem undefined, rightItemIndex:${rightItemIndex}`); return; } // 右侧预览已经在底部时，不需要再触发左侧的滚动 if (rightScrollHeight - rightScrollTop === rightClientHeight) { return; } codeMirrorRef.current.editor.scrollTo(undefined, leftItem.from + (leftItem.to - leftItem.from) * percent); }, 0), }), [],);const previewDivRef = useRef&lt;HTMLDivElement&gt;(null);const editorDivRef = useRef&lt;HTMLDivElement&gt;(null); 滚动方法使用codemirror12345678910&lt;CodeMirror editorDidMount={(editor: CodeMirror.Editor) =&gt; (codeMirrorRef.current.editor = editor)} className='content-editor-code-mirror' onScroll={(editor) =&gt; { if (!editorStateRef.current.showPreview) { return; } throttleScroll.onLeftScroll(editor); }}/&gt; preview123&lt;div className={classNames('doc-markdown-container')} ref={previewDivRef} onScroll={throttleScroll.onRightScroll}&gt; &lt;MarkdownRenderWrapper content={editorStateRef.current.rightView.content} onClickLink={clickLink} /&gt;&lt;/div&gt; 小结这次使用一种次优的方案实现了比较好的滚动效果, 整体比较节省时间和工作量, 其中最麻烦的是双向滚动时候的状态保存, 需要记录滚动是由左侧还是右侧触发的, 再计算需要滚动到的对应坐标. 最终使用百分比, 实现了在mermaid和大图片的情况下滚动都是基本同步无异常的效果 当然最好的方案还是渲染时直接记录对应行号, 但是这样成本太高只能舍弃了","link":"/2020/06-23-react-app-markdown-editor-scroll-sync/"},{"title":"Sourcemap Resolve","text":"背景很久之前已经做过将混淆后的代码根据sourcemap解析为混淆前的工作了, 这次需要研究的更近了一步: 如何解决多次编译的代码后的sourcemap错误导致找不到原始代码的问题. 比如由ts开发的源码, 先经过tsc打包生成js, 然后经过uglifyjs压缩成为一个文件, 最后由第三方打包工具再进行一些修改, 即使每一步都存在sourcemap记录, 但此时的sourcemap也已经无法解析到原始的源码了. 调研根据sourcemap的原理, 实际上我们是可以将这几次的生成合并成一份最终文件, 根据这份文件找到原始代码的, 因为按层层反向解析, 确实能找到每一步的操作是由哪里开始, 然后到哪里结束. 同时还发现了一个非常好用的库: magic-string, 它可以记录下原始的字符串, 并根据每一步的修改内容, 最终生成一份sourcemap文件, 在rollup打包里就使用的它来实现的代码修改 问题但是在最终尝试和完成之后, 却发现了一个比较大的问题: 如果工具链中有一个并没有根据原始的sourcemap来记录它的修改, 那么就会出现某些行信息遗漏, 导致找不到原始的代码. flowchart TD A(1: ts源码) --> |编译|B(2: .js) B --> |uglify|C(3: .min.js) C --> |copy+change|D(4: .xxx.js) 在1-3步, 由于都是有现成的工具, 而且它们往往会对每一行都进行操作, 所以他们的sourcemap信息里, 会将每一行的原始信息都记录下来, 但是在4步, 假设这个change只是统一全局替换了某个字符串, 那么它只会记录影响到的每一行, 如果这个字符串没有出现在这一行, 那么这行的信息在回溯查找的时候就会被遗漏掉, 存在比较大的问题. 但理论上其实也不是无法解决的, 在解析上一层sourcemap的时候如果发现有遗漏的行信息, 可以实现往后追溯补全这一行的, 但是这个实现过于复杂, 没有深入研究 开发这里就记录下如果每一步都有完整的sourcemap信息, 将它们合并为原始的sourcemap的过程. 实测经过ts到js再到min.js的代码可以通过这个脚本后生成原始ts的sourcemap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142import fs from 'fs';import path from 'path';import _ from 'lodash';import { decode, encode, SourceMapMappings, SourceMapLine } from 'sourcemap-codec';import { ExistingDecodedSourceMap, ExistingRawSourceMap, SegmentStruct, SegmentStructSource } from '../source';const resolveSourcemap = (filepath: string): ExistingDecodedSourceMap | null =&gt; { const code = fs.readFileSync(filepath).toString('utf-8'); const lastLine = _.last(code.trim().split('\\n')); if (!lastLine) { return null; } const sourcemapMatch = /^\\/\\/#\\s*sourceMappingURL=(.+)$/i.exec(lastLine); if (!sourcemapMatch) { return null; } const sourcemapUrl = sourcemapMatch[1]; let sourcemapStr: string = ''; if (sourcemapUrl.startsWith(`data:application/json;base64,`)) { const sourcemapBase64Str = sourcemapUrl.slice(`data:application/json;base64,`.length); sourcemapStr = Buffer.from(sourcemapBase64Str, 'base64').toString(); } else { sourcemapStr = fs.readFileSync(path.resolve(path.dirname(filepath), sourcemapUrl)).toString('utf-8'); } const sourceMap: ExistingRawSourceMap = JSON.parse(sourcemapStr); const sourceMapDecode: ExistingDecodedSourceMap = { ...sourceMap, mappings: decode(sourceMap.mappings), file: filepath }; return sourceMapDecode;};const resolveMappingToSegments = (sourcemap: ExistingDecodedSourceMap): SegmentStruct[] =&gt; { const segments: SegmentStruct[] = []; _.map(sourcemap.mappings, (line, lineIndex) =&gt; { _.map(line, (_segments) =&gt; { if (_segments.length === 1) { return null; } segments.push({ dist: { file: sourcemap.file, line: lineIndex, column: _segments[0], }, source: { file: path.resolve(path.dirname(sourcemap.file), sourcemap.sources[_segments[1]]), line: _segments[2], column: _segments[3], name: _segments.length === 5 ? sourcemap.names[_segments[4]] : undefined, }, }); }); }); return segments;};const resolveSegmentLine = (segmentSource: SegmentStructSource): SegmentStructSource =&gt; { const sourcemapDecode = resolveSourcemap(segmentSource.file); if (sourcemapDecode) { return findSegmentAtSourcePosition(segmentSource, sourcemapDecode); } else { return segmentSource; }};const findSegmentAtSourcePosition = (segmentSource: SegmentStructSource, sourcemap: ExistingDecodedSourceMap): SegmentStructSource =&gt; { const sourceSegments = sourcemap.mappings[segmentSource.line]; if (!sourceSegments) { return segmentSource; } // binary search through segments for the given column let columnStart = 0; let columnEnd = sourceSegments.length - 1; while (columnStart &lt;= columnEnd) { const m = (columnStart + columnEnd) &gt;&gt; 1; const sourceSegment = sourceSegments[m]; if (sourceSegment[0] === segmentSource.column) { if (sourceSegment.length == 1) { return segmentSource; } const sourceFile = sourcemap.sources[sourceSegment[1]]; if (!sourceFile) { return segmentSource; } return resolveSegmentLine({ file: path.resolve(path.dirname(sourcemap.file), sourceFile), line: sourceSegment[2], column: sourceSegment[3], // why need segmentSource.name? name: sourceSegment.length === 5 ? sourcemap.names[sourceSegment[4]] : segmentSource.name, }); } if (sourceSegment[0] &gt; segmentSource.column) { columnEnd = m - 1; } else { columnStart = m + 1; } } return segmentSource;};const formatSegments = (file: string, sourceRoot: string | undefined, segments: SegmentStruct[]): ExistingRawSourceMap =&gt; { const result: ExistingRawSourceMap = { version: 3, file: file, sourceRoot: sourceRoot, sources: [], sourcesContent: [], names: [], mappings: '', }; const sourceMapMappings: SourceMapMappings = Array.from&lt;SourceMapLine&gt;({ length: segments[segments.length - 1].dist.line + 1 }).fill([]); _.map(segments, (segment) =&gt; { let fileIndex = result.sources.indexOf(segment.source.file); if (fileIndex === -1) { fileIndex = result.sources.length; result.sources.push(segment.source.file); } let nameIndex: number | null = null; if (segment.source.name) { nameIndex = result.names.indexOf(segment.source.name); if (nameIndex === -1) { nameIndex = result.names.length; result.names.push(segment.source.name); } } sourceMapMappings[segment.dist.line].push( nameIndex === null ? [segment.dist.column, fileIndex, segment.source.line, segment.source.column] : [segment.dist.column, fileIndex, segment.source.line, segment.source.column, nameIndex], ); }); result.mappings = encode(sourceMapMappings); return result;};export { resolveSourcemap, resolveMappingToSegments, resolveSegmentLine, formatSegments };","link":"/2020/07-01-sourcemap-resolve/"},{"title":"WebSocket grpc调用封装","text":"背景最近需要开发用于聊天通讯的SDK, 服务端提供的是grpc用于android和ios的通讯, 在web上, grpc-web实质上是基于中间代理服务器通过http请求转发的, 而且也由于grpc-web将协议数据解析逻辑生成了一份js文件, 随着接口代码的逐渐增多, 用于解码数据的js文件大小也会越来越大, 不太符合现在的场景 调研在web层, 常用于rpc调用的方案是websocket, 考虑了一下可行性, 客户端和服务端保持websocket长链接, 通过sendMessage来实现rpc调用和返回, 服务端再将接受到的websocket数据转换为grpc调用方法, 调用后返回结果通过websocket返回给客户端, 所以最终确定使用websocket来实现grpc的调用 开发开发一个稳定可用的websocket-client, 需要封装好几个关键的接口: 初始化/自动重连/错误处理/超时处理/发送数据/接收通知/数据解析 初始化直接使用constructor实现, 将用于websocket的参数传入, 同时传入一些自定义参数, 如重连配置等, 同时将websocket的事件处理函数注册好, 这里注意, 如果接收到的message并不是客户端发起的, 意味着是服务端主动调用, 需要通过EventEmitter通知客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export type WebsocketClientOptions = { url: string; rpcTimeout?: number; reconnectTimes?: number; reconnectInterval?: number; reconnectIntervalIncrease?: number; keepAliveInterval?: number;};export type WebsocketClientAllOptions = { url: string; rpcTimeout: number; reconnectTimes: number; reconnectInterval: number; reconnectIntervalIncrease: number; keepAliveInterval: number;};const defaultOptions: WebsocketClientAllOptions = { url: '', rpcTimeout: 10 * 1000, reconnectTimes: 10, reconnectInterval: 1 * 1000, reconnectIntervalIncrease: 1 * 1000, keepAliveInterval: 30 * 1000,};export class WebsocketClient implements IwebsocketClient { private options: WebsocketClientAllOptions; private _socketClient: WebSocket | null; private eventBus: EventEmitter&lt;Event&gt;; private _isConnected: boolean; private _keepAliveTimer!: number; private _rpcId: number; private _rpcHandler: { [key: string]: { resolve: (value: unknown) =&gt; void; reject: (error: ServerError) =&gt; void }; }; private _lockReconnectPromise: Promise&lt;WebSocket | null&gt; | null; constructor(options: WebsocketClientOptions) { this.options = { ...defaultOptions, ...options }; if (!this.options.url) { throw new Error(`WebsocketClient need args url`); } this._socketClient = null; this.eventBus = new EventEmitter(); this._isConnected = false; this._rpcId = 1; this._rpcHandler = {}; this._lockReconnectPromise = null; this.initMessageHandler(); } private initMessageHandler(): void { this.eventBus.on(ClientEvent.MESSAGE, (data: Data) =&gt; { getLogger().info(`Get message, rpcId: ${data.rpcid}`); if (data.rpcid) { if (this._rpcHandler[data.rpcid]) { const { resolve, reject } = this._rpcHandler[data.rpcid]; Reflect.deleteProperty(this._rpcHandler, data.rpcid); if (data.errorcode) { return reject(new ServerError(data.errormsg, data.errorcode)); } const result = data.payload ? JSON.parse(b64DecodeUnicode(data.payload)) : null; return resolve(result ? result : null); } else { getLogger().error(`Not found rpcHandler: ${data.rpcid}`); } } else { // no rpcid means server call this.eventBus.emit(ClientEvent.SERVER_CALL, data); } }); }} 连接/重连/心跳由于js是单线程的, 可以很轻松的实现唯一重连锁, 将重连用promise实现, 并将此promise记录下来就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192export class WebsocketClient implements IwebsocketClient { isConnected(): boolean { return this._isConnected; } private setSocketClient(socketClient: WebSocket) { this._socketClient = socketClient; this.addSocketEvent(this._socketClient); } async connect(): Promise&lt;void&gt; { if (this._isConnected) { throw new Error('Client is connected'); } if (!this.options.url) { throw new Error('Not found url'); } const socketClient = await this._connect(); if (!socketClient) { throw new Error('Connect websocket error'); } this._isConnected = true; this.setSocketClient(socketClient); this.addKeepAlive(); } private async _connect(): Promise&lt;WebSocket | null&gt; { const socket = await new Promise&lt;WebSocket | null&gt;((resolve) =&gt; { const socket = new WebSocket(this.options.url); socket.addEventListener('open', () =&gt; { resolve(socket); }); socket.addEventListener('error', (event) =&gt; { getLogger().warn(`connect websocket error`, event); resolve(null); }); }); if (socket) { socket.addEventListener('close', () =&gt; { getLogger().warn(`socket is closed`); }); } return socket; } private async sleep(milliSecond: number): Promise&lt;void&gt; { return new Promise((r) =&gt; setTimeout(r, milliSecond)); } private async _reconnect(): Promise&lt;WebSocket | null&gt; { let socketClient: WebSocket | null = null; for (let i = 0; i &lt; this.options.reconnectTimes &amp;&amp; this._isConnected; i++) { socketClient = await this._connect(); if (!socketClient) { await this.sleep(this.options.reconnectInterval + this.options.reconnectIntervalIncrease * i); } else { break; } } return socketClient; } private async reconnect(): Promise&lt;void&gt; { getLogger().warn(`target websocket reconnet`); if (this._isConnected &amp;&amp; !this._lockReconnectPromise) { this.eventBus.emit(ClientEvent.RECONNECT, ClientReconnectStatus.START); this._lockReconnectPromise = this._reconnect(); const socketClient = await this._lockReconnectPromise; if (!socketClient) { this.eventBus.emit(ClientEvent.RECONNECT, ClientReconnectStatus.FAIL); } else { this.eventBus.emit(ClientEvent.RECONNECT, ClientReconnectStatus.SUCCESS); this.setSocketClient(socketClient); } this._lockReconnectPromise = null; } else if (this._lockReconnectPromise) { await this._lockReconnectPromise; return; } } private addSocketEvent(socketClient: WebSocket): void { socketClient.addEventListener('message', async (event: MessageEvent) =&gt; { const resultUInt8Array: Uint8Array = event.data instanceof Blob ? new Uint8Array(await event.data.arrayBuffer()) : event.data; const resultText = new TextDecoder('utf-8').decode(resultUInt8Array); this.eventBus.emit(Event.MESSAGE, JSON.parse(resultText) as Data); }); } private addKeepAlive() { this._keepAliveTimer = window.setInterval(async () =&gt; { try { await this.send&lt;request, response&gt;({ type: 'ping' }); } catch (e) { getLogger().warn(`Keepalive error`); } }, this.options.keepAliveInterval); }} 发送消息发送前注册本地的消息回调处理函数, 并且根据超时时间设置回调, 如果没有按时返回则直接按超时进行处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465export class WebsocketClient implements IwebsocketClient { private sendRequest(request: Request, mainCmd: number, subCmd: number): void { if (!this._isConnected) { throw new Error(`Websocket not connected`); } if (this._socketClient?.readyState !== WebSocket.OPEN) { this.reconnect(); throw new ClientError(`websocket state error`, ErrorCode.REQUEST_TIMEOUT); } if (this._isConnected &amp;&amp; this._socketClient) { getLogger().info(`Request, rpcId: ${request.data.rpcid}`); this._socketClient.send(TextEncoder.encode(JSON.stringify(request))); } } private registerRpcIdHandler(rpcId: string, resolve: () =&gt; void, reject: () =&gt; void) { this._rpcHandler[rpcId] = { resolve, reject, }; } async send&lt;Q extends {}, T&gt;(cmd: number, payload: Q = {} as Q): Promise&lt;T&gt; { if (!this._isConnected) { throw new Error(`Websocket not connected`); } return await new Promise&lt;T&gt;((resolve, reject) =&gt; { const rpcId = this.getRpcId(); let isTimeout = false; const timer = setTimeout(() =&gt; { isTimeout = true; this.reconnect(); reject(new ClientError(`Request Timeout`, ErrorCode.REQUEST_TIMEOUT)); }, this.options.rpcTimeout); this.registerRpcIdHandler( rpcId, (value?: T) =&gt; { if (!isTimeout) { clearTimeout(timer); resolve(value); } }, (error?: ClientError) =&gt; { if (!isTimeout) { clearTimeout(timer); reject(error); } }, ); try { this.sendRequest({ header: { rpcid: rpcId, }, body: { cmd: cmd, payload: b64EncodeUnicode(JSON.stringify(payload)), }, }); } catch (e) { clearTimeout(timer); throw e; } }); }} 事件处理这里使用ts的函数重载实现的on方法, 可以在客户端使用指定事件的时候自动加上类型判断和检查 123456789export class WebsocketClient implements IwebsocketClient { on(event: ClientEvent.SERVER_CALL, callback: ({ data }: { data: Data }) =&gt; void): () =&gt; void; on(event: ClientEvent.SERVER_ERROR, callback: (error: ClientError) =&gt; void): () =&gt; void; on(event: ClientEvent.RECONNECT, callback: (status: ClientReconnectStatus) =&gt; void): () =&gt; void; on(event: ClientEvent, callback: (data: any, mainCmd?: number) =&gt; void): () =&gt; void { this.eventBus.on(event, callback); return () =&gt; this.eventBus.off(event, callback); }} 使用开发完成这个通用的websocketclient后, 使用起来就非常方便了, 而且是ts类型全兼容的 12const result = await this.client.send&lt;RequestData, ResponseData&gt;(data);return result.data; 其他二进制传输与文本传输最开始是直接使用的纯json文本传输, 但是后端为了安全性改为了base64后的二进制传输, 但是后来发现TextEncoder在某些android的webview内的兼容性不好, 最终还是改为base64的文本传输 proto生成类型定义.ts服务端提供的proto能生成客户端代码, 也能生成ts解析类型, 所以在想能不能直接生成我们需要的ts的类型定义, 不需要类型解析 研究了一番之后发现是可以直接用的, 只是有点hack. 先将proto转化为js代码 1npx -p protobufjs -c &quot;pbjs ./**/*.proto -p ./ -t static -w commonjs --keep-case --force-number -o proto_out.js&quot; 上面这句命令能将proto文件生成一份js解析数据格式代码, 然后再使用官方提供的命令, 将proto转化为ts文件 1npx -p protobufjs -c &quot;pbts proto_out.js proto_out.ts&quot; 这两步完成后, 就可以得到一份完整的proto的ts类型定义, 但是里面会有很多class和格式解析的代码, 这些都是我们不需要的, 需要在生成的时候去掉 研究了源码之后, 发现在protobufjs源码里去掉一部分就可以了 123456789101112131415// change node_modules/protobufjs/cli/lib/tsd-jsdoc/publish.js// at line: 509// handles a class or class-likefunction handleClass(element, parent) { var is_interface = isInterface(element); begin(element, is_interface); if (is_interface) write(&quot;interface &quot;); else {- if (element.virtual)- write(&quot;abstract &quot;);- write(&quot;class &quot;);+ return } 将以上过程实现一个自动化脚本, 在脚本里将生成的proto.ts里加上格式化和eslint的部分注释, 就可以全自动根据proto生成ts类型了. 服务端再更新proto我们只需要重新跑一遍脚本, 就能获得最新的接口格式和数据定义, 也能看到具体diff","link":"/2020/07-23-websocket-rpc/"},{"title":"React App - Water Mark","text":"背景最近需要实现前端水印, 于是实现了一个通用组件, 各系统都可以直接使用, 有一定的防破解能力 开发过程原理直接根据页面长宽生成需要的水印div元素, 然后将元素插入到页面中即可 防破解通过MutationObserver监听页面元素变化, 如果发现元素变化, 则重新生成水印, 由于我们的元素是由react自动生成的, 所以不需要做任何特殊改动, 只需要改变一次数据, 重新render即可 如果用户通过修改class样式实现样式覆盖, 我们这里也可以很简单的使用随机生成className字符串来解决这个问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React, { useEffect, useState } from 'react';const itemWidth = 100;const itemHeight = 20;const itemMarginLeft = 100;const itemMarginTop = 120;const itemTop = 20;const itemLeft = 20;const WaterMark: React.FC&lt;{ /** * 组件 classname */ className?: string; /** * 水印显示内容 */ content: string;}&gt; = React.memo(({ className, content }) =&gt; { const [itemCountState, setItemCountState] = useState({ x: 0, y: 0 }); useEffect(() =&gt; { const onResize = _.debounce(() =&gt; { const x = Math.floor((document.body.clientWidth - itemLeft + itemMarginLeft) / (itemWidth + itemMarginLeft)); const y = Math.floor((document.body.clientHeight - itemTop + itemMarginTop) / (itemHeight + itemMarginTop)); if (x !== itemCountState.x || y !== itemCountState.y) { setItemCountState({ x, y }); } }, 200); onResize(); window.addEventListener('resize', onResize); return () =&gt; window.removeEventListener('resize', onResize); }, []); const [refreshState, setRefreshState] = useState(false); const containerRef = React.useRef&lt;HTMLDivElement&gt;(null); useEffect(() =&gt; { const observer = new MutationObserver(() =&gt; { setRefreshState(true); setTimeout(() =&gt; { setRefreshState(false); }, 500); }); observer.observe(containerRef.current, { attributes: true, childList: true, subtree: true }); return () =&gt; { observer.disconnect(); }; }, []); return refreshState ? null : ( &lt;div ref={containerRef}&gt; &lt;div className={classNames('water-container', className)}&gt; {_.map(Array.from({ length: itemCountState.y }), (item, y) =&gt; _.map(Array.from({ length: itemCountState.x }), (item, x) =&gt; ( &lt;div style={{ left: `${itemLeft + (itemWidth + itemMarginLeft) * x}px`, top: `${itemTop + (itemHeight + itemMarginTop) * y}px` }} className='water-mark' key={`${y}-${x}`} &gt;&lt;/div&gt; )), )} &lt;/div&gt; &lt;style jsx&gt;{` .water-container { .water-mark { position: absolute; z-index: 99999; font-size: 14px; color: #000; opacity: 0.05; filter: alpha(opacity=5); pointer-events: none; -webkit-transform: rotate(-15deg); -moz-transform: rotate(-15deg); -o-transform: rotate(-15deg); -ms-transform: rotate(-15deg); transform: rotate(-15deg); max-width: 400px; word-wrap: break-word; &amp;::before { content: '${content}'; } } } `}&lt;/style&gt; &lt;/div&gt; );});export default WaterMark;","link":"/2020/11-02-react-app-water-mark/"},{"title":"React App - Chrome Big Content","text":"问题在系统内有个地方会显示设备传上来的系统堆栈, 有时候在windows上这段堆栈会非常大. 而它是已经自带格式的了, 之前的做法是直接用一个pre显示这段内容就可以. 但是最近发现了一个问题, 在chrome下, 如果内容超过1M, 就会非常卡顿, firefox下就不会出现这个问题. 最开始还以为是我们系统元素过多, 导致了这个问题, 但是实测发现, 即时是一个空的html, 一个纯文本节点内容超过1M的时, chrome渲染都需要5s以上, 而firefox是秒开, 所以定位到了这个问题. 解决尝试了一下, 只要把节点划分得越多, chrome就渲染得越快. 但也不能太多, 如果节点太多同样会导致dom渲染较慢, 取一个中间值, 分成30-50个节点, 就可以实现性能的平衡. react实现123456789101112131415161718192021222324252627282930const strArr = useMemo(() =&gt; { const result: string[] = []; if (!data) { return result; } const rows = data.split(/\\n/); let currentIndex = 0; _.map(rows, (row) =&gt; { const rowStr = `${row}\\n`; if (!result[currentIndex]) { result[currentIndex] = rowStr; } else if (result[currentIndex]) { if (result[currentIndex].length + rowStr.length &lt;= 8000) { result[currentIndex] += rowStr; } else { currentIndex++; result[currentIndex] = rowStr; } } }); return result;}, [data]);return ( &lt;div className='code-font-family'&gt; {_.map(strArr, (str, index) =&gt; ( &lt;pre key={index}&gt;{str}&lt;/pre&gt; ))} &lt;/div&gt;); 其他在测试的时候额外尝试了一下极端情况, 发现不管是否分多个节点, 在超过20M的文本内容情况下, chrome打开都会直接崩溃, 而firefox没有这个问题. 看来chrome和firefox还是有区别的","link":"/2020/12-04-react-app-chrome-big-content/"},{"title":"React App - Performace","text":"起因最近突然发现在大文件渲染预览的时候, 会卡顿很久, 连loading都无法显示, 用浏览器的performance查看, 发现是因为设置了loading之后, 会再次重排(reflow)一遍所有的子节点, 导致页面卡顿, 表现在performace记录上是会出现很长的一条Layout Shift记录 问题排查仔细研究后发现这个问题触发的具体流程是: 打开一个比较大的页面 点击事件刷新页面数据 刷新时候触发loading动画 由于我们的loading动画在大页面的最外层, 会触发所有子节点reflow, 导致Layout Shift 子节点reflow完成后, 数据加载回来, 取消loading动画, 刷新数据 新数据再次触发reflow, 两次连续的Layout Shift导致用户感觉卡顿 解决办法项目中的loading组件是直接使用的antd的Spin组件, 而包裹页面的用法一般如下, 而且为了支持自动适配大小, 有时会设置flex相关的class, 支持内层容器自动适配外层容器大小 123&lt;Spin tip='Loading...'&gt; &lt;Alert message='Alert message title' description='Further details about the context of this alert.' type='info' /&gt;&lt;/Spin&gt; 而解决重绘reflow的方法也很简单, 就是各处都讲过的: 绝对定位元素不会引起reflow, 开发一套适配spin的绝对定位的class就可以了, 将真实的子元素放在Spin外层, 就不会引起reflow了 12345678910111213141516171819.ant-spin-relative { position: relative; .ant-spin-nested-loading { position: static; .ant-spin-spinning { display: flex; align-items: center; justify-content: center; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 10; max-height: 100%; background-color: rgba(255, 255, 255, 0.5); } }} 123456&lt;div className='ant-spin-relative'&gt; &lt;Spin spinning={true}&gt; &lt;div&gt;&lt;/div&gt; &lt;/Spin&gt; &lt;Page /&gt;&lt;/div&gt; 小结虽然最终的解决办法很简单, 但是一路排查下来过程却挺麻烦, 特别是chrome开了performance后渲染性能感觉直接减少了两倍, 十分影响效率","link":"/2020/12-10-react-app-performace-flex/"},{"title":"Next App - ssr redux","text":"背景最近在开发一个新项目的时候, 想尝试使用next.js来实现服务端渲染, 但最终碰到一个比较棘手的问题, 最终还是使用回了create-react-app客户端渲染, 这里记录下碰到的问题, 便于以后如果有解决方案了, 可以直接使用. 问题在页面中, 用户信息和部分权限状态以前是保存在store中的, 这样便于全局统一使用. 在csr的情况下, 只需要在root组件中, 统一处理相关加载和更新请求并保存数据变化到store中即可. 但是在ssr的场景下, 需要优化首屏渲染, 而且这部分数据也是可以通过server端的请求写入store的, 于是尝试下在服务端使用redux并保存到客户端 next.js redux redux server-rendering 如果这里使用客户端异步加载或者window.__PRELOADED_STATE__的方式注入, 就不能做到首屏渲染的时候带上这些信息了, 所以必须在服务端渲染的时候, 先把需要的数据提前加载好, 并且把数据通过getInitialProps/getServerSideProps传给组件, 并同步到全局store, 就能在首屏渲染的时候携带好数据了. 而且这样在服务端渲染的时候, 也能同步通过store获取需要的数据 同步store数据在服务端使用redux生成store数据并同步到客户端有两种方案: 获取server-store单例因为可能多个组件同时需要用到store, 所以我们将store实例化为单例, 并绑定在req上, 保证唯一实例 123456789101112131415import { IncomingMessage } from 'http';import _ from 'lodash';import { AppStore } from '../reducers';import initializeStore from '../reducers/store';const STORE_KEY = '__store';const getServerStore = (req: IncomingMessage): AppStore =&gt; { if (!_.get(req, STORE_KEY)) { _.set(req, STORE_KEY, initializeStore()); } return _.get(req, STORE_KEY) as AppStore;};export default getServerStore; 通过_app.tsx全局同步1234567891011App.getInitialProps = async (appCtx: AppContext) =&gt; { const store = UTILS.getServerStore(appCtx.ctx.req); console.log('app store.getState() : ', store.getState()); store.dispatch(userInfoDucks.setUserInfo({ ...appCtx.ctx.req.user })); return { storeState: store.getState() };};export default App; 通过page.tsx页面同步123456789101112export const getServerSideProps: GetServerSideProps = async (ctx) =&gt; { const store = UTILS.getServerStore(ctx.req); store.dispatch(userInfoDucks.setUserInfo({ ...ctx.req.user })); console.log('home store.getState() : ', store.getState()); return { props: { storeState: store.getState(), }, };}; 上面两个方案都能实现首屏渲染的时候能正确获取到store里的数据, 但是都有一些比较严重的问题: 通过_app.tsx全局同步 每次页面切换, 都会看见有一个请求: /_next/data/development/xxx.json, 里面会携带storeState, 是一份完整的数据, 这样实际上会出现的效果是: 服务端的store数据会完全覆盖客户端store数据, 即使做好相关数据的reducer, 也会造成每个请求都会额外携带很多无用的信息, 而store里如果保存了比较大的数据, 也会造成性能影响. 如果客户端修改了store暂存到本地的数据, 或者某个特殊页面想额外获取一部分新的需要保存在store中的数据, 在_app.tsx里就很难处理 会导致这个问题: 静态优化失效 通过page.tsx页面同步 可以实现不同页面加载不同store的数据, 但是同样存在一个问题: 某些基础信息, 每个页面都需要, 维护起来就比较麻烦, 但相比起_app.tsx好一点 同样也存在每次进入页面, 都会请求一次完整的数据, 即使客户端本地已经有了这份数据 某些依赖客户端动作修改store的功能无法实现: 如瀑布流加载/滚动加载更多等 本质原因碰到这个问题后思考了一下, 引起这个问题的本质原因是: 服务端无法实时获得客户端状态 比如上面出现的问题: 本地修改store无法同步到服务端 客户端需要额外参数请求的接口, 服务端无法获取 每个页面都需要请求一次完整的store数据 其实本质上都是一个原因: 服务端无法获取客户端store当前数据 如果能解决这个问题, 那么后端可以根据store的当前状态, 请求各自需要的数据, 并通过redux同步派发到页面中, 就不会造成数据请求过多等性能问题. 而传统的csr方式不会存在这个问题, 是因为在请求对应数据url的时候, 相关状态已经通过请求参数传递过去了 解决方案既然能确定问题, 那就有解决方案, 虽然不够优雅 通过cookie来解决 如果store数据量不大, 将store状态完整的通过cookie传递, 虽然数据量不大, 但也会造成流量问题 将部分首屏渲染依赖数据通过cookie传递, 其他页面数据各自通过store传递, 比上一种方案好一点, 但是开发起来非常麻烦, 并且cookie到store的数据同步也不是很简单的事情 开源方案: next-redux-wrapper, 它实际上上做的事情和上面的方案是一样的, 其中提到Persist可以使用next-redux-cookie-wrapper来解决, 实际上也是使用cookie来解决, 但是优化了数据传输部分 小结最终由于这个状态同步的问题, 可以看出ssr不太适合这种类型的项目, 更适合页面结构比较简单, 没有太多状态信息的应用, 但是这次研究仍然是非常有意义的, 彻底梳理清楚了和ssr和csr的优缺点, 可以为以后的项目选型提供参考","link":"/2020/12-22-next-app-ssr-redux/"},{"title":"React App - Preload Request","text":"背景最近在查看新技术和文章时, 突然看到一个很有意思的新特性, 研究之后以后发现我们也可以使用上, 用于优化首屏加载时间 原理link元素的rel属性值在设置成preload的时候, 可以实现预先请求这个地址, 后续在真实请求的时候, 就能直接拿到这份结果来使用, 不用再次请求 同时, 可以通过as属性来指定请求的类型是fetch, 就可以实现提前发起http GET请求(POST不行), 获取一些信息. 在我们系统中就是两个的接口: 用户登录相关信息和项目权限信息 实现过程preload按官方api用法, 直接将请求路径设置到href内 1&lt;link rel=&quot;preload&quot; href=&quot;/api/v1/user/info&quot; as=&quot;fetch&quot; /&gt; 加完之后测试, 发现它没有带上cookie, 无法获取登录态, 需要额外设置crossorigin=&quot;use-credentials&quot; 1&lt;link rel=&quot;preload&quot; href=&quot;/api/v1/user/info&quot; as=&quot;fetch&quot; crossorigin=&quot;use-credentials&quot; /&gt; 这时在network里就能看到页面加载最初就发起了一个请求了, 返回值也是正确的, 但是在页面加载完成之后却还是又发起了一次请求, 同时控制台提示了一个warning 1The resource https://xxxxxxxxx/api/v1/user/info was preloaded using link preload but not used within a few seconds from the window's load event. Please make sure it has an appropriate `as` value and it is preloaded intentionally. 这样明显就是虽然link设置了preload, 但是返回的结果没有被用上, 又按照官方文档开了一个新页面, 在控制台尝试一下发现是没问题的, 说明是我们系统内的使用方法的问题. 排查了参数/路径等没问题之后, 注意到浏览器内network日志记录里, 我们的请求类型是xhr, 怀疑是不是这一块的问题. 尝试将系统内的请求直接使用fetch写死, 发现是可以复用preload的, 于是定位到了这个问题 fetch最初我们系统使用过fetch作为基础请求库, 后来发现兼容性不够好, 部分电脑的chrome版本过低不支持, 需要手动升级才有fetch, 于是将底层改为使用axios实现了, 而axios是使用XMLHttpRequest来实现网络请求的, 所以不支持link-preload 解决起来也比较简单, 旧的其实已经封装过fetch方法, 将旧的fetch加上自动兼容就可以直接使用了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const _fetch: &lt;T&gt;(url: string, options?: AxiosRequestConfig) =&gt; Promise&lt;AxiosResponse&lt;T&gt;&gt; = async &lt;T&gt;( url: string, options: AxiosRequestConfig = {},) =&gt; { if (!window.fetch) { return await _axios(url, options); } const log: fetchLog&lt;T&gt; = { url, options, startTime: new Date(), }; const requestPerformance = webPerformance.startRequest(url, options.method as any); try { const response = await fetch(url, { ...options, credentials: 'include' }); log.response = response as unknown as AxiosResponse; try { _.set(response, 'result', await response.clone().json()); } catch { _.set(response, 'result', await response.text()); } log.response.data = _.get(response, 'result'); return log.response; } catch (error) { log.error = error; error.error_id = md5(Date.now() + navigator.userAgent + Math.random()); const response = (log.response = error.response || {}); const result = _.get(response.data, 'msg', response.data); if (response.status === 401) { log.error = new FetchError.AuthError(result, response); } if (response.status === 404) { log.error = new FetchError.NotFoundError(result, response); } if (response.status === 500) { log.error = new FetchError.InternalServerError(result, response); } if (response.status &gt;= 400) { log.error = new FetchError.NetworkError(result, response); } throw log.error; } finally { if (log.error) { _.attempt(() =&gt; captureException(log.error, { error_source: 'request error', referer: window.location.href, info: url, trace_id: log.response.headers?.['trace-id'], conditions: [`method.${options.method || 'GET'}`, `status.${log.response.status}`, `error_id.${_.get(log.error, 'error_id', '')}`], }), ); } _.attempt(() =&gt; webPerformance.sendClientLog(requestPerformance(log.response.status, log.response.headers['trace-id']))); log.endTime = new Date(); log.cost = log.endTime.getTime() - log.startTime.getTime(); if (log.error) { console.log('fetch log: ', log); } else { debug.log('fetch log: ', log); } }}; 代码里使用1UTILS.restful.fetch&lt;{ code: number; msg: string; data: AuthUserInfo }&gt;(api.auth.getUserInfo()); 自动注入路径这样改造完之后, 就可以直接使用link-preload预加载请求了, 但是这里的请求路径是写死在public/index.html中的, 而且我们实际上还有请求参数的, 如果固定写死不好维护, 使用htmlWebpackPlugin实现一下自动注入 1&lt;link rel=&quot;preload&quot; href=&quot;&lt;%= htmlWebpackPlugin.options.data.userInfoPreload %&gt;&quot; as=&quot;fetch&quot; crossorigin=&quot;use-credentials&quot; /&gt; 123456789101112131415// webpack.config.jsnew HtmlWebpackPlugin( Object.assign( {}, { inject: true, template: paths.appHtml, data: { userInfoPreload: `${api.auth.getUserInfo()}?${queryString.stringify({ apps: buildConfig.includesAuthApps }, { arrayFormat: 'index' })}`, permissionPreloadUrl: `${api.auth.getPermission()}`, }, }, // ... ),); 脚本加载第二个权限相关请求会复杂一点, 请求权限的时候要区分当前是哪个应用以及项目, 在每次切换时都会重新请求的. 但是为了首屏时间, 也可以通过script来实现 在public/index.html中加上自动解析url中的app和project, 并直接加上preload-link对permission的请求即可, 因为这里有部分是使用localStorage的逻辑, 所以不能全部放在webpack.config.js中处理, 只能在页面加载时候处理了. 保证和真实使用时统一逻辑就行. 即使preload路径修改或者参数错误, 也不会影响到页面的正常使用, 因为预加载是如果一样就使用, 如果不一样, 会直接发起新的请求的, 保证了正式使用时的准确性 123456789101112131415161718192021&lt;script&gt; var appAuthConfig = &lt;%= htmlWebpackPlugin.options.data.appAuthConfig %&gt;; var paths = window.location.pathname.split('/'); var app = paths[1]; var project = paths[2]; var authApp = appAuthConfig[app] || 'all'; if (authApp !== 'all' &amp;&amp; !project) { var storeConfig = JSON.parse(localStorage.getItem('STORE_APP_CONFIG') || '{}'); if (storeConfig &amp;&amp; storeConfig._all_last &amp;&amp; storeConfig._all_last.project) { project = storeConfig._all_last.project; } } else if (authApp === 'all') { project = 'all'; } var preloadLink = document.createElement('link'); preloadLink.href = '&lt;%= htmlWebpackPlugin.options.data.permissionPreloadUrl %&gt;?app=' + authApp + '&amp;project=' + project; preloadLink.rel = 'preload'; preloadLink.as = 'fetch'; preloadLink.crossOrigin = 'use-credentials'; document.head.appendChild(preloadLink);&lt;/script&gt; 小结这次的优化逻辑非常简单, 但是效果却非常好, 因为是将两个必须请求和会强制阻塞页面加载的逻辑提前到了页面最初加载时. 在现在系统内, html和js文件加载一般在300-500ms内, 而这两个请求加起来可能占用400ms, 优化前页面loading完成到能正常使用的时间大概需要800ms, 修改完成之后, 首屏时间是js文件与user请求时长中最长的, 一般在400ms内, 因此这次优化的效果非常好, 而且这个方法非常通用, 其他类似系统有登录/权限请求的也可以同样使用这个方案","link":"/2021/03-09-react-app-preload-request/"},{"title":"CNPM - with custom auth server","text":"背景最近开发了越来越多的内部js库, 库的版本管理就显得越来越重要了. 之前的做法是通过gitlab-ci控制master发布到gitlab-release中, 但是随着库的数量的增长, 以及项目也需要做依赖库的版本管理的需求, 所以考虑搭建一个私有的cnpm仓库来存储内部开发的js库 调研初步看到有两个比较常用的解决方案 cnpm - 阿里出品 verdaccio - 最近流行的开源方案 cnpm的优点是稳定, 相关开发文档全面, 而且使用的用户也比较多. 而verdaccio看起来比较新颖而且有比较多的新特性, 但是开发资料少, 而且很少见到有大型用户使用. 由于我们这个仓库只是作为内部库的registry使用, 不太需要新功能以及人力来维护, 所以最终权衡后, 还是考虑更稳定和使用更广泛的cnpm来搭建自己的私有仓库 实现需求 稳定存储 权限控制 减少侵入 易于部署 开发私有registry最基础的需求是前面两点: 稳定存储和权限控制. 然后出于维护成本的考虑, 希望能尽可能减少开发量和侵入性修改, 便于后期迭代升级, 也需要减少部署成本, 如更换服务器或迁移机房后重新部署起来不会麻烦 设计分别解决以上需求的方案如下: 使用现有的CephFS来解决稳定存储的问题, 虽然cnpm也支持s3存储, 但是在本地开发或测试环境使用s3会比较麻烦, 因此这里直接使用CephFS来存储, 它的体验和本地文件系统是一样的, 同时也是支持多副本存储和共享存储挂载的 研究了cnpm的用户模块后, 发现只需要实现一个自己的user_service来提供权限认证就可以了, 它已经定义好了需要实现的接口和结构 为了实现减少代码侵入, 将user_service和scope等管理接口额外抽离出一个独立服务来提供结构给cnpm调用, 避免修改过多的cnpm的代码导致维护困难 直接容器化部署, 可以很简单的扩缩容, 没有运维压力 开发docker化cnpm已经提供了docker化的方案, 自带Dockerfile和dockerize/config, 修改里面需要调整的内容即可. 本地开发可以直接修改docker-compose.yml里的volume/mysql等配置. user_service比较重要的就是这一块代码调整了, cnpm默认使用的default_user_service是直接读取config.js里相关配置实现的, 我们需要同样实现一个user_service, 只是将信息通过接口获取. 其中proto.auth接口就是提供给客户端npm login使用的, 传入参数是用户输入的username和password. 而我们这里为了避免用户泄露密码, 采用的是用户的登录token去auth平台校验, 避免用户密码泄露 1234567// modify user.js// var DefaultUserService = require('./default_user_service');// config.userService = new DefaultUserService();// config.customUserService = false;var AuthUserService = require('./auth_user_service');config.userService = new AuthUserService();config.customUserService = true; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// auth_user_service.js'use strict';var debug = require('debug')('cnpmjs.org:services:auth_user_service');var request = require('request');var gravatar = require('gravatar');// var User = require('../proxy/user');var User = require('../models').User;var config = require('../config');// User: https://github.com/cnpm/cnpmjs.org/wiki/Use-Your-Own-User-Authorization#user-data-structure// {// &quot;login&quot;: &quot;fengmk2&quot;,// &quot;email&quot;: &quot;fengmk2@gmail.com&quot;,// &quot;name&quot;: &quot;Yuan Feng&quot;,// &quot;html_url&quot;: &quot;http://fengmk2.github.com&quot;,// &quot;avatar_url&quot;: &quot;https://avatars3.githubusercontent.com/u/156269?s=460&quot;,// &quot;im_url&quot;: &quot;&quot;,// &quot;site_admin&quot;: false,// &quot;scopes&quot;: [&quot;@org1&quot;, &quot;@org2&quot;]// }module.exports = AuthUserService;const authRequest = async (options) =&gt; { return await new Promise((resolve, reject) =&gt; { request(options, function (error, response) { if (error) { return reject(error); } if (response.statusCode !== 200) { return reject(response.statusCode); } const result = JSON.parse(response.body); return resolve(result); }); });};async function convertToUser(row) { const userWithScopeInfo = await authRequest({ method: 'GET', url: `${config.userServiceConfig.npmUserServiceAddr}?name=${row.username}`, headers: { 'X-TOKEN': '// ...', }, }); debug('userWithScopeInfo: ', userWithScopeInfo); var user = { login: row.username, email: row.email, name: row.username, html_url: 'http://cnpmjs.org/~' + row.username, avatar_url: '', im_url: `// ...`, site_admin: !!userWithScopeInfo.data.userInfo.is_super_admin, scopes: userWithScopeInfo.data.scopeList.map((x) =&gt; x.id), }; if (row.json) { var data = row.json; if (data.login) { // custom user user = data; } else { // npm user if (data.avatar) { user.avatar_url = data.avatar; } if (data.fullname) { user.name = data.fullname; } if (data.homepage) { user.html_url = data.homepage; } if (data.twitter) { user.im_url = 'https://twitter.com/' + data.twitter; } } } if (!user.avatar_url) { user.avatar_url = gravatar.url(user.email, { s: '50', d: 'retro' }, true); } return user;}async function getUserInfoByName(name) { try { const result = await authRequest({ method: 'GET', url: `${config.userServiceConfig.npmUserServiceAddr}?name=${name}`, headers: { 'X-TOKEN': '// ...', }, }); if (!result || !result.data) { return null; } return [].concat(result.data).find((x) =&gt; x &amp;&amp; x.username === name); } catch (e) { return null; }}function AuthUserService() {}var proto = AuthUserService.prototype;/** * Auth user with login name and password * @param {String} login login name * @param {String} password login password * @return {User} */proto.auth = function* (login, password) { var row = yield new Promise((resolve) =&gt; { request( { method: 'GET', url: config.userServiceConfig.npmUserLoginAddr, headers: { 'X-TOKEN': password, }, }, function (error, response) { if (error) { return resolve(null); } if (response.statusCode !== 200) { return resolve(null); } const result = JSON.parse(response.body); if (!result || !result.data) { return resolve(null); } if (result.data.user.username !== login) { return resolve(null); } return resolve(result.data.user); }, ); }); if (!row) { return null; } return yield convertToUser(row);};/** * Get user by login name * @param {String} login login name * @return {User} */proto.get = function* (login) { var row = yield User.findByName(login); if (!row) { return null; } var user = yield getUserInfoByName(row.name); if (!user) { return null; } return yield convertToUser(user);};/** * List users * @param {Array&lt;String&gt;} logins login names * @return {Array&lt;User&gt;} */proto.list = function* (logins) { var rows = yield User.listByNames(logins); var users = []; for (var row of rows) { const user = yield getUserInfoByName(row.name); users.push(yield convertToUser(user)); } return users;};/** * Search users * @param {String} query query keyword * @param {Object} [options] optional query params * - {Number} limit match users count, default is `20` * @return {Array&lt;User&gt;} */proto.search = function* (query, options) { options = options || {}; options.limit = parseInt(options.limit); if (!options.limit || options.limit &lt; 0) { options.limit = 20; } var rows = yield User.search(query, options); var users = []; for (var row of rows) { const user = yield getUserInfoByName(row.name); users.push(yield convertToUser(user)); } return users;}; scope_service完成user_service之后, 私有npm就可以使用了, 但是在上传包时, 发现每个用户只能上传固定scope的包, 研究后发现同样是通过config配置的, 所以同样修改为通过scope_service实现, 同时user_service的用户信息接口中也额外返回此用户有哪些scope权限以及是否超管即可 1234567891011121314151617181920212223242526272829303132333435363738394041'use strict';var request = require('request');var config = require('../config');const authRequest = async (options) =&gt; { return await new Promise((resolve, reject) =&gt; { request(options, function (error, response) { if (error) { return reject(error); } if (response.statusCode !== 200) { return reject(response.statusCode); } const result = JSON.parse(response.body); return resolve(result); }); });};const scopeService = { async getAllScope() { try { const result = await authRequest({ method: 'GET', url: `${config.userServiceConfig.npmUserServiceHost}/api/v1/scope/list`, headers: { 'X-TOKEN': '// ...', }, }); if (!result || !result.data) { return []; } return result.data.scopeList.map((x) =&gt; x.id); } catch (e) { return []; } },};module.exports = scopeService; 然后修改middleware/proxy_to_npm和middleware/sync_by_install里相关获取scope的逻辑, 改为通过scope_service获取 小结外部auth_service的实现就不用细讲了, 很简单的curd实现即可, 特殊点的是为了方便, 我们直接使用cnpm自带的mysql的库就行 开发完成后, 通过k8s将共享分布式存储CephFS挂载到容器内data目录下启动, 尝试上传包-&gt;重启容器-&gt;查看包是否能正常下载, 扩容缩容后服务均能正常运行和下载, 至此就完成了内部npm-registry的搭建 其他设置scope方便使用npm现在支持指定特定scope使用特定registry来下载, 如果不使用此命令而是在下载时候指定--registry https://my.registry.com, 偶尔会出现某些包被解析到这个registry目录下但实际上不存在的情况, 测试后发现可能是npm自己的bug, 所以实践上建议通过scope来指定registry 123npm config set '@myscope:registry' https://my.registry.comnpm install @myscope/lib tag使用在用其他包时如果想要使用最新特性, 往往会通过@next等标签来获取最新版本, 内部发布测试的时候同样可以指定tag来发布, 完成某些功能测试和提供先行体验版本等. 但是得注意的是, 即时是携带tag的版本, 版本号同样不能与正式版本冲突(即版本号为唯一主键), 建议使用@1.0.0-next-{hash:8}携带具体版本信息的字符串作为测试的版本号 1npm publish --tag next --registry https://my.registry.com ci-publish自动发布都有内部registry了, 自动发布流程就也可以安排上了. 由于npm只支持真实用户账号, 所以我们也可以同样直接使用账号的token来进行发布 在本地登录npm login --registry https://my.registry.com后, 可以在~/.npmrc文件下看到属于my.registry.com的token, 将此token设置到ci环境变量中, 通过脚本在发布时注入即可完成权限验证(此方法也适用于正式npm站点) 12npm config set //my.registry.com/:_authToken ${NPM_TOKEN}npm publish --verbose --registry https://my.registry.com","link":"/2021/04-17-cnpm-with-custom-auth/"},{"title":"Code-Server with Sidecar Auth","text":"背景去年年底在qcon2020大会上了解到了某团的微服务网格治理方式, 使用Sidecar + Unix Socket实现了服务的解耦, 目前有个同样的类似场景, 只需要鉴权功能, 所以考虑参考这个方式来实现 使用场景同样是在qcon上得到的启发, 外面各大厂都在研究独立在线IDE, 恰好现在有个需求可以尝试使用这种方式实现, 了解了一番后发现实际上都是基于code-server来实现的, 而code-server只提供了最简单的token鉴权功能, 而我们需要实现对接内部账号, 所以正好使用Sidecar来实现鉴权 调研外部的Sidecar模式是使用Unix Socket做进程间通讯的, 对比起TCP Socket通讯来说, 减少了协议解析, 所以理论上能获得更高的性能 相关资料 nodejs对Unix Socket的支持 Unix 域套接字 k8s同pod内容器共享存储文档 UNIX Socket简介这部分是copy其他资料的, 简单介绍一下UNIX Socket的概念 123456789101112131415const http = require('http');// 创建一个 HTTP 服务器var server = http.createServer((req, res) =&gt; { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('hello world');});// 从'127.0.0.1'和3000端口开始接收连接server.listen(3000, '127.0.0.1', () =&gt; { console.log('在端口3000启动了服务器');});// 从 UNIX 套接字所在路径 path 上监听连接server.listen('/path/to/socket', () =&gt; { console.log('从socket路径启动了服务器');}); 在上面示例中，使用port端口形式的监听，本质是监听TCP Socket端口。而使用path文件路径的方式，本质上是Unix Domain Socket（Unix域套接字）文件。 什么是Socket在网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个Socket。Socket可以被定义描述为两个应用通信通道的端点，一个Socket端点可以用Socket地址（地址 IP、端口、协议组成）来描述。Socket作为一种进程通信机制，操作系统会分配唯一一个Socket标识，这个标识与通讯协议有关（不仅限于TCP或UDP）。 Unix Domain SocketUnix Domain Socket并不是一个实际的协议，它只在同客户机和服务器通信时使用的API，且一台主机与在不同主机间通信时使用相同的API。 Unix Domain Socket有以下特点 Unix Domain Socket使用的地址通常是一个文件 在同一主机通讯时，传输速率是不同主机间的两倍 Unix Domain Socket套接字描述符可以在同一主机不同进程间传递 Unix Domain Socket套接字可以向服务器提供用户认证信息 TCP Socket与Unix Domain Socket无论是TCP Socket套接字还是Unix Domain Socket套接字，每个套接字都是唯一的。TCP Socket通过IP和端口描述，而Unix Domain Socket通过文件路径描述。 TCP属于传输层的协议，使用TCP Socket进行通讯时，需要经过传输层TCP/IP协议的解析。 而Unix Domain Socket可用于不同进程间的通讯和传递，使用Unix Domain Socket进行通讯时不需要经过传输层，也不需要使用TCP/IP协议。所以，理论上讲Unix Domain Socket具有更好的传输效率。 实现架构设计sequenceDiagram participant B as Browser participant A as Node Auth Server participant S as Code Server participant T as Third Party User Service alt 用户访问 B ->> A: 1. 访问服务 A ->> T: 2. 获取用户信息 opt 权限验证失败 T -->> A: 3.1 无权限 A -->> B: 4.1 跳转登录页 end opt 权限验证成功 T -->> A: 3.2 有权限 A ->> S: 4.2 获取数据 S -->> A: 5.2 返回结果 A -->> B: 6.2 返回结果 end end 可以看到用户实际访问的入口是Sidecar组件, 而Code Server服务没有任何改动, 维护起来非常方便 code-servercode-server提供docker化部署方式, 同时也支持socket启动, 只需要手动修改一下启动命令, 将服务监听修改为通过socket, 并禁用auth验证 12345678910111213141516171819# code-server.DockerfileFROM codercom/code-serverRUN sudo apt-get update &amp;&amp; sudo apt-get install -y vimRUN sudo apt-get update &amp;&amp; sudo apt-get install -y npmRUN sudo npm install -g nRUN sudo n ltsRUN sudo npm install -g npmCOPY --chown=coder:coder .vscode/user-settings.json /home/coder/.local/share/code-server/User/settings.jsonCOPY --chown=coder:coder .vscode/user-keybindings.json /home/coder/.local/share/code-server/User/keybindings.jsonRUN mkdir -p /home/coder/project/WORKDIR /home/coder/project/# ENTRYPOINT [&quot;/usr/bin/entrypoint.sh&quot;, &quot;--bind-addr&quot;, &quot;0.0.0.0:8080&quot;, &quot;--auth&quot;, &quot;none&quot;, &quot;.&quot;]ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;/usr/bin/entrypoint.sh --socket /var/run/unix-socket/server.socket --auth none --disable-telemetry --disable-update-check ./&quot;] auth-sidecar这个服务比较轻量, 却是实际服务的入口, 将所有需要登录的请求验证一次用户身份, 如果不通过就返回302并跳转登录, 如果通过则通过unix-socket转发给code-server获取真实数据 这里稍微注意下需要对websocket协议同样进行转发处理, 因为code-server里用到了websocket连接, 如果不处理, 就会导致无法使用 而websocket协议同样是携带header的, 所以可以直接使用通用的鉴权方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const http = require('http');const httpProxy = require('http-proxy');const express = require('express');const _ = require('lodash');const fetch = require('node-fetch').default;const ServerPort = JSON.parse(process.env.PORT || '8080');const ProxySocketPath = JSON.parse(process.env.PROXY_SOCKET_PATH || `&quot;/var/run/unix-socket/server.socket&quot;`);const AuthProxyAddr = `...`;const getUserInfo = async (headers) =&gt; { if (!headers.cookie &amp;&amp; !headers['x-token']) { return null; } const userPermissionResponse = await fetch(AuthProxyAddr, { timeout: 3000, headers: { ..._.pick(headers, ['cookie', 'origin', 'referer', 'user-agent', 'x-token']), 'content-type': 'application/json', }, }); if (userPermissionResponse.status != 200) { console.log(`Auth Error: get user permission info from auth error [${userPermissionResponse.status}]`); return null; } const data = await userPermissionResponse.json(); if (data.code !== 200) { console.log(`Auth Error: get user permission info from auth error: ${JSON.stringify(data)}`); return null; } return data.data;};const validateUser = async (headers) =&gt; { const data = await getUserInfo(headers); if (!data) { return false; } return true;};// create a serverconst app = express();const proxy = httpProxy.createProxyServer({ target: { socketPath: ProxySocketPath }, ws: true }).on('error', (error, req, res) =&gt; { if (!res.destroyed) { res.statusCode = 500; res.end(`Server error`); } console.log(`Proxy error`, error);});const authProxy = httpProxy .createProxyServer({ target: AuthProxyAddr, changeOrigin: true, xfwd: true, }) .on('error', (error, req, res) =&gt; { if (!res.destroyed) { res.statusCode = 500; res.end(`Server error`); } console.log(`Proxy error`, error); });const server = http.createServer(app);// Proxy websocketsserver.on('upgrade', async (req, socket, head) =&gt; { // console.log('proxying upgrade request', req.url); if (!(await validateUser(req.headers))) { socket.write(`HTTP/1.1 401 Unauthorized\\r\\n\\r\\n`); socket.destroy(); return; } proxy.ws(req, socket, head);});app.route(['/api/auth', '/login', '/logout']).all((req, res) =&gt; { authProxy.web(req, res, {});});app.route('/').all(async (req, res) =&gt; { if (!(await validateUser(req.headers))) { res.redirect(`/login`); return; } proxy.web(req, res, {});});app.route('/vscode-remote-resource').all(async (req, res) =&gt; { if (!(await validateUser(req.headers))) { res.statusCode = 401; res.end(); return; } proxy.web(req, res, {});});// serve static contentapp.route('*').all((req, res) =&gt; { proxy.web(req, res, {});});server.on('error', (error) =&gt; { console.log(`Server error`, error);});server.listen(ServerPort, () =&gt; { console.log(`Server listen ${ServerPort}`);}); k8s启动其中code-server-node的project目录是通过持久化存储挂载进去的, 保证了重启不会丢失数据 1234567891011121314151617181920212223242526272829application: containers: - name: code-server-node image: code-server-node command: - /bin/bash - '-c' - /usr/bin/entrypoint.sh --socket /var/run/unix-socket/server.socket --auth none --disable-telemetry --disable-update-check ./ cpu: '2' reqCPU: '2' memory: 4Gi reqMemory: 2Gi volumeMounts: - name: unix-socket-dir mountPath: /var/run/unix-socket/ imagePullPolicy: Always - name: code-server-auth image: code-server-auth cpu: '1' reqCPU: '1' memory: 1Gi reqMemory: 1Gi volumeMounts: - name: unix-socket-dir mountPath: /var/run/unix-socket/ imagePullPolicy: Always volumes: - name: unix-socket-dir emptyDir: {} 小结开发完成后实测非常好用, 而且是完全无侵入式实现, 对后续的code-server维护/升级等都无压力, 体验非常好 同时经过这次Sidecar尝试后, 发现后续很多类似服务设计方案都可以考虑使用这种模式实现 问题这里仍然存在的问题是, node-auth往往使用go/c++等实现, 因为作为主要的流量入口, 往往还是会担心node性能不够. 但是此次的需求因为并不是外部访问, 所以使用node来实现方便快捷, 同时也不需要太过于担心入口的性能问题","link":"/2021/05-27-code-server-with-side-car-auth/"},{"title":"Cypress Web Automate Test","text":"背景最近项目越来越多, 测试压力也增大了, 于是酝酿很久的自动化测试也提上议程了. 框架选择常见的项目脚手架中其实应该都自带了测试框架, 一般直接使用npm test脚本, 内置的往往是jest框架, 但是用的人却很少, 归根结底是不方便开发, 项目中的组件不是单一的, 页面逻辑也很复杂, 出bug的往往涉及到后端接口. 单独针对某个组件的测试确实意义不大, 所以调研后选择使用cypress框架, 来实现真正的模拟用户场景的端到端测试. cypress原理cypress通过调用chrome并模拟用户行为, 这意味着所有在开发中能使用到的chrome的功能, 在开发测试用例的时候都能用上, 包括脚本断点/网络请求/浏览器状态等, 这对测试开发是十分重要的 安装cypress提供create-react-app的支持版, 但实际上是依赖侵入性修改的, 实际上直接使用通用的安装方式更好 12cd /home/project/npm install -D cypress 虽然我们将cypress安装在当前项目下, 但cypress实际上还是在全局安装了它自己的chrome和调用方式, 方便多个项目共享. 启动可以修改package.json里加上script.cypress-open: &quot;cypress open&quot;来启动cypress, 也可以直接使用npx来启动 1npx cypress open 第一次启动时, 会提示首次运行, 然后初始化cypress/文件夹到项目目录下, 并生成cypress.json文件, 以后相关配置只需要修改这两块内容, 最后会自动打开cypress控制台, 可以看到里面自带的一些写好的测试用例demo. 点击某个spec.js后, 就会自动打开浏览器, 运行测试脚本了. ts支持准备好环境后, 就来开发第一个测试脚本, 一开始就碰见了问题: 按官方实例开发一个app.spec.js后, eslint提示'cy' is not defined.eslintno-undef不存在 查了下文档, 发现cypress也有完善的typescript支持, 只需要配置一下即可 首先修改app.spec.js后缀为ts, 然后在cypress目录下添加tsconfig.json文件 12345678910{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;es5&quot;, &quot;dom&quot;], &quot;esModuleInterop&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;types&quot;: [&quot;cypress&quot;, &quot;../node_modules/@types/node&quot;] }, &quot;include&quot;: [&quot;**/*.ts&quot;]} 123456// app.spec.tsdescribe('First Test', () =&gt; { it('Visit the app', () =&gt; { cy.visit('/'); });}); 完成后, 就可以很轻松的使用typescript来开发了 覆盖率报告一般使用jest的项目能使用npm run test -- --coverage生成覆盖率报告, 在cypress中同样也有相关功能, 直接参考官方文档配置即可 在开发这块时突然很好奇是如何在浏览器中生成原始代码覆盖率的, 查了Istanbul的工作原理后, 发现它实际上是在编译时注入运行次数信息实现收集的 function App() { cov_26lgl7ul30().f[0]++; cov_26lgl7ul30().s[0]++; return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(\"div\", { }) } babel-plugin-istanbul既然是编译时注入的, 那就需要babel插件了, 注意只有在非生产环境下才需要加上这个插件 1234// npm i -D babel-plugin-istanbulif (!isEnvProduction) { config = addBabelPlugin(['istanbul'])(config);} cypress-plugin此处直接按照文档内容配置 123456789// cypress/plugins/index.jsmodule.exports = (on, config) =&gt; { require('@cypress/code-coverage/task')(on, config); // include any other plugin code... // It's IMPORTANT to return the config object // with any changed environment variables return config;}; 12// cypress/support/index.jsimport '@cypress/code-coverage/support'; 生成覆盖率报告插件配置完成后, 运行一次测试用例, 就可以在coverage文件夹下看到html版的覆盖率报告了. 如果需要文本格式的报告, 可以使用npx nyc report --reporter=text-summary生成 全链路覆盖率cypress可以实现从后端到前端同时收集覆盖率并合并到同一个报告中, 在某些独立项目中其实也是很有意义的, 可以参考官方例子 测试用例鉴权内部系统测试往往要鉴权, 下策是用自己的账号密码登录, 上策是直接获取测试账号token写入cookie即可 1234567describe('Web Test', () =&gt; { it('Visit Web', () =&gt; { cy.setCookie('TOKEN', 'my-token'); cy.visit('/'); cy.get('.App-header .ant-btn').children().first().should('have.text', 'Ant Design').invoke('prop', 'tagName').should('be.equal', 'SPAN'); });}); url跳转某些操作后需要检测url是否生效和一致, 可以使用url()来检测 1cy.url().should('include', '/index'); 其他最后在ci中配上npm start &amp;和npx cypress run, 就可以实现全流程自动化测试了. 虽然由于时间关系只覆盖了最重要的几个页面和组件, 但是框架已经搭建完成, 后续在开发业务的时候都能同步开发测试内容了","link":"/2021/06-28-cypress-automate-test/"},{"title":"JS Common Middleware","text":"背景最近有个库需要新增一个功能, 影响面比较广, 但是这个功能又同时是可选的, 如果关闭后希望对原有逻辑没有任何影响, 所以就考虑使用插件化注入和中间件调用的方式来实现了. 而提到中间件, 目前前端比较熟知的就是Express和Koa的中间件机制了. Express的中间件是依次顺序调用的, 而Koa是洋葱圈模型, 从可控性角度来看, 洋葱圈模型的自由程度更高一点, 所以在实际开发中, 可以参考Koa的中间件机制来实现 实现调研先分析下Koa的中间件是如何实现的, 然后参考实现我们自己的中间件 Koa-composeKoa里中间件最核心的组装方法就是compose函数了, 它传入一个数组, 能实现嵌套调用传值, 源码也十分简洁, 这里简单分析下调用顺序和含义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748'use strict';/** * Expose compositor. */module.exports = compose;/** * Compose `middleware` returning * a fully valid middleware comprised * of all those which are passed. * * @param {Array} middleware * @return {Function} * @api public */function compose(middleware) { if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!'); for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!'); } /** * @param {Object} context * @return {Promise} * @api public */ return function (context, next) { // last called middleware # let index = -1; return dispatch(0); function dispatch(i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')); index = i; let fn = middleware[i]; if (i === middleware.length) fn = next; if (!fn) return Promise.resolve(); try { return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err); } } };} 类型检查和注释可以忽略, 只分析核心内容 compose方法接受一个数组, 返回了一个函数, 这个函数在调用后返回dispath(0)方法, 而核心实现内容在dispath方法中 dispatch首先检查了一下当前执行的函数是否之前已经执行过, 如果没有执行过, 则记录当前执行的index, 用于下一次检查 然后根据下标获取到第i个中间件函数, 而如果此时已经执行了全部的中间件, 那么fn就是next方法, 就是需要使用中间件包裹的最原始的函数 后续就比较简单了: 如果fn不存在, 直接返回Promise.resolve(), 否则将context和下一次需要执行的中间件函数传入fn中, 这样fn里就能获取到context和next函数, 可以自由处理. 而且全程使用Promise包裹, 可以更好的控制异步操作 Koa-application再看看在Koa里的调用方法 123456789101112131415161718192021222324252627class Application extends Emitter { listen(...args) { debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args); } callback() { const fn = compose(this.middleware); if (!this.listenerCount('error')) this.on('error', this.onerror); const handleRequest = (req, res) =&gt; { const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); }; return handleRequest; } handleRequest(ctx, fnMiddleware) { const res = ctx.res; res.statusCode = 404; const onerror = (err) =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); }} server启动时调用callback, 返回了handleRequest函数, handleRequest函数构造了ctx对象, 和中间件函数一起传给this.handleRequest执行(这里可以看见handleRequest并没有使用到compose返回函数的第二个next参数). context在以上代码分析中, 可以看到Koa里比较关键的一个点是使用了构造的context对象进行透传, 并在中间件执行时也传入, 这样中间件函数里就不用传参, 而是通过context对象来获取需要的参数. 但是对于其他库这样可能不够合适, 对于TypeScript的类型定义和调用来说也不够友好, 所以需要考虑将context概念去掉, 还原回函数参数调用的模式 开发分析以上调用栈, 可以发现handleRequest返回的是一个无参数的调用方法, 那么只需要从这一步开始改造即可 外部调用形式先构造出外部正常使用的调用代码 12const fn = compose(middleware);const result = fn(data); 再构造中间件里调用的代码 12345678const middleware = function (next) { return async function (...args) { console.log(`Start middleware`); const result = await next(...args); console.log(`Finish middleware`); return result; };}; compose对比Koa的compose函数, 可以发现我们的middleware返回的是一个带参数的异步函数A, 这个返回的函数A执行后才是真实的逻辑, 传参也是传入这个A函数. 而Koa返回的是一个无参数的异步函数B, 而且B函数执行后就是真实的中间件逻辑. 所以只需要将Koa的compose里返回的相关调用修改为函数A调用模式即可 123456789101112131415161718192021222324252627282930const compose = (middleware) =&gt; { if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!'); for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!'); } return (next) =&gt; { // last called middleware # let index = -1; const dispatch = (i: number) =&gt; (...args) =&gt; { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')); index = i; const fn = middleware[i]; if (i === middleware.length) { if (next) { return Promise.resolve(next(...args)); } } if (!fn) return Promise.resolve(); try { return Promise.resolve(fn(dispatch(i + 1))(...args)); } catch (err) { return Promise.reject(err); } }; return dispatch(0); };}; 完成后, 可以看到需要修改的内容其实很少, 主要就是将next函数改造为支持传参的模式, 并且在fn(dispatch)调用得到的A函数之后, 传入args执行真正的中间件逻辑即可 使用12345678910111213const middwareFn = (next) =&gt; { return async function (...args) { console.log(`Start middleware`); const result = await next(...args); console.log(`Finish middleware`); return result; };};const fnMiddleware = compose([middwareFn, middwareFn]);const result = await fnMiddleware(async ({ data }) =&gt; { return await 'success';})({ data }); TypeScript支持再对compose函数补完类型定义即可, 其中T是需要经过middleware的实际函数签名, 传入后能实现后续的next函数都能自动识别到此函数参数和返回值 123456789101112131415161718192021222324252627282930313233343536373839404142export type AnyFunction = (...args: any) =&gt; Promise&lt;any&gt;;export type NextFunction&lt;T extends AnyFunction&gt; = (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;;export type MiddlewareFunction&lt;T extends AnyFunction&gt; = (next: NextFunction&lt;T&gt;) =&gt; NextFunction&lt;T&gt;;export type MiddlewareCompose&lt;T extends AnyFunction&gt; = (middleware: MiddlewareFunction&lt;T&gt;[]) =&gt; (next: NextFunction&lt;T&gt;) =&gt; NextFunction&lt;T&gt;;const compose: MiddlewareCompose&lt;AnyFunction&gt; = &lt;T extends AnyFunction&gt;( middleware: MiddlewareFunction&lt;T&gt;[],): ((next: NextFunction&lt;T&gt;) =&gt; NextFunction&lt;T&gt;) =&gt; { if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!'); for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!'); } return (next: NextFunction&lt;T&gt;) =&gt; { // last called middleware # let index = -1; const dispatch: (i: number) =&gt; NextFunction&lt;T&gt; = (i: number) =&gt; (...args: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) as ReturnType&lt;T&gt;; index = i; const fn = middleware[i]; if (i === middleware.length) { if (next) { return Promise.resolve(next(...args)) as ReturnType&lt;T&gt;; } } if (!fn) return Promise.resolve() as ReturnType&lt;T&gt;; try { return Promise.resolve(fn(dispatch(i + 1))(...args)) as ReturnType&lt;T&gt;; } catch (err) { return Promise.reject(err) as ReturnType&lt;T&gt;; } }; return dispatch(0); };};export default compose; 小结实现完核心的compose后, 再完善plugin-setup相关的逻辑, 就可以实现插件注入和中间件拦截了, 对于插件的开发和核心库的维护来说也更独立和简单了 其他对比Redux ComposeRedux里也有链式调用的compose实现, 但是对比起Koa的来说, 它是通过reduce来实现将后一个函数参数调用后的结果作为下一个函数的参数, 无法通过next函数来实现调用链的控制. 在上面的compose实现中, 可以在任何中间件里结束这次调用并返回结果, 但是在redux中是无法实现的. 其他资料 插件化思维","link":"/2021/07-07-js-common-middleware/"},{"title":"Esbuild vs Babel","text":"前言最近在做等create-react-app-webpack5官方支持的同时, 去研究了一下最近新出的一些打包工具, 如vite/snowpack, 发现了一些他们各自的优缺点, 在此总结一下 打包工具webpackwebpack就不用过多介绍了, 完善的生态和插件系统, 各工具链必须要支持的框架, 基本满足所有需求, webpack5的本地缓存机制出现后也极大的提高了开发体验 snowpack相比起webpack来说, 主要优化了bundle构建的过程, 不再将所有依赖内容打包压缩到bundle.js中, 而是拆分成各自的小文件, 这样达到O(1)的构建速度, 贴个官方的对比图 但缺点也是很明显的: 社区支持不够, 各插件的整合程度不强, 如果需要用一些新功能需要自己采坑, 可能会比较困难. 而且还有个比较严肃的问题: 这种在开发期分离打包的做法, 会导致开发期和生产环境代码不一致, 风险很大. 所以在尝试了一下react-demo后, 暂时先搁置 vitevite是最近两年的热门打包工具之一, 也有受到snowpack启发和影响, 同样是开发期通过es-modules加载依赖库, 但有更好的官方支持和社区环境, 以及一个比较大的新特性: 使用了esbuild来打包js代码 按照官方文档初始化了一个react项目后, 确实有了丝滑的开发体验, 打包速度也是非常快, 但同样存在开发期和打包生产环境内容不一致的问题, 而且polyfill都需要自己引用解决, 在正式项目上还是不太方便使用 esbuild虽然vite并不太适合现在的react项目开发, 但是里面的esbuild却是个非常好的工具, 其实在webpack中也是可以使用esbuild来打包的 esbuild-loaderesbuild可以简单的理解为: 使用go语言开发的babel编译器 在webpack中使用也非常简单: 直接用esbuild-loader替换掉babel-loader即可 这里直接简单粗暴的通过索引替换掉babel-loader, 如果要生产环境使用可以使用find和filter查询到索引后替换 12345678910111213config.module.rules[1].oneOf[3].loader = require.resolve('esbuild-loader');config.module.rules[1].oneOf[3].options = { loader: 'tsx', target: 'es2015',};config.module.rules[1].oneOf.splice(4, 1);config.optimization.minimizer = [ new ESBuildMinifyPlugin({ target: 'es2015', }),]; 替换完成后, 执行npm start, 在webpack5的加持下可以做到10s内启动完成, 相比起使用babel-loader的25s来说, 提高了大约150%的构建速度, 同时, 也不存在vite/snowpack的开发环境和生产环境代码不一致的问题, 看起来是个比较好的选择 问题虽然esbuild极大的提高了编译速度, 但是存在一个硬伤: 暂时还不支持插件, 这意味着无法自定义或者按需修改编译内容. 而现在很多工具链都是依赖babel-plugin来实现各自的功能的. styled-jsx比如常用的styled-jsx, 是通过[babel-plugin]styled-jsx/babel插件来实现的自定义解析jsx, 以及现在支持的babel-macro也需要使用babel-plugin-macros. 使用esbuild的情况下, 就完全无法使用styled-jsx了 在rollup中的babel插件也是同样可以支持styled-jsx的, 但vite虽然使用的rollup, 但由于同样使用esbuild, 所以无法支持styled-jsx istanbul其次是代码覆盖率插件, 上个月研究的cypress的代码覆盖率生成, 是依赖babel-plugin-istanbul注入代码调用埋点的, 在esbuild打包时没有办法注入, 所以也就没有办法获取覆盖率了 结论兜兜转转饶了一圈, 结果还是回归原始的webpack+babel老套路了. 虽然前端工程迭代足够快, 但想达到更高的高度, 还是需要时间沉淀优化的","link":"/2021/08-19-esbuild-vs-babel/"},{"title":"React App Framework - 11. Webpack 5 Module Federation","text":"背景久违的React-App-Framework终于有了新内容了, 从一年前就开始关注的Create-React-App对于Webpack5的支持, 在上个月终于有了可以稳定使用的版本, 可以通过@next版本来使用webpack5开发, 也可以使用期待很久的文件缓存加速和Module Federation了, 而且对于分子应用来说, Module Federation提供的各自打包发布能力格外重要. 经过一段时间的试用和踩坑, 终于完成了子应用分离打包部署, 这里记录下部分重点内容. 配置config-overrides之前在webpack4开发时, 是通过npm run eject后实现修改webpack.config.js的, 这样的好处是自由, 但是问题是不方便维护. 所以这次决定切换成使用react-app-rewired来实现修改webpack.config sass/lesssass/less和typescript主题变量注入的使用方法基本没有变化, 在config中找到对应的loaders加入相关修改即可, web-worker的支持也是同理, 不过其中有部分动态生成的配置需要从react-scripts/config/webpack.config.js中复制出来使用, 因为它没有暴露公开接口 调试方法react-app-rewired的build和start都是可以使用node debug的, 可以在运行时断点查看相应配置是否正确 1234567891011121314{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;start debug building&quot;, &quot;program&quot;: &quot;${workspaceFolder}/node_modules/react-app-rewired/scripts/start.js&quot;, &quot;args&quot;: [&quot;&quot;], &quot;outFiles&quot;: [&quot;${workspaceFolder}/config/*.js&quot;], &quot;env&quot;: {} } ]} 调整完成所有配置启动之后, 发现了第一个问题: 切换主题变量之后不会触发重新编译, 导致页面主题不变 cache与theme最开始怀疑是之前开发的babelLoader.options.customize缓存注入组件由于webpack配置变更导致没有生效, 但是实际测试后发现是有效的. 同时删除缓存文件之后主题也是可以改变的, 再联想到webpack5对于缓存有了比较大的优化, 所以基本能确定问题出现在webpack5的最新的缓存机制上了 webpack5支持了基于文件系统的持久化缓存, 官方文档指明它会在依赖项和配置内容不变的时候, 直接读取缓存内容, 不会进行任何编译. 所以可以很明确的知道问题出现在这里了, 同时官方也提供了解决方案: version参数, 设置version参数后, webpack就会针对不同的版本启用不同的缓存路径, 对于我们指定主题来说, 非常方便, 而且也不会造成切换主题时缓存失效了 1config.cache.version = `${config.cache.version}-${buildConfig.options.appTheme}`; Module Federation修复缓存问题后, webpack5就可以正式替换webpack4版本了(虽然还是使用的&quot;react-scripts&quot;: &quot;^5.0.0-next.47&quot;版本, 但是实测页面没有任何问题). 下一步就是使用最吸引人的Module Federation来实现子应用的模块化开发了, 官方文档介绍了Module Federation的基本原理, 能实现的效果是远程加载一个js应用, 可以理解为动态import的外部链接版本, 同时还支持基础库共享, 不会造成多份react/antd库的问题 架构设计由于原本已经将子应用隔离划分得比较好, 支持Module Federation的成本其实很低, 只需要配置相应的子应用打包模块配置, 并实现动态导入即可 sequenceDiagram participant U as User participant F as Base Framework participant M as App Module alt 用户访问 U ->> F: 1. 加载基础框架 F ->> M: 2. 加载子应用模块代码 M -->> U: 3 返回子应用 end webpack.config按照官方文档指导, 配置基础框架shared-module, 再将每个子应用抽离一个ModuleFederationPlugin, 并配置文件名和exposes即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344config.plugins = [ new ModuleFederationPlugin({ shared: Object.assign( _.mapValues(pkg.dependencies, () =&gt; ({ singleton: true, requiredVersion: false, })), { './src/other-file': { singleton: true, requiredVersion: false, }, }, ), remotes: { // xxx }, name: 'app_base', }), ..._.map( buildConfig.includesAppConfig, (config, app) =&gt; new ModuleFederationPlugin({ shared: Object.assign( _.mapValues(pkg.dependencies, () =&gt; ({ singleton: true, requiredVersion: false, })), { './src/other-file': { singleton: true, requiredVersion: false, }, }, ), name: `app_${app}`, filename: `remote-app-${app}.js`, exposes: { [`./index`]: `./src/containers/${app}/index.tsx`, }, }), ),]; 配置完成后, npm start就能直接输出对应app的remote.js文件了, 在代码中使用也非常简单: const App = React.lazy(() =&gt; import(&quot;app_xxx/index&quot;));, 同时可以在react-app-env.d.ts中添加相关模块的定义, 这样就可以避免ts模块编译报错 12345678910declare module 'app_*/index' { const Component: React.FunctionComponent&lt;any&gt;; export default Component;}// 下面动态加载组件需要使用declare global { const __webpack_init_sharing__: (type: string) =&gt; Promise&lt;any&gt;; const __webpack_share_scopes__: { default: (type: string) =&gt; Promise&lt;any&gt; };} 动态加载这样配置完后, 通过network就可以看到页面会自动加载remote_app.js了, 但是这里存在一个问题, 查看编译后生成的index.html可以发现, remote_app.js是通过&lt;script src=&quot;xxxxx.js&quot;&gt;加载的, 如果子系统太多, 一次性加载的脚本太多也会导致首屏时间变长, 所以需要解决这个问题 官方文档和demo也提供了解决方案: 使用动态注入script实现即可, 这里直接参考官方demo实现useDynamicScriptComponent, 同时额外加上全局缓存, 可以避免在react-router变化的时候导致重新加载React.lazy组件, 导致页面状态丢失 开发完动态加载后, 需要将ModuleFederationPlugin中的remotes参数去掉, 就不会在index.html中注入加载脚本了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import React, { useEffect, useState } from 'react';import debug from '../utils/debug';const cache: Record&lt;string, React.LazyExoticComponent&lt;React.ComponentType&lt;any&gt;&gt;&gt; = {};const loadComponent = (scope: string, module: string) =&gt; { if (!cache[scope]) { cache[scope] = React.lazy(async () =&gt; { // Initializes the share scope. This fills it with known provided modules from this build and all remotes await __webpack_init_sharing__('default'); const container = (window as any)[scope]; // or get the container somewhere else // Initialize the container, it may provide shared modules await container.init(__webpack_share_scopes__.default); const factory = await (window as any)[scope].get(module); const Module = factory(); return Module; }); } return cache[scope];};const useDynamicScriptComponent = ({ url, scope, module,}: { url: string; scope: string; module: string;}): React.LazyExoticComponent&lt;React.ComponentType&lt;any&gt;&gt; =&gt; { const [ready, setReady] = useState(() =&gt; !!cache[scope]); const [failed, setFailed] = useState(false); useEffect(() =&gt; { if (!url) { return; } if (cache[scope]) { setReady(true); setFailed(false); return; } const element = document.createElement('script'); element.src = url; element.type = 'text/javascript'; element.async = true; setReady(false); setFailed(false); element.onload = () =&gt; { debug.log(`Dynamic Script Loaded: ${url}`); setReady(true); }; element.onerror = () =&gt; { debug.error(`Dynamic Script Error: ${url}`); setReady(false); setFailed(true); }; document.head.appendChild(element); return () =&gt; { debug.log(`Dynamic Script Removed: ${url}`); document.head.removeChild(element); }; }, [url, scope]); if (!ready || failed) { return null; } return loadComponent(scope, module);};export default useDynamicScriptComponent; 模块配置管理实现完动态模块加载后, 就可以将模块路径实现动态注入了, 最开始考虑开发一个独立的服务端接口用于管理, 但后来发现可以直接使用k8s提供的ConfigMaps来实现动态管理模块 首先在public/config/module.js下定义好模块配置 1234567window.__appModule = { app_xxx: { url: host + 'app-modules/app-xxx/remote-app-xxx.js', scope: 'app_xxx', module: './index', },}; 然后在ConfigMaps中添加对public/config目录的覆盖, 将配置挂载到module.js中, 在需要使用的时候直接使用window.__appModule读取全局变量, 就可以实现热更新模块功能了 同时修改nginx配置, 将模块管理部分独立一个容器, 可以实现所有测试环境共用同一个模块管理后端, 也能减少模块管理的复杂度 1234567891011121314151617server { location ^~ /app-modules/ { proxy_buffering off; proxy_pass http://app-module-server; proxy_redirect default; } location ~ \\.html$ { add_header Cache-Control &quot;private, no-cache, no-store, must-revalidate&quot;; try_files $uri /index.html; } location ~ ^/config/module\\.js$ { add_header Cache-Control &quot;no-cache&quot;; try_files $uri =404; }} app-modules-nginx-server内就使用已有的服务端代码发布流程, 将打包后的代码发布到此容器内即可, 不同应用不同分支都有独立的文件夹, 可以通过外层configmaps随时切换需要的分支 子应用代理动态配置完成子应用的动态加载后, 如果需要切换子应用的nginx-proxy还是需要重启整个容器, 同样考虑动态配置实现, 最初考虑过使用nginxproxymanager, 但是维护起来比较复杂, 就决定直接使用ConfigMaps来实现了, 配置如下, 这里的conf.d/app-proxy/也是通过ConfigMaps来注入的文件 123server { include conf.d/app-proxy/*.conf;} 然后开发一个简单的文件监听重启nginx的服务, 可以充分利用nginx的配置检测和热更新功能, 保证了线上环境的正常运行 12345678910111213141516const fs = require('fs');const path = require('path');const child_process = require('child_process');fs.watch(path.resolve('/etc/nginx/conf.d/app-proxy'), async function (event, filename) { console.log(`event is: ${event}`); if (filename) { console.log(`filename provided: ${filename}`); } else { console.log(`filename not provided`); } child_process.spawn('/usr/sbin/nginx', ['-t'], { stdio: 'inherit' }); child_process.spawn('/usr/sbin/nginx', ['-s', 'reload'], { stdio: 'inherit' });});console.log(`nginx conf watching`); 小结完成以上内容后, 就成功的将Module Federation使用到项目中了. 对比之前的架构, 能实现基础框架动态更新子应用代理/代码模块, 子模块发布代码统一管理, 容器基本不用重启, 基本告别运维压力了. 而且webpack5带来的文件缓存也极大的提高了开发效率, 独立子应用打包速度也有了飞速提升. 页面架构最终的页面架构如下 sequenceDiagram participant Br as Browser participant BN as Base Nginx participant BA as Base App Code participant SS as Subapp Module Server participant SN as Subapp Module Nginx participant SC as Subapp Module Code alt 页面加载 Br ->> BN: 1. 访问系统 BN ->> BA: 2. 读取基础框架代码 BA -->> Br: 3.1 返回基础框架代码 BA -->> Br: 3.2 返回module.js Br ->> BN: 4. 访问子模块代码 BN ->> SN: 5. 访问子模块代码 SN ->> SC: 6. 读取本地子模块代码 SC -->> Br: 7. 返回子模块代码 Br ->> BN: 8. 发起子模块api请求 BN ->> SS: 9. 转发到子模块server SS -->> Br: 10. 返回请求结果 BN -->> BN: 监听configmaps触发nginx配置更新重启 BN -->> BN: 更新configmaps的module.js文件 SN -->> SN: 更新子模块代码 end 其他webpack5对比起webpack4确实基本能做到无痛升级, 但Module Federation里是对代码质量有些要求的, 这里记录一下遇到的一些问题和解决方案 codemirror/require代码中有个地方使用了codemirror, 然后在测试时发现, 如果切换子应用(不同的app_module), 后加载的子应用的codemirror没有样式. 研究后发现是因为codemirror代码中使用的require是相对路径, 在共享模块的时候不会生效, 需要修改为共享模块引用, 于是通过webpack-loader实现打包时动态替换解决了这个问题 1234567891011config.module.rules.unshift({ test: /\\.js$/, include: path.resolve('node_modules/codemirror'), enforce: 'pre', loader: 'pattern-replace-loader', options: { verbose: buildConfig.options.verbose, search: /&quot;\\.\\.\\/\\.\\.\\/lib\\/codemirror&quot;/g, replace: '&quot;codemirror&quot;', },}); d3.js打包失败在引用d3的时候, npm start不会有问题, 但是在build的时候会有如下报错 12Module not found: Error: Can't resolve '/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper' in '/node_modules/d3-array/src'Did you mean 'createForOfIteratorHelper.js'? 在webpack中添加resolve的处理即可 123456config.module.rules.unshift({ test: /\\.m?js/, resolve: { fullySpecified: false, },}); 循环引用在没有使用Module Federation的时候, 代码里的循环引用不会出问题, 因为webpack的模块加载可以解决循环引用, 但是Module Federation里的循环引用会导致remote.js出现报错, 于是只能加上&quot;import/no-cycle&quot;: &quot;error&quot;和&quot;plugin:import/recommended&quot;, &quot;plugin:import/typescript&quot;的EsLint插件检测循环引用, 然后调整相关问题代码","link":"/2021/10-13-react-app-webpack-5-module-federation/"}],"tags":[{"name":"others","slug":"others","link":"/tags/others/"},{"name":"programming","slug":"programming","link":"/tags/programming/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"react-native","slug":"react-native","link":"/tags/react-native/"},{"name":"egg","slug":"egg","link":"/tags/egg/"}],"categories":[{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Code","slug":"Code","link":"/categories/Code/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Programming","slug":"Code/Programming","link":"/categories/Code/Programming/"},{"name":"Extensions","slug":"Web/Extensions","link":"/categories/Web/Extensions/"},{"name":"Angularjs","slug":"Web/Angularjs","link":"/categories/Web/Angularjs/"},{"name":"Sql","slug":"Code/Sql","link":"/categories/Code/Sql/"},{"name":"CSS","slug":"Web/CSS","link":"/categories/Web/CSS/"},{"name":"Regex","slug":"Code/Regex","link":"/categories/Code/Regex/"},{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"ES6","slug":"Web/ES6","link":"/categories/Web/ES6/"},{"name":"React","slug":"Web/React","link":"/categories/Web/React/"},{"name":"TypeScript","slug":"Web/TypeScript","link":"/categories/Web/TypeScript/"},{"name":"Others","slug":"Code/Others","link":"/categories/Code/Others/"},{"name":"JavaScript","slug":"Web/JavaScript","link":"/categories/Web/JavaScript/"},{"name":"React Native","slug":"Web/React-Native","link":"/categories/Web/React-Native/"},{"name":"Egg","slug":"Server/Egg","link":"/categories/Server/Egg/"},{"name":"Docker","slug":"Server/Docker","link":"/categories/Server/Docker/"},{"name":"Next","slug":"Web/Next","link":"/categories/Web/Next/"},{"name":"Others","slug":"Server/Others","link":"/categories/Server/Others/"},{"name":"File System","slug":"Server/File-System","link":"/categories/Server/File-System/"}]}