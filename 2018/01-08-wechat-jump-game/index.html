<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>微信跳一跳自动辅助 - Mosby</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#000000"><meta name="application-name" content="Mosby Zhou Blog"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="msapplication-TileColor" content="#000000"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Mosby Zhou Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="256x256" href="/img/favicon.png"><meta name="description" content="微信跳一跳分析和辅助制作, 以及原理"><meta property="og:type" content="blog"><meta property="og:title" content="Mosby Zhou Blog"><meta property="og:url" content="https://mosby-zhou.github.io/2018/01-08-wechat-jump-game/"><meta property="og:site_name" content="Mosby"><meta property="og:description" content="微信跳一跳分析和辅助制作, 以及原理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mosby-zhou.github.io/images/wx-jump-game/program-run.jpg"><meta property="og:image" content="https://mosby-zhou.github.io/images/wx-jump-game/program-log.jpg"><meta property="og:image" content="https://mosby-zhou.github.io/images/wx-jump-game/screenshot-20180109-121451-analysed.png"><meta property="og:image" content="https://mosby-zhou.github.io/images/wx-jump-game/screenshot-20180109-121459-analysed.png"><meta property="og:image" content="https://mosby-zhou.github.io/images/wx-jump-game/screenshot-20180109-121507-analysed.png"><meta property="article:published_time" content="2018-01-06T07:19:11.000Z"><meta property="article:modified_time" content="2018-01-11T02:05:30.000Z"><meta property="article:author" content="Mosby"><meta property="article:tag" content="others"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/wx-jump-game/program-run.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mosby-zhou.github.io/2018/01-08-wechat-jump-game/"},"headline":"微信跳一跳自动辅助","image":["https://mosby-zhou.github.io/images/wx-jump-game/program-run.jpg","https://mosby-zhou.github.io/images/wx-jump-game/program-log.jpg","https://mosby-zhou.github.io/images/wx-jump-game/screenshot-20180109-121451-analysed.png","https://mosby-zhou.github.io/images/wx-jump-game/screenshot-20180109-121459-analysed.png","https://mosby-zhou.github.io/images/wx-jump-game/screenshot-20180109-121507-analysed.png"],"datePublished":"2018-01-06T07:19:11.000Z","dateModified":"2018-01-11T02:05:30.000Z","author":{"@type":"Person","name":"Mosby"},"publisher":{"@type":"Organization","name":"Mosby","logo":{"@type":"ImageObject","url":"https://mosby-zhou.github.io/img/logo.png"}},"description":"微信跳一跳分析和辅助制作, 以及原理"}</script><link rel="canonical" href="https://mosby-zhou.github.io/2018/01-08-wechat-jump-game/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai-sublime.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Mosby" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/mosby-zhou"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-01-06T07:19:11.000Z" title="1/6/2018, 7:19:11 AM">2018-01-06</time>发表</span><span class="level-item"><time dateTime="2018-01-11T02:05:30.000Z" title="1/11/2018, 2:05:30 AM">2018-01-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Code/">Code</a><span> / </span><a class="link-muted" href="/categories/Code/Others/">Others</a></span><span class="level-item">34 分钟读完 (大约5072个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">微信跳一跳自动辅助</h1><div class="content"><p>最近微信跳一跳在元旦一周火了起来, 刚玩的时候能艰难的跳到<code>120+</code>分, 看了网上的站立加分能跳到<code>280+</code>. 使用<code>GGuardian</code>让每次踩中心能加<code>32</code>分能跳到接近<code>1000</code>, 然而每次重开太累了, 于是抽晚上和周末写了个自动跳. 目前最高分有<code>4000+</code>, 不过是因为要玩手机而手动停止, 并不是算法问题. 想直接使用的看<a target="_blank" rel="noopener" href="https://github.com/mosby-zhou/wechat-jump-game-resolve">这里</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>手机截图发送到电脑</li>
<li>电脑读取图片像素, 分析图片, 得到跳跃距离</li>
<li>根据跳跃距离和计算函数得出按压时间</li>
<li>发送按压时间到手机长按 -&gt; 跳!</li>
<li>再次截图, 并循环</li>
</ol>
<h3 id="手机截图"><a href="#手机截图" class="headerlink" title="手机截图"></a>手机截图</h3><p>还好使用的是<code>android</code>, 可以直接使用<code>adb shell</code>进行截图, 并发送到电脑. 百度一下可以得到以下几个命令.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//调用截图, 并将截图保存到/sdcard/screenshot.png</span><br><span class="line">adb shell /system/bin/screencap -p /sdcard/screenshot.png</span><br><span class="line">//将截图从手机复制到电脑目录</span><br><span class="line">adb pull /sdcard/screenshot.png d:/screenshot.png</span><br></pre></td></tr></table></figure>

<p>然后再带一个删除图片的<code>linux</code>命令, 免得截图太多浪费内存空间.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell rm /sdcard/screenshot.png</span><br></pre></td></tr></table></figure>

<h3 id="按压命令"><a href="#按压命令" class="headerlink" title="按压命令"></a>按压命令</h3><p>顺便查了一下发送输入事件到手机的命令, 也挺简单的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//点击x,y坐标</span><br><span class="line">adb shell input tap x y</span><br><span class="line">//使用n毫秒从(x1,y1)滑动到(x2,y2), 模拟长按事件</span><br><span class="line">adb shell input swipe 500 500 501 501 2000</span><br></pre></td></tr></table></figure>

<p>测试了一下, 发现一般距离按个<code>300ms</code>-<code>400ms</code>, 基本都能跳到. 算测试成功, 进行下一步.</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="帮助类库"><a href="#帮助类库" class="headerlink" title="帮助类库"></a>帮助类库</h3><p>首先还是使用<code>.Net</code> + <code>C#</code>, 毕竟<code>window</code>平台下最好用的语言. 图片的读取和写入还是使用之前读取支付宝 AR 红包时候用的<code>Byte[]</code>和<code>System.Runtime.InteropServices.Marshal</code>, 性能远远优于<code>.Net</code>自带的图片像素颜色读取写入. 方法也类似之前的方法, 只是数组改成二维数组了, 方便一些, 由于有半透明图片的读取, 所以还添加了一个读取<code>RGBA</code>值的方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">public static void GetRGB(this Bitmap image, int startX, int startY, int w, int h, int[][] rgbArray)</span><br><span class="line">&#123;</span><br><span class="line">    const int PixelWidth = 3;</span><br><span class="line">    const PixelFormat PixelFormat = PixelFormat.Format24bppRgb;</span><br><span class="line"></span><br><span class="line">    // En garde!</span><br><span class="line">    if (image == null) throw new ArgumentNullException(&quot;image&quot;);</span><br><span class="line">    if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;);</span><br><span class="line">    if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;);</span><br><span class="line">    if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;);</span><br><span class="line">    if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;);</span><br><span class="line">    if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.ReadOnly, PixelFormat);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] pixelData = new Byte[data.Stride];</span><br><span class="line">        for (int i = 0; i &lt; h; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rgbArray[i] = new int[w];</span><br><span class="line">            Marshal.Copy(data.Scan0 + (i * data.Stride), pixelData, 0, data.Stride);</span><br><span class="line">            for (int j = 0; j &lt; w; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                // PixelFormat.Format32bppRgb means the data is stored</span><br><span class="line">                // in memory as BGR. We want RGB, so we must do some</span><br><span class="line">                // bit-shuffling.</span><br><span class="line">                rgbArray[i][j] =</span><br><span class="line">                    (pixelData[j * PixelWidth + 2] &lt;&lt; 16) +   // R</span><br><span class="line">                    (pixelData[j * PixelWidth + 1] &lt;&lt; 8) +    // G</span><br><span class="line">                    pixelData[j * PixelWidth];                // B</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        image.UnlockBits(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void GetRGBA(this Bitmap image, int startX, int startY, int w, int h, long[][] rgbArray)</span><br><span class="line">&#123;</span><br><span class="line">    const int PixelWidth = 4;</span><br><span class="line">    const PixelFormat PixelFormat = PixelFormat.Format32bppArgb;</span><br><span class="line"></span><br><span class="line">    // En garde!</span><br><span class="line">    if (image == null) throw new ArgumentNullException(&quot;image&quot;);</span><br><span class="line">    if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;);</span><br><span class="line">    if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;);</span><br><span class="line">    if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;);</span><br><span class="line">    if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;);</span><br><span class="line">    if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.ReadOnly, PixelFormat);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] pixelData = new Byte[data.Stride];</span><br><span class="line">        for (int i = 0; i &lt; h; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rgbArray[i] = new long[w];</span><br><span class="line">            Marshal.Copy(data.Scan0 + (i * data.Stride), pixelData, 0, data.Stride);</span><br><span class="line">            for (int j = 0; j &lt; w; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                // PixelFormat.Format32bppARgb means the data is stored</span><br><span class="line">                // in memory as BGRA. We want ARGB, so we must do some</span><br><span class="line">                // bit-shuffling.</span><br><span class="line">                rgbArray[i][j] =</span><br><span class="line">                    (((long)pixelData[j * PixelWidth + 3]) &lt;&lt; 24) +   // A</span><br><span class="line">                    (pixelData[j * PixelWidth + 2] &lt;&lt; 16) +   // R</span><br><span class="line">                    (pixelData[j * PixelWidth + 1] &lt;&lt; 8) +    // G</span><br><span class="line">                    pixelData[j * PixelWidth];                // B</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        image.UnlockBits(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void SetRGB(this Bitmap image, int startX, int startY, int w, int h, int[][] rgbArray)</span><br><span class="line">&#123;</span><br><span class="line">    const int PixelWidth = 3;</span><br><span class="line">    const PixelFormat PixelFormat = PixelFormat.Format24bppRgb;</span><br><span class="line"></span><br><span class="line">    // En garde!</span><br><span class="line">    if (image == null) throw new ArgumentNullException(&quot;image&quot;);</span><br><span class="line">    if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;);</span><br><span class="line">    if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;);</span><br><span class="line">    if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;);</span><br><span class="line">    if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;);</span><br><span class="line">    if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.WriteOnly, PixelFormat);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        int dst_bytes = data.Stride * h;</span><br><span class="line">        byte[] dstValues = new byte[dst_bytes];</span><br><span class="line">        IntPtr dstPtr = data.Scan0;</span><br><span class="line">        Marshal.Copy(dstPtr, dstValues, 0, dst_bytes);</span><br><span class="line">        int position = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; h; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; w; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                position = (i * data.Stride) + j * PixelWidth;</span><br><span class="line">                dstValues[position + 0] = (byte)(rgbArray[i][j]);</span><br><span class="line">                dstValues[position + 1] = (byte)(rgbArray[i][j] &gt;&gt; 8);</span><br><span class="line">                dstValues[position + 2] = (byte)(rgbArray[i][j] &gt;&gt; 16);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Marshal.Copy(dstValues, 0, dstPtr, dst_bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    finally</span><br><span class="line">    &#123;</span><br><span class="line">        image.UnlockBits(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始的想法是, 从左上往右下扫描图片, 当碰到顶点的时候, 就能确定该顶点是目标物体, 然后根据顶点颜色找到整个目标面, 计算下平均坐标, 即可得到目标点.<br>而自己的坐标确认方法, 看了一下好像自己的颜色不会变化, 那么就去<code>PS</code>里面, 把自己的棋子单独截出来, 当作<code>Res</code>资源图片, 在扫描时候碰见自己棋子颜色的时候, 就去和资源图片比对, 如果相关像素点颜色都一样, 那么就可以确定该点为自己的棋子, 再根据起点坐标和资源图片计算偏移, 即可得到自己的准确坐标.</p>
<p>那么就开始干活. 首先定义一个结构<code>struct</code>记录点的颜色, 为什么不是<code>class</code>而是<code>struct</code>呢, 因为性能好一些, 而且不会有引用值类型传错的可能. <code>.Net</code>还有个好处就是和<code>C</code>一样, 能重载<code>+</code>, ‘-‘, ‘*‘, ‘/‘, ‘==’这种运算符, 这样算法写起来也简单.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">public struct RGB</span><br><span class="line">&#123;</span><br><span class="line">    public static char[] RGBNAME = new char[] &#123; &#x27;A&#x27;, &#x27;R&#x27;, &#x27;G&#x27;, &#x27;B&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">    public RGB(long color, bool hasAlpha = false)</span><br><span class="line">    &#123;</span><br><span class="line">        //this.R = color &gt;&gt; 16;</span><br><span class="line">        //this.G = (color &amp; 65280) &gt;&gt; 8;</span><br><span class="line">        //this.B = (color &amp; 255);</span><br><span class="line">        this.A = hasAlpha ? (byte)(color &gt;&gt; 24) : 255;</span><br><span class="line">        this.R = (byte)(color &gt;&gt; 16);</span><br><span class="line">        this.G = (byte)(color &gt;&gt; 8);</span><br><span class="line">        this.B = (byte)(color);</span><br><span class="line">    &#125;</span><br><span class="line">    public static RGB FromInt(long color, bool hasAlpha = false)</span><br><span class="line">    &#123;</span><br><span class="line">        return new RGB(color, hasAlpha);</span><br><span class="line">    &#125;</span><br><span class="line">    public int ToInt()</span><br><span class="line">    &#123;</span><br><span class="line">        return (this.R &lt;&lt; 16) + (this.G &lt;&lt; 8) + this.B;</span><br><span class="line">    &#125;</span><br><span class="line">    public long ToLong(bool hasAlpha = false)</span><br><span class="line">    &#123;</span><br><span class="line">        return (hasAlpha ? ((long)this.A) &lt;&lt; 24 : 0) + (this.R &lt;&lt; 16) + (this.G &lt;&lt; 8) + this.B;</span><br><span class="line">    &#125;</span><br><span class="line">    public RGB(int r, int g, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        this.R = r;</span><br><span class="line">        this.G = g;</span><br><span class="line">        this.B = b;</span><br><span class="line">        this.A = 255;</span><br><span class="line">    &#125;</span><br><span class="line">    public RGB(int r, int g, int b, int a)</span><br><span class="line">    &#123;</span><br><span class="line">        this.R = r;</span><br><span class="line">        this.G = g;</span><br><span class="line">        this.B = b;</span><br><span class="line">        this.A = a;</span><br><span class="line">    &#125;</span><br><span class="line">    public int Get(char key)</span><br><span class="line">    &#123;</span><br><span class="line">        if (key &gt; 90)</span><br><span class="line">        &#123;</span><br><span class="line">            key = (char)(key - 32);</span><br><span class="line">        &#125;</span><br><span class="line">        switch (key)</span><br><span class="line">        &#123;</span><br><span class="line">            case &#x27;A&#x27;: return this.A;</span><br><span class="line">            case &#x27;R&#x27;: return this.R;</span><br><span class="line">            case &#x27;G&#x27;: return this.G;</span><br><span class="line">            case &#x27;B&#x27;: return this.B;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new ArgumentOutOfRangeException(&quot;字符不对&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static RGB operator +(RGB color1, RGB color2)</span><br><span class="line">    &#123;</span><br><span class="line">        return new RGB(</span><br><span class="line">        color1.R + color2.R,</span><br><span class="line">        color1.G + color2.G,</span><br><span class="line">        color1.B + color2.B</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    public static RGB operator -(RGB color1, RGB color2)</span><br><span class="line">    &#123;</span><br><span class="line">        return new RGB(</span><br><span class="line">        color1.R - color2.R,</span><br><span class="line">        color1.G - color2.G,</span><br><span class="line">        color1.B - color2.B</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    public static RGB operator *(RGB color, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        return new RGB(</span><br><span class="line">        color.R * m,</span><br><span class="line">        color.G * m,</span><br><span class="line">        color.B * m</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    public static RGB operator /(RGB color, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        return new RGB(</span><br><span class="line">        color.R / m,</span><br><span class="line">        color.G / m,</span><br><span class="line">        color.B / m</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    public static RGB operator ~(RGB color)</span><br><span class="line">    &#123;</span><br><span class="line">        return new RGB(</span><br><span class="line">        255 - color.R,</span><br><span class="line">        255 - color.G,</span><br><span class="line">        255 - color.B</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    public static bool operator ==(RGB color1, RGB color2)</span><br><span class="line">    &#123;</span><br><span class="line">        return color1.A == color2.A &amp;&amp; color1.R == color2.R &amp;&amp; color1.G == color2.G &amp;&amp; color1.B == color2.B;</span><br><span class="line">    &#125;</span><br><span class="line">    public static bool operator !=(RGB color1, RGB color2)</span><br><span class="line">    &#123;</span><br><span class="line">        return !(color1 == color2);</span><br><span class="line">    &#125;</span><br><span class="line">    public int R;</span><br><span class="line">    public int G;</span><br><span class="line">    public int B;</span><br><span class="line">    public int A;</span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return string.Format(&quot;R:&#123;0&#125;,G:&#123;1&#125;,B:&#123;2&#125;,A:&#123;3&#125;&quot;, this.R, this.G, this.B, this.A);</span><br><span class="line">    &#125;</span><br><span class="line">    public override bool Equals(object obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj != null &amp;&amp; obj is RGB)</span><br><span class="line">        &#123;</span><br><span class="line">            return this == (RGB)obj;</span><br><span class="line">        &#125;</span><br><span class="line">        return base.Equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    public override int GetHashCode()</span><br><span class="line">    &#123;</span><br><span class="line">        return this.ToLong(true).GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有这个<code>struct</code>来帮助将颜色和<code>bitmap</code>里面存的<code>int</code>进行互相转换和计算以后, 就可以开始正式做图片识别相关的了, 目前还是使用的传统算法实现图片识别, 而不是网上比较多的人工智能<code>Tensorflow</code> + 训练集来识别图片. 两种算法各有优劣, 传统算法优势是意义明确, 可以清楚的知道代码是如何识别图片和如果失败哪里出现了问题, 人工智能识别的好处就是不用费心想算法…而且以后万一图片改了, 直接换个训练集一样能上能识别.</p>
<h2 id="分析主函数"><a href="#分析主函数" class="headerlink" title="分析主函数"></a>分析主函数</h2><p>先定义分析主函数<code>double AnalyseSpace()</code>, 主要流程是从图片中读取颜色信息, 然后分析图片, 计算出目标点坐标和自己点坐标, 根据位置求两点距离.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var bitmap = (Bitmap)Image.FromFile(ImgBoxResolved.ImageLocation);</span><br><span class="line">if (bitmap.Width != 1080 || bitmap.Height != 1920)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(&quot;图片错误&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">var imgRGBArray = new int[1920][];</span><br><span class="line">bitmap.GetRGB(0, 0, 1080, 1920, imgRGBArray);</span><br><span class="line"></span><br><span class="line">var chessPoint = GetMySelfChessPosition(imgRGBArray);</span><br><span class="line">var targetPoint = FindTargetPoint(imgRGBArray);</span><br><span class="line"></span><br><span class="line">return calcSpace(chessPoint, targetPoint);</span><br></pre></td></tr></table></figure>

<h3 id="计算目标点坐标"><a href="#计算目标点坐标" class="headerlink" title="计算目标点坐标"></a>计算目标点坐标</h3><p>如何计算目标点坐标是个比较困难的问题, 最开始想的是扫描图片, 取最上方的节点颜色, 然后从该点开始取周围所有相同颜色的坐标, 最后求平均值就能得到中心点即目标点坐标了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">private Point FindTargetPoint(int[][] imgRGBArray)</span><br><span class="line">&#123;</span><br><span class="line">    //从500开始逐行扫描</span><br><span class="line">    RGB tempRGB;</span><br><span class="line">    RGB tempBoxColorRGB = new RGB();</span><br><span class="line">    Point startPoint = new Point(0, 0);</span><br><span class="line">    Point endPoint = new Point(0, 0);</span><br><span class="line">    Point rightPoint = new Point(0, 0);</span><br><span class="line">    int rightHeight = 0;</span><br><span class="line">    int maybeHeight = 0;</span><br><span class="line">    var isFindStart = false;</span><br><span class="line">    var isInBox = true;</span><br><span class="line">    var isFindRight = false;</span><br><span class="line">    var findCount = 400;</span><br><span class="line"></span><br><span class="line">    var currentRowMaxJ = 0;</span><br><span class="line"></span><br><span class="line">    for (var i = 500; i &lt; imgRGBArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        currentRowMaxJ = 0;</span><br><span class="line">        for (var j = 0; j &lt; imgRGBArray[i].Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempRGB = RGB.FromInt(imgRGBArray[i][j]);</span><br><span class="line">            if (!isFindStart)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!IsBgColor(tempRGB))</span><br><span class="line">                &#123;</span><br><span class="line">                    isFindStart = true;</span><br><span class="line">                    startPoint.Y = i;</span><br><span class="line">                    startPoint.X = j;</span><br><span class="line">                    endPoint.X = j;</span><br><span class="line">                    rightPoint.X = j;</span><br><span class="line">                    tempBoxColorRGB = tempRGB;</span><br><span class="line">                    imgRGBArray[i][j] = (~tempRGB).ToInt();</span><br><span class="line">                    currentRowMaxJ = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (findCount &gt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (RGB.FromInt(imgRGBArray[i][j]) == tempBoxColorRGB)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentRowMaxJ = j;</span><br><span class="line"></span><br><span class="line">                    if (!isFindRight)</span><br><span class="line">                    &#123;</span><br><span class="line">                        imgRGBArray[i][j] = (~tempBoxColorRGB).ToInt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (isFindRight &amp;&amp; (i - startPoint.Y) &lt; (2 * maybeHeight + 20))</span><br><span class="line">                    &#123;</span><br><span class="line">                        imgRGBArray[i][j] = (~tempBoxColorRGB).ToInt();</span><br><span class="line">                        endPoint.Y = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (isFindRight &amp;&amp; (i - startPoint.Y) &gt;= (2 * maybeHeight + 20))</span><br><span class="line">                    &#123;</span><br><span class="line">                        isInBox = false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isFindStart)</span><br><span class="line">        &#123;</span><br><span class="line">            findCount--;</span><br><span class="line"></span><br><span class="line">            //该行循环完成</span><br><span class="line">            if (rightPoint.X &lt; currentRowMaxJ)</span><br><span class="line">            &#123;</span><br><span class="line">                rightPoint.X = currentRowMaxJ;</span><br><span class="line">                rightPoint.Y = i;</span><br><span class="line">                rightHeight = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rightPoint.X == currentRowMaxJ)</span><br><span class="line">            &#123;</span><br><span class="line">                rightHeight++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rightPoint.X &gt; currentRowMaxJ)</span><br><span class="line">            &#123;</span><br><span class="line">                isFindRight = true;</span><br><span class="line">                maybeHeight = rightPoint.Y - startPoint.Y + rightHeight / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (findCount &lt; 0 || !isInBox)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new Point((startPoint.X + endPoint.X) / 2, (startPoint.Y + endPoint.Y) / 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做了以后, 发现的问题是… 跳到后面一点以后, 有颜色完全不同的方块出来了… 忘记了这一点, 如果改成全用非背景识别区域, 那么后期也会存在一个问题, 距离特别近的时候, 棋子会覆盖住这片空白空间, 用非背景色判断也会存在问题. 那么就只能换种思路了.</p>
<p>再从头分析一下, 跳一步以后, 下一个方块从上方落下, 随机一个点, 但是一定是最上方, 那么换一种计算方式, 先找到目标物的顶点, 而光照是从右边往左边的, 那么下一步去找目标物的右端点, 如果右端点被棋子挡住了, 说明棋子在右边, 然后去寻找左端点, 就不会出现左端点被阴影挡住了的情况.</p>
<p>那么接下来的分析函数就简单了, 分成几个小函数实现.</p>
<h3 id="寻找顶点坐标"><a href="#寻找顶点坐标" class="headerlink" title="寻找顶点坐标"></a>寻找顶点坐标</h3><p>这里有个要注意的情况, 即棋子最高点有可能是比顶点还高的, 需要处理下这种情况, 所以需要先找到棋子位置再传入.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 寻找顶点的方法</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">private Point FindTopPoint(int[][] imgRGBArray, Point chessPoint)</span><br><span class="line">&#123;</span><br><span class="line">    RGB tempRGB;</span><br><span class="line"></span><br><span class="line">    Point topPoint = new Point(0, 0);</span><br><span class="line">    var hasFindTopPoint = false;</span><br><span class="line"></span><br><span class="line">    var isFirstFindIsNotBg = 0;</span><br><span class="line"></span><br><span class="line">    for (var i = 500; i &lt; imgRGBArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var j = 0; j &lt; imgRGBArray[i].Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            isFirstFindIsNotBg++;</span><br><span class="line">            if (!hasFindTopPoint)</span><br><span class="line">            &#123;</span><br><span class="line">                tempRGB = RGB.FromInt(imgRGBArray[i][j]);</span><br><span class="line">                //if (!IsBgColor(tempRGB) &amp;&amp; !tempRGB.TotalLike(SelfCheesColor, 30))</span><br><span class="line">                if (!IsBgColor(tempRGB))</span><br><span class="line">                &#123;</span><br><span class="line">                    if (isFirstFindIsNotBg == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        MessageBox.Show(string.Format(&quot;第一个点就不是BG,出错,BG颜色:&#123;0&#125;,当前点颜色:&#123;1&#125;&quot;, BgColorAverage, tempRGB));</span><br><span class="line">                        return ErrorPoint;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //如果当前点在自己点的空间中</span><br><span class="line">                    if ((j &gt; chessPoint.X - 32) &amp;&amp; (j &lt; chessPoint.X + 50)</span><br><span class="line">                        &amp;&amp; (i &gt; chessPoint.Y - 2) &amp;&amp; (i &lt; chessPoint.Y + 200))</span><br><span class="line">                    &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        hasFindTopPoint = true;</span><br><span class="line">                        topPoint.Y = i;</span><br><span class="line">                        topPoint.X = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasFindTopPoint)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!hasFindTopPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;未找到合适的顶点&quot;);</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    return topPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找右端点坐标"><a href="#寻找右端点坐标" class="headerlink" title="寻找右端点坐标"></a>寻找右端点坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 先寻找右端点, 如果未找到或者右端点在自己棋子区间, 返回ErrorPoint</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">private Point FindRightPoint(int[][] imgRGBArray, Point chessPoint, Point topPoint)</span><br><span class="line">&#123;</span><br><span class="line">    RGB tempRGB;</span><br><span class="line"></span><br><span class="line">    var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]);</span><br><span class="line"></span><br><span class="line">    //从顶点开始往右边找</span><br><span class="line">    //最高高度设置为200</span><br><span class="line">    var maxHeight = 200;</span><br><span class="line">    var maxWidth = 300;</span><br><span class="line">    Point rightPoint = new Point(0, 0);</span><br><span class="line">    var hasFindRightPoint = false;</span><br><span class="line"></span><br><span class="line">    for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        var thisRowIsAllBG = true;</span><br><span class="line">        var currentRowHasBgInMiddle = false;</span><br><span class="line">        for (var j = topPoint.X; j &lt; topPoint.X + maxWidth &amp;&amp; j &lt; imgRGBArray[i].Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!hasFindRightPoint)</span><br><span class="line">            &#123;</span><br><span class="line">                tempRGB = RGB.FromInt(imgRGBArray[i][j]);</span><br><span class="line"></span><br><span class="line">                //如果当前点是背景颜色, 跳过该行</span><br><span class="line">                if (!thisRowIsAllBG &amp;&amp; tempRGB.Like(currentBGColor, 10))</span><br><span class="line">                &#123;</span><br><span class="line">                    currentRowHasBgInMiddle = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!IsBgColor(tempRGB))</span><br><span class="line">                &#123;</span><br><span class="line">                    thisRowIsAllBG = false;</span><br><span class="line">                    //如果当前点不是背景,而下一个点是背景</span><br><span class="line">                    if (!currentRowHasBgInMiddle &amp;&amp; IsBgColor(RGB.FromInt(imgRGBArray[i][j + 1])))</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (rightPoint.X &lt; j)//如果已经有的rightPoint在当前点左边</span><br><span class="line">                        &#123;</span><br><span class="line">                            rightPoint.Y = i;</span><br><span class="line">                            rightPoint.X = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (rightPoint.X == j)</span><br><span class="line">                        &#123;</span><br><span class="line">                            //如果已有的rightPoint和当前点的X坐标相同,</span><br><span class="line">                            //那么需要接下来的几个点都不是背景,才能确定是最终点</span><br><span class="line">                            var isFinal = true;</span><br><span class="line">                            for (int m = 1; m &lt; 3; m++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                if (!IsBgColor(RGB.FromInt(imgRGBArray[i + m][j + 1])))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    isFinal = false;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (isFinal)</span><br><span class="line">                            &#123;</span><br><span class="line">                                hasFindRightPoint = true;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (rightPoint.X &gt; j)</span><br><span class="line">                        &#123;</span><br><span class="line">                            hasFindRightPoint = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasFindRightPoint)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!hasFindRightPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">        //MessageBox.Show(&quot;未找到合适的右端点, 去寻找左端点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return rightPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找左端点坐标"><a href="#寻找左端点坐标" class="headerlink" title="寻找左端点坐标"></a>寻找左端点坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 如果右端点不存在或者出错的情况下, 开始寻找左端点</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">private Point FindLeftPoint(int[][] imgRGBArray, Point chessPoint, Point topPoint)</span><br><span class="line">&#123;</span><br><span class="line">    var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]);</span><br><span class="line">    var topPointColor = RGB.FromInt(imgRGBArray[topPoint.Y][topPoint.X]);</span><br><span class="line"></span><br><span class="line">    //从顶点开始往右边找</span><br><span class="line">    //最高高度设置为200</span><br><span class="line">    var maxHeight = 200;</span><br><span class="line"></span><br><span class="line">    var hasFindLeftPoint = false;</span><br><span class="line">    var leftPoint = new Point(0, 0);</span><br><span class="line">    //寻找左边端点</span><br><span class="line">    for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var j = 100; j &lt; topPoint.X; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!hasFindLeftPoint)</span><br><span class="line">            &#123;</span><br><span class="line">                //如果当前点不是背景色</span><br><span class="line">                if (!RGB.FromInt(imgRGBArray[i][j]).Like(currentBGColor, 10))</span><br><span class="line">                &#123;</span><br><span class="line">                    //如果以下8个点都不是背景,</span><br><span class="line">                    //而且前一位的8个点都是背景</span><br><span class="line">                    //那么就是左端点</span><br><span class="line">                    var isFinal = true;</span><br><span class="line">                    for (var m = 1; m &lt;= 8; m++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (!RGB.FromInt(imgRGBArray[i + m][j - 1]).Like(currentBGColor, 10)</span><br><span class="line">                            || RGB.FromInt(imgRGBArray[i + m][j]).Like(currentBGColor, 10))</span><br><span class="line">                        &#123;</span><br><span class="line">                            isFinal = false;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (isFinal)</span><br><span class="line">                    &#123;</span><br><span class="line">                        leftPoint.Y = i;</span><br><span class="line">                        leftPoint.X = j;</span><br><span class="line">                        hasFindLeftPoint = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasFindLeftPoint)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!hasFindLeftPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    return leftPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找自己棋子坐标"><a href="#寻找自己棋子坐标" class="headerlink" title="寻找自己棋子坐标"></a>寻找自己棋子坐标</h3><p>这个坐标寻找方式就和之前的找目标点完全不同了, 因为棋子是不会变化的, 那么从<code>PS</code>中截出棋子的图片, 然后当作<code>res</code>把图片信息加载进来, 再整个图片查找一下对应点和像素, 就能找到自己的点了. 需要注意的是, 为了防止色差, 对自己棋子的点的颜色比较设定了一个容差<code>5</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#region 棋子位置和颜色函数</span><br><span class="line"></span><br><span class="line">private RGB[][] imgMySelfChessRGBColorArray;</span><br><span class="line">private RGB[][] mySelfChessStart3x3Point;</span><br><span class="line">private void InitMyImgARGBArray()</span><br><span class="line">&#123;</span><br><span class="line">    var bitmap = (Bitmap)Image.FromFile(PublicPath + @&quot;/Res/WX-MY.png&quot;);</span><br><span class="line">    if (bitmap.Width != 80 || bitmap.Height != 220)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(&quot;资源图片错误&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    var imgMySelfRGBArray = new long[220][];</span><br><span class="line"></span><br><span class="line">    Point StartPoint = new Point(-1, -1);</span><br><span class="line"></span><br><span class="line">    imgMySelfChessRGBColorArray = new RGB[imgMySelfRGBArray.Length][];</span><br><span class="line">    bitmap.GetRGBA(0, 0, 80, 220, imgMySelfRGBArray);</span><br><span class="line">    for (var i = 0; i &lt; imgMySelfRGBArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        imgMySelfChessRGBColorArray[i] = new RGB[imgMySelfRGBArray[i].Length];</span><br><span class="line">        for (var j = 0; j &lt; imgMySelfRGBArray[i].Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            var tempRGB = RGB.FromInt(imgMySelfRGBArray[i][j], true);</span><br><span class="line">            imgMySelfChessRGBColorArray[i][j] = tempRGB;</span><br><span class="line">            if (tempRGB.A == 255 &amp;&amp; StartPoint.X == -1)</span><br><span class="line">            &#123;</span><br><span class="line">                StartPoint.Y = i;</span><br><span class="line">                StartPoint.X = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mySelfChessStart3x3Point = new RGB[3][];</span><br><span class="line">    for (var i = 0; i &lt; mySelfChessStart3x3Point.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mySelfChessStart3x3Point[i] = new RGB[3];</span><br><span class="line">        for (var j = 0; j &lt; mySelfChessStart3x3Point[i].Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            mySelfChessStart3x3Point[i][j] = imgMySelfChessRGBColorArray[StartPoint.Y + i][StartPoint.X + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private Point GetMySelfChessPosition(int[][] imgRGBArray)</span><br><span class="line">&#123;</span><br><span class="line">    int temp_i = 0;</span><br><span class="line">    int temp_j = 0;</span><br><span class="line"></span><br><span class="line">    RGB tempRGB = new RGB();</span><br><span class="line">    var isFindStart = false;</span><br><span class="line">    var findCount = 50;</span><br><span class="line"></span><br><span class="line">    for (var i = 500; i &lt; 1500; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var j = 100; j &lt; 1000; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempRGB = RGB.FromInt(imgRGBArray[i][j]);</span><br><span class="line">            if (!isFindStart)</span><br><span class="line">            &#123;</span><br><span class="line">                if (IsMySelfChess(imgRGBArray, i, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    isFindStart = true;</span><br><span class="line">                    temp_i = i;</span><br><span class="line">                    temp_j = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isFindStart)</span><br><span class="line">        &#123;</span><br><span class="line">            findCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (findCount &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new Point(temp_j, temp_i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private bool IsMySelfChess(int[][] imgRGBArray, int _i, int _j)</span><br><span class="line">&#123;</span><br><span class="line">    for (var i = 0; i &lt; mySelfChessStart3x3Point.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var j = 0; j &lt; mySelfChessStart3x3Point[i].Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!mySelfChessStart3x3Point[i][j].Like(RGB.FromInt(imgRGBArray[_i + i][_j + j]), 5))</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>

<h3 id="计算距离"><a href="#计算距离" class="headerlink" title="计算距离"></a>计算距离</h3><p>最开始直接使用的两点距离计算公式, 后来发现可能需要只计算轴向距离的间隔. 但是最终测试以后, 发现直接计算距离好像也可以.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//计算轴向距离</span><br><span class="line">var l = Math.Sqrt(Math.Pow(targetPoint.X - cheesCenterPoint.X, 2) + Math.Pow(targetPoint.Y - cheesCenterPoint.Y, 2));</span><br><span class="line">var angle = Math.Atan2(Math.Abs(targetPoint.Y - cheesCenterPoint.Y), Math.Abs(targetPoint.X - cheesCenterPoint.X)) * 180 / Math.PI;</span><br><span class="line">var space = l * Math.Cos((angle - 30) * Math.PI / 180);</span><br><span class="line"></span><br><span class="line">//计算点距离</span><br><span class="line">var space = Math.Sqrt(Math.Pow(targetPoint.X - cheesCenterPoint.X, 2) + Math.Pow(targetPoint.Y - cheesCenterPoint.Y, 2));</span><br></pre></td></tr></table></figure>

<h3 id="计算跳跃时间"><a href="#计算跳跃时间" class="headerlink" title="计算跳跃时间"></a>计算跳跃时间</h3><p>这个值…纯粹靠猜和试, 毕竟分辨率不同, 测出来的像素距离也会不同…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 根据距离计算按压时间</span><br><span class="line">/// * 可能距离超过一定长度的时候需要减少按压时间</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;space&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public int GetPressTimeBySpace(double space)</span><br><span class="line">&#123;</span><br><span class="line">    double result = space * 1.4;</span><br><span class="line">    if (space &gt; 600)</span><br><span class="line">    &#123;</span><br><span class="line">        result = space * 1.35;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化-amp-流程"><a href="#优化-amp-流程" class="headerlink" title="优化&amp;流程"></a>优化&amp;流程</h2><p>到这里以后, 基本上功能就完成了, 然后添加一些小的修补功能和自动化流程以后, 就能使用了. 不过还有个优化的地方, 就是在一次跳在正中心点以后, 下一个目标物上会出现一个白色小圈圈, 表示跳那里能出现<code>2x</code>加分. 利用好这个点, 可以极大的缩减点位计算幅度. 那么流程就变成如下:</p>
<ol>
<li>寻找自己点坐标;</li>
<li>寻找顶点坐标(需要排除自己的位置);</li>
<li>试图根据顶点坐标寻找白圈;</li>
<li>如果找到白圈 -&gt; 返回;</li>
<li>如果没找到, 寻找右端点;</li>
<li>如果右端点不存在或者被自己挡住, 寻找左端点;</li>
<li>根据端点计算出目标点距离, 返回;</li>
</ol>
<h3 id="试图寻找中心白圈"><a href="#试图寻找中心白圈" class="headerlink" title="试图寻找中心白圈"></a>试图寻找中心白圈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 试图寻找下一步中间的白点(如果上一步是中心点)</span><br><span class="line">/// 从顶点开始, 寻找整个可能的格子空间,</span><br><span class="line">/// 记录所有颜色值为白点的点.</span><br><span class="line">/// 如果这些点最终能构成符合大小的圆形,</span><br><span class="line">/// 那么可以确定为中心点.</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">private Point TryFindCenterWhitePoint(int[][] imgRGBArray, Point chessPoint, Point topPoint)</span><br><span class="line">&#123;</span><br><span class="line">    var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]);</span><br><span class="line"></span><br><span class="line">    //从顶点开始往右边找</span><br><span class="line">    //最高高度设置为200</span><br><span class="line">    var maxHeight = 200;</span><br><span class="line">    var maxWidth = 300;</span><br><span class="line">    Point centerPoint = new Point(0, 0);</span><br><span class="line">    var hasFindCenterPoint = false;</span><br><span class="line"></span><br><span class="line">    for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var j = topPoint.X; j &lt; topPoint.X + maxWidth; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!hasFindCenterPoint)</span><br><span class="line">            &#123;</span><br><span class="line">                if (topPoint.X - j &gt; 0 &amp;&amp; RGB.FromInt(imgRGBArray[i][topPoint.X - j]) == TargetCenterWhitePointColor)</span><br><span class="line">                &#123;</span><br><span class="line">                    var centerPointMay = TryFindWhiteCircleAtPosition(imgRGBArray, i, topPoint.X - j);</span><br><span class="line">                    if (centerPointMay == ErrorPoint)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        centerPoint = centerPointMay;</span><br><span class="line">                        hasFindCenterPoint = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (j &lt; imgRGBArray[i].Length &amp;&amp; RGB.FromInt(imgRGBArray[i][j]) == TargetCenterWhitePointColor)</span><br><span class="line">                &#123;</span><br><span class="line">                    var centerPointMay = TryFindWhiteCircleAtPosition(imgRGBArray, i, j);</span><br><span class="line">                    if (centerPointMay == ErrorPoint)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        centerPoint = centerPointMay;</span><br><span class="line">                        hasFindCenterPoint = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasFindCenterPoint)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasFindCenterPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        return centerPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    return ErrorPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 在指定坐标(白色圆形顶部)判断是否能找到白色圆形</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;_i&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;_j&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">private Point TryFindWhiteCircleAtPosition(int[][] imgRGBArray, int _i, int _j)</span><br><span class="line">&#123;</span><br><span class="line">    var maxWhiteCircleHeight = 28;</span><br><span class="line">    var maxWhiteCircleWidth = 45;</span><br><span class="line"></span><br><span class="line">    var startPointSpaceBetweenCircle = maxWhiteCircleWidth / 2;</span><br><span class="line"></span><br><span class="line">    var minWhiteCircleHeight = 20;</span><br><span class="line">    var minWhiteCircleWidth = 35;</span><br><span class="line"></span><br><span class="line">    var leftTopPoint = new Point(1920 - 1, 1080 - 1);</span><br><span class="line">    var rightBottomPoint = new Point(0, 0);</span><br><span class="line"></span><br><span class="line">    var centerPoint = new Point(0, 0);</span><br><span class="line">    var centerPointAddCount = 0;</span><br><span class="line"></span><br><span class="line">    //根据平均统计,找到最中心的点</span><br><span class="line">    for (var i = _i; i &lt; _i + maxWhiteCircleHeight; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var j = _j - startPointSpaceBetweenCircle; j &lt; _j + maxWhiteCircleWidth + startPointSpaceBetweenCircle; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (j &lt; 0 || j &gt; imgRGBArray[0].Length)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (RGB.FromInt(imgRGBArray[i][j]) == TargetCenterWhitePointColor)</span><br><span class="line">            &#123;</span><br><span class="line">                leftTopPoint.Y = Math.Min(leftTopPoint.Y, i);</span><br><span class="line">                leftTopPoint.X = Math.Min(leftTopPoint.X, j);</span><br><span class="line">                rightBottomPoint.Y = Math.Max(rightBottomPoint.Y, i);</span><br><span class="line">                rightBottomPoint.X = Math.Max(rightBottomPoint.X, j);</span><br><span class="line">                centerPoint.Y += i;</span><br><span class="line">                centerPoint.X += j;</span><br><span class="line">                centerPointAddCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    centerPoint = new Point(centerPoint.X / centerPointAddCount, centerPoint.Y / centerPointAddCount);</span><br><span class="line"></span><br><span class="line">    var middlePoint = new Point((leftTopPoint.X + rightBottomPoint.X) / 2, (leftTopPoint.Y + rightBottomPoint.Y) / 2);</span><br><span class="line"></span><br><span class="line">    //判断该点周围全是白色</span><br><span class="line">    for (var i = centerPoint.Y - 3; i &lt;= centerPoint.Y + 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (var j = centerPoint.X - 10; j &lt;= centerPoint.X + 10; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (RGB.FromInt(imgRGBArray[i][j]) != TargetCenterWhitePointColor)</span><br><span class="line">            &#123;</span><br><span class="line">                return ErrorPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //最大距离之外不是白色, 最小距离之内全是白色</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y - maxWhiteCircleHeight / 2][centerPoint.X]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y + maxWhiteCircleHeight / 2][centerPoint.X]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X - maxWhiteCircleWidth / 2]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X + maxWhiteCircleWidth / 2]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y - minWhiteCircleHeight / 2][centerPoint.X]) != TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y + minWhiteCircleHeight / 2][centerPoint.X]) != TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X - minWhiteCircleWidth / 2]) != TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X + minWhiteCircleWidth / 2]) != TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //最大边框处不应该有白色</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[leftTopPoint.Y][leftTopPoint.X]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[leftTopPoint.Y][rightBottomPoint.X]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[rightBottomPoint.Y][rightBottomPoint.X]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RGB.FromInt(imgRGBArray[rightBottomPoint.Y][leftTopPoint.X]) == TargetCenterWhitePointColor)</span><br><span class="line">    &#123;</span><br><span class="line">        return ErrorPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetPointWithRectColor(imgRGBArray, leftTopPoint.Y, leftTopPoint.X, 3, CenterBoxColor);</span><br><span class="line">    SetPointWithRectColor(imgRGBArray, leftTopPoint.Y, rightBottomPoint.X, 3, CenterBoxColor);</span><br><span class="line">    SetPointWithRectColor(imgRGBArray, rightBottomPoint.Y, rightBottomPoint.X, 3, CenterBoxColor);</span><br><span class="line">    SetPointWithRectColor(imgRGBArray, rightBottomPoint.Y, leftTopPoint.X, 3, CenterBoxColor);</span><br><span class="line"></span><br><span class="line">    return centerPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>开启一个新线程执行循环跳, 再点一次干掉线程.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void BtnStartJump_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    isDoingJump = !isDoingJump;</span><br><span class="line">    if (isDoingJump)</span><br><span class="line">    &#123;</span><br><span class="line">        myLog.AppendToFile(LogFilePath, &quot;开始跳...&quot;);</span><br><span class="line">        BtnStartJump.Text = &quot;正在跳...&quot;;</span><br><span class="line">        jumpThread = new Thread(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            while (isDoingJump)</span><br><span class="line">            &#123;</span><br><span class="line">                GetAndroidScreen();</span><br><span class="line">                var space = AnalyseSpace();</span><br><span class="line">                System.Threading.Thread.Sleep(JumpDelay);</span><br><span class="line">                var pressTime = GetPressTimeBySpace(space);</span><br><span class="line">                ExecCmd(ADBPath + string.Format(&quot;shell input swipe 500 500 501 501 &#123;0&#125;&quot;, pressTime));</span><br><span class="line">                System.Threading.Thread.Sleep(pressTime + ShotScreenDelay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        jumpThread.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        myLog.AppendToFile(LogFilePath, &quot;跳完了&quot;);</span><br><span class="line">        BtnStartJump.Text = &quot;开始跳!&quot;;</span><br><span class="line">        jumpThread.Abort();</span><br><span class="line">        jumpThread = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>然后就是加入日志模块, 和图片保存, 将每次跳和计算的结果都保存起来, 以供之后分析.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class JumpLog</span><br><span class="line">&#123;</span><br><span class="line">    public JumpLog()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JumpLog(DateTime shotScreenTime)</span><br><span class="line">    &#123;</span><br><span class="line">        this.ShotScreenTime = shotScreenTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DateTime ShotScreenTime &#123; get; set; &#125;</span><br><span class="line">    public DateTime AnalyseStartTime &#123; get; set; &#125;</span><br><span class="line">    public DateTime AnalyseEndTime &#123; get; set; &#125;</span><br><span class="line">    public int AnalyseTime</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return (int)(AnalyseEndTime - AnalyseStartTime).TotalMilliseconds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public double AnalyseSpace &#123; get; set; &#125;</span><br><span class="line">    public Point TopPointPosition &#123; get; set; &#125;</span><br><span class="line">    public Point RightPointPosition &#123; get; set; &#125;</span><br><span class="line">    public Point LeftPointPosition &#123; get; set; &#125;</span><br><span class="line">    public Point CenterWhitePointPosition &#123; get; set; &#125;</span><br><span class="line">    public JumpLogPointPositionType GetPointPositionType &#123; get; set; &#125;</span><br><span class="line">    public Point TargetPointPosition &#123; get; set; &#125;</span><br><span class="line">    public Point SelfChessPointPosition &#123; get; set; &#125;</span><br><span class="line">    public int PressTime &#123; get; set; &#125;</span><br><span class="line">    public string ScreenImageFileName &#123; get; set; &#125;</span><br><span class="line">    public void AppendToFile(string filePath, string content)</span><br><span class="line">    &#123;</span><br><span class="line">        using (var fileStream = File.Open(filePath, FileMode.Append, FileAccess.Write))</span><br><span class="line">        &#123;</span><br><span class="line">            var writeStream = new StreamWriter(fileStream, Encoding.UTF8);</span><br><span class="line">            writeStream.WriteLine(string.Format(&quot;[&#123;0&#125;] : &#123;1&#125;&quot;, DateTime.Now.GetCommonDateString(), content));</span><br><span class="line">            writeStream.Flush();</span><br><span class="line">            writeStream.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void AppendToFile(string filePath)</span><br><span class="line">    &#123;</span><br><span class="line">        AppendToFile(filePath, GetLogString());</span><br><span class="line">    &#125;</span><br><span class="line">    private string GetLogString()</span><br><span class="line">    &#123;</span><br><span class="line">        return string.Format(&quot;[截图时间:&#123;0&#125;] [分析耗时:&#123;1&#125;ms] [分析最终距离:&#123;2&#125;px] [按压时间:&#123;3&#125;] [定位模式:&#123;4&#125;] [顶点坐标:&#123;5&#125;] [定位点坐标:&#123;6&#125;] [目标点坐标:&#123;7&#125;] [棋子坐标:&#123;8&#125;] [图片名称:&#123;9&#125;]&quot;,</span><br><span class="line">            ShotScreenTime.GetCommonDateString(), AnalyseTime, AnalyseSpace.ToString(&quot;0.00&quot;), PressTime,</span><br><span class="line">            GetPointPositionType.GetDescription(), TopPointPosition.ToString(),</span><br><span class="line">            GetRightAnchorPointPosition().ToString(), TargetPointPosition.ToString(),</span><br><span class="line">            SelfChessPointPosition.ToString(), ScreenImageFileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Point GetRightAnchorPointPosition()</span><br><span class="line">    &#123;</span><br><span class="line">        switch (GetPointPositionType)</span><br><span class="line">        &#123;</span><br><span class="line">            case JumpLogPointPositionType.Center: return CenterWhitePointPosition;</span><br><span class="line">            case JumpLogPointPositionType.Right: return RightPointPosition;</span><br><span class="line">            case JumpLogPointPositionType.Left: return LeftPointPosition;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Point(-1, -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public enum JumpLogPointPositionType</span><br><span class="line">&#123;</span><br><span class="line">    [Description(&quot;通过中心白点定位&quot;)]</span><br><span class="line">    Center = 1,</span><br><span class="line">    [Description(&quot;通过右端点定位&quot;)]</span><br><span class="line">    Right = 2,</span><br><span class="line">    [Description(&quot;通过左端点定位&quot;)]</span><br><span class="line">    Left = 4,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class StaticJumpLogPointPositionTypeHelp</span><br><span class="line">&#123;</span><br><span class="line">    public static string GetDescription(this JumpLogPointPositionType type)</span><br><span class="line">    &#123;</span><br><span class="line">        FieldInfo EnumInfo = type.GetType().GetField(type.ToString());</span><br><span class="line">        DescriptionAttribute[] EnumAttributes = (DescriptionAttribute[])EnumInfo.</span><br><span class="line">            GetCustomAttributes(typeof(DescriptionAttribute), false);</span><br><span class="line">        if (EnumAttributes.Length &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return EnumAttributes[0].Description;</span><br><span class="line">        &#125;</span><br><span class="line">        return type.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/images/wx-jump-game/program-run.jpg"><br><img src="/images/wx-jump-game/program-log.jpg"><br><img src="/images/wx-jump-game/screenshot-20180109-121451-analysed.png"><br><img src="/images/wx-jump-game/screenshot-20180109-121459-analysed.png"><br><img src="/images/wx-jump-game/screenshot-20180109-121507-analysed.png"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>微信跳一跳自动辅助</p><p><a href="https://mosby-zhou.github.io/2018/01-08-wechat-jump-game/">https://mosby-zhou.github.io/2018/01-08-wechat-jump-game/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Mosby</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-01-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2018-01-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/others/">others</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" href="https://www.buymeacoffee.com/mosby" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/03-12-xposed-sport-edit/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">xposed 插件开发</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2017/12-25-quantum-computing/"><span class="level-item">量子计算原理入门</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "cc068f1df78cf29360241e90e492f6b8",
            repo: "mosby-zhou.github.io",
            owner: "mosby-zhou",
            clientID: "16bcda17da1d8096c181",
            clientSecret: "eeca61cbccf5f011dc54308ffa8dbfba816efe32",
            admin: ["mosby-zhou"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Mosby"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Mosby</p><p class="is-size-6 is-block">Full stack development</p><p class="is-size-6 is-flex justify-content-center"><a class="link-muted" target="_blank" href="https://www.amap.com/search?query=%E5%B9%BF%E5%B7%9E"><i class="fas fa-map-marker-alt mr-1"></i></a><span>Guangzhou</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">83</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/mosby-zhou" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#思路"><span class="level-left"><span class="level-item">1</span><span class="level-item">思路</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#手机截图"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">手机截图</span></span></a></li><li><a class="level is-mobile" href="#按压命令"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">按压命令</span></span></a></li></ul></li><li><a class="level is-mobile" href="#开始"><span class="level-left"><span class="level-item">2</span><span class="level-item">开始</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#帮助类库"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">帮助类库</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分析主函数"><span class="level-left"><span class="level-item">3</span><span class="level-item">分析主函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#计算目标点坐标"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">计算目标点坐标</span></span></a></li><li><a class="level is-mobile" href="#寻找顶点坐标"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">寻找顶点坐标</span></span></a></li><li><a class="level is-mobile" href="#寻找右端点坐标"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">寻找右端点坐标</span></span></a></li><li><a class="level is-mobile" href="#寻找左端点坐标"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">寻找左端点坐标</span></span></a></li><li><a class="level is-mobile" href="#寻找自己棋子坐标"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">寻找自己棋子坐标</span></span></a></li><li><a class="level is-mobile" href="#计算距离"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">计算距离</span></span></a></li><li><a class="level is-mobile" href="#计算跳跃时间"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">计算跳跃时间</span></span></a></li></ul></li><li><a class="level is-mobile" href="#优化-amp-流程"><span class="level-left"><span class="level-item">4</span><span class="level-item">优化&amp;流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#试图寻找中心白圈"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">试图寻找中心白圈</span></span></a></li><li><a class="level is-mobile" href="#自动化"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">自动化</span></span></a></li><li><a class="level is-mobile" href="#日志记录"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">日志记录</span></span></a></li></ul></li><li><a class="level is-mobile" href="#运行结果"><span class="level-left"><span class="level-item">5</span><span class="level-item">运行结果</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Code/"><span class="level-start"><span class="level-item">Code</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/Code/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Code/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Code/Regex/"><span class="level-start"><span class="level-item">Regex</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Code/Sql/"><span class="level-start"><span class="level-item">Sql</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Server/"><span class="level-start"><span class="level-item">Server</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/Server/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Server/Egg/"><span class="level-start"><span class="level-item">Egg</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Server/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Server/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">61</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/Angularjs/"><span class="level-start"><span class="level-item">Angularjs</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/ES6/"><span class="level-start"><span class="level-item">ES6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Extensions/"><span class="level-start"><span class="level-item">Extensions</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Next/"><span class="level-start"><span class="level-item">Next</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/React/"><span class="level-start"><span class="level-item">React</span></span><span class="level-end"><span class="level-item tag">39</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/React-Native/"><span class="level-start"><span class="level-item">React Native</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/egg/"><span class="tag">egg</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/others/"><span class="tag">others</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/programming/"><span class="tag">programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">40</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react-native/"><span class="tag">react-native</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql/"><span class="tag">sql</span><span class="tag">3</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Mosby" height="28"></a><p class="is-size-7"><span>© <span id="footer_site_year">2021</span> Mosby</span><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var ThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/mermaid.min.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>